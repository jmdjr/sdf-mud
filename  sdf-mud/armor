OLDreset.c: * pRoom->people, rch->carrying, obj->contains, and pArea->reset_first ..
OLDreset.c:      pRoom = ch->in_room;
OLDreset.c:      char *nm = ( ch->substate == SUB_REPEATCMD ? "" : ( aRoom ? "rreset " : "reset " ) );
OLDreset.c:      ch->substate = SUB_REPEATCMD;
OLDreset.c:      ch->dest_buf = ( aRoom ? ( void * )aRoom : ( void * )pArea );
OLDreset.c:         vnum = ( aRoom ? aRoom->vnum : ch->in_room->vnum );
OLDreset.c:            pRoom = ch->in_room;
OLDreset.c:            pRoom = ch->in_room;
OLDreset.c:   if( ch->substate == SUB_REPEATCMD )
OLDreset.c:      ch->substate = SUB_NONE;
OLDreset.c:      ch->substate = SUB_REPEATCMD;
OLDreset.c:      ch->last_cmd = ( aRoom ? do_rreset : do_reset );
OLDreset.c:   if( ch->substate == SUB_REPEATCMD )
OLDreset.c:      pArea = ch->dest_buf;
OLDreset.c:      if( pArea && pArea != ch->pcdata->area && pArea != ch->in_room->area )
OLDreset.c:            bug( "do_reset: %s's dest_buf points to invalid area", ch->name );   /* why was this cast to an int? */
OLDreset.c:            ch->substate = SUB_NONE;
OLDreset.c:            ch->dest_buf = NULL;
OLDreset.c:         ch->substate = SUB_NONE;
OLDreset.c:         ch->dest_buf = NULL;
OLDreset.c:         pArea = ch->pcdata->area;
OLDreset.c:         pArea = ch->in_room->area;
OLDreset.c:      pArea = ch->pcdata->area;
OLDreset.c:   if( ch->substate == SUB_REPEATCMD )
OLDreset.c:      pRoom = ch->dest_buf;
OLDreset.c:         bug( "do_rreset: %s's dest_buf points to invalid room", ( int )ch->name );
OLDreset.c:      ch->substate = SUB_NONE;
OLDreset.c:      ch->dest_buf = NULL;
OLDreset.c:      pRoom = ch->in_room;
OLDreset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
OLDreset.c:      add_reset( pArea, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
OLDreset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
OLDreset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata || !ch->pcdata->area )
OLDreset.c:   pArea = ch->pcdata->area;
OLDreset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata || !ch->pcdata->area )
OLDreset.c:   pArea = ch->pcdata->area;
act_comm.c:   ROOM_INDEX_DATA *room = ch->in_room;
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata )
act_comm.c:   drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:   if( IS_SET( och->deaf, channel ) )
act_comm.c:         && ( !str_cmp( och->pcdata->council_name, "Newbie Council" )
act_comm.c:              || !str_cmp( och->pcdata->council2_name, "Newbie Council" ) ) ) )
act_comm.c:   if( channel == CHANNEL_YELL && vch->in_room->area != ch->in_room->area )
act_comm.c:      if( vch->pcdata->clan != ch->pcdata->clan )
act_comm.c:    * if (vch->pcdata->guild != ch->pcdata->guild )
act_comm.c:      if( ( vch->pcdata->council != ch->pcdata->council && vch->pcdata->council2 != ch->pcdata->council ) )
act_comm.c:      if( ( vch->pcdata->council != ch->pcdata->council2 && vch->pcdata->council2 != ch->pcdata->council2 ) )
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:      position = ch->position;
act_comm.c:      ch->position = POS_STANDING;
act_comm.c:      ch->position = position;
act_comm.c:      position = ch->position;
act_comm.c:      ch->position = POS_STANDING;
act_comm.c:      ch->position = position;
act_comm.c:      position = ch->position;
act_comm.c:      ch->position = POS_STANDING;
act_comm.c:      ch->position = position;
act_comm.c:      ch_printf( victim, "&W^z%s beeps you from '%s'^x&w\a\r\n", PERS( ch, victim ), ch->in_room->name );
act_comm.c:   if( ch->position == POS_FIGHTING
act_comm.c:       || ch->position == POS_EVASIVE
act_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
act_comm.c:   if( ch->position < POS_STUNNED )
act_comm.c:   if( IS_PKILL( ch ) && ch->wimpy > ( int )ch->max_hit / 2.25 )
act_comm.c:   drop_artifacts( ch, ch->last_carrying );
act_comm.c:   if( ch->position == POS_MOUNTED )
act_comm.c:   sprintf( log_buf, "%s has quit (Room %d).", ch->name, ( ch->in_room ? ch->in_room->vnum : -1 ) );
act_comm.c:   if( sysdata.save_pets && ch->pcdata->pet )
act_comm.c:      act( AT_BYE, "$N follows $S master into the Void.", ch, NULL, ch->pcdata->pet, TO_ROOM );
act_comm.c:      extract_char( ch->pcdata->pet, TRUE );
act_comm.c:   if( ch->pcdata->clan )
act_comm.c:      save_clan( ch->pcdata->clan );
act_comm.c:   if( ch->level >= 1 )
act_comm.c:      for( vch = first_char; vch; vch = vch->next )
act_comm.c:    * Expecting a ch->last_carrying or an obj->last_content
act_comm.c:         obj_to_room( tobj, ch->in_room );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      xSET_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_ANSI );
act_comm.c:   if( ch->level < 2 && ch->level2 == -1 && ch->level3 == -1 )
act_comm.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master )
act_comm.c:      act( AT_PLAIN, "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:      if( !ch->master )
act_comm.c:    if ( ( ch->level - victim->level < -10 || ch->level - victim->level >  10 )
act_comm.c:    &&   !IS_HERO(ch) && !(ch->level < 15 && !IS_NPC(victim) 
act_comm.c:   if( ch->master )
act_comm.c:   if( ch->master )
act_comm.c:   ch->master = master;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PET ) && !IS_NPC( master ) )
act_comm.c:   if( !ch->master )
act_comm.c:   if( IS_NPC( ch ) && !IS_NPC( ch->master ) && ch->master->pcdata->pet == ch )
act_comm.c:      ch->master->pcdata->pet = NULL;
act_comm.c:      xREMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:   if( can_see( ch->master, ch ) )
act_comm.c:      if( !( !IS_NPC( ch->master ) && IS_IMMORTAL( ch ) && !IS_IMMORTAL( ch->master ) ) )
act_comm.c:         act( AT_ACTION, "$n stops following you.", ch, NULL, ch->master, TO_VICT );
act_comm.c:   act( AT_ACTION, "You stop following $N.", ch, NULL, ch->master, TO_CHAR );
act_comm.c:   ch->master = NULL;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( ch->master )
act_comm.c:   ch->leader = NULL;
act_comm.c:   for( fch = first_char; fch; fch = fch->next )
act_comm.c:      if( fch->master == ch )
act_comm.c:      if( fch->leader == ch )
act_comm.c:         fch->leader = fch;
act_comm.c:   for( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:      och_next = och->next_in_room;
act_comm.c:      if( IS_AFFECTED( och, AFF_CHARM ) && och->master == ch && ( fAll || och == victim ) )
act_comm.c:      sprintf( log_buf, "%s: order %s.", ch->name, argbuf );
act_comm.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
act_comm.c:      leader = ch->leader ? ch->leader : ch;
act_comm.c:                 PERS( leader, ch ), ch->level < LEVEL_AVATAR ? " [to lvl]" : "" );
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:                                              * if (IS_AFFECTED(gch, AFF_POSSESS) || IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS))
act_comm.c:                                              * gch->level,
act_comm.c:            if( gch->alignment > 750 )
act_comm.c:            else if( gch->alignment > 350 )
act_comm.c:            else if( gch->alignment > 150 )
act_comm.c:            else if( gch->alignment > -150 )
act_comm.c:            else if( gch->alignment > -350 )
act_comm.c:            else if( gch->alignment > -750 )
act_comm.c:            ch_printf( ch, "%-2d %2.2s %3.3s", gch->level, buf,
act_comm.c:                        * IS_NPC(gch) ? "Mob" : class_table[gch->class]->who_name 
act_comm.c:            if( gch->hit < gch->max_hit / 4 )
act_comm.c:            else if( gch->hit < gch->max_hit / 2.5 )
act_comm.c:            ch_printf( ch, "%5d", gch->hit );
act_comm.c:            ch_printf( ch, "/%-5d ", gch->max_hit );
act_comm.c:                          IS_VAMPIRE( gch ) ? gch->pcdata->condition[COND_BLOODTHIRST] : gch->mana,
act_comm.c:                          IS_VAMPIRE( gch ) ? 10 + gch->level : gch->max_mana );
act_comm.c:            if( gch->mental_state < -25 || gch->mental_state > 25 )
act_comm.c:                       gch->mental_state > 75 ? "+++" :
act_comm.c:                       gch->mental_state > 50 ? "=++" :
act_comm.c:                       gch->mental_state > 25 ? "==+" :
act_comm.c:                       gch->mental_state > -25 ? "===" :
act_comm.c:                       gch->mental_state > -50 ? "-==" : gch->mental_state > -75 ? "--=" : "---" );
act_comm.c:            ch_printf( ch, "%5d ", gch->move );
act_comm.c:            ch_printf( ch, "%6s ", npc_race[gch->race] );
act_comm.c:            if( gch->level < LEVEL_AVATAR )
act_comm.c:               ch_printf( ch, "%8d ", exp_level( gch, gch->level + 1 ) - gch->exp );
act_comm.c:      if( ch->leader || ch->master )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:            gch->leader = NULL;
act_comm.c:            gch->master = NULL;
act_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:         if( ch != rch && !IS_NPC( rch ) && can_see( ch, rch ) && rch->master == ch && !ch->master && !ch->leader
act_comm.c:/*    	   &&   abs( ch->level - rch->level ) < 8  Level restrict on groups is stupid -- Scion */
act_comm.c:            rch->leader = ch;
act_comm.c:   if( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:   if( ch->level - victim->level < -8 || ch->level - victim->level > 8 || ( IS_PKILL( ch ) != IS_PKILL( victim ) ) )
act_comm.c:      if( ch->gold < amount )
act_comm.c:      if( ch->silver < amount )
act_comm.c:      if( ch->copper < amount )
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:   if( xIS_SET( ch->act, PLR_AUTOGOLD ) && members < 2 )
act_comm.c:      ch->gold -= amount;
act_comm.c:      ch->gold += share + extra;
act_comm.c:      ch->silver -= amount;
act_comm.c:      ch->silver += share + extra;
act_comm.c:      ch->copper -= amount;
act_comm.c:      ch->copper += share + extra;
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:            gch->gold += share;
act_comm.c:            gch->silver += share;
act_comm.c:            gch->copper += share;
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:/*    sprintf( buf, "%s tells the group '%s'.\r\n", ch->name, argument );*/
act_comm.c:   for( gch = first_char; gch; gch = gch->next )
act_comm.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:            int speakswell = UMIN( knows_language( gch, ch->speaking ),
act_comm.c:                                   knows_language( ch, ch->speaking ) );
act_comm.c:               ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name,
act_comm.c:               ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, argument );
act_comm.c:         if( knows_language( gch, ch->speaking ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:            ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, scramble( argument, ch->speaking ) );
act_comm.c:   if( ach->leader )
act_comm.c:      ach = ach->leader;
act_comm.c:   if( bch->leader )
act_comm.c:      bch = bch->leader;
act_comm.c:   if( IS_NPC( ch ) && !ch->speaks )   /* No langs = knows nothing for npcs */
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->speaks, ( language & ~LANG_CLAN ) ) )
act_comm.c:      return ( 50 + ( 25 - ch->mod_int ) * 2 );
act_comm.c:      if( IS_SET( race_table[ch->race]->language, language ) )
act_comm.c:         return ( ( 65 + ( 25 - ch->mod_int ) * 2 ) <= 100 ? ( 65 + ( 25 - ch->mod_int ) * 2 ) : 100 );
act_comm.c:         if( IS_SET( language, lang_array[lang] ) && IS_SET( ch->speaks, lang_array[lang] ) )
act_comm.c:               return ch->pcdata->learned[sn];
act_comm.c:   if( race_table[ch->race]->language & language )
act_comm.c:   if( ch->speaks & language )
act_comm.c:            if( ch->pcdata->learned[sn] >= 99 )
act_comm.c:      ch->speaking = ~LANG_CLAN;
act_comm.c:            if( lang_array[langs] == LANG_CLAN && ( IS_NPC( ch ) || !ch->pcdata->clan ) )
act_comm.c:            ch->speaking = lang_array[langs];
act_comm.c:      if( race_table[ch->race]->language & lang_array[lang] ||
act_comm.c:          lang_array[lang] == LANG_COMMON || ch->pcdata->learned[sn] >= 99 )
act_comm.c:      for( sch = ch->in_room->first_person; sch; sch = sch->next_in_room )
act_comm.c:         if( IS_NPC( sch ) && xIS_SET( sch->act, ACT_SCHOLAR )
act_comm.c:             && knows_language( sch, ch->speaking )
act_comm.c:             && ( !sch->speaking || knows_language( ch, sch->speaking ) ) )
act_comm.c:      if( countlangs( ch->speaks ) >= ( ch->level / 10 ) && ch->pcdata->learned[sn] <= 0 )
act_comm.c:      if( ch->practice < prac )
act_comm.c:      ch->practice -= prac;
act_comm.c:      ch->pcdata->learned[sn] += prct;
act_comm.c:      ch->pcdata->learned[sn] = UMIN( ch->pcdata->learned[sn], 99 );
act_comm.c:      SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:      if( ch->pcdata->learned[sn] == prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 99 )
act_comm.c:         if( ch->speaking & lang_array[lang] || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:   if( ch->level < 10 && ch->level2 == -1 && ch->level3 == -1 )
act_comm.c:   sprintf( save, "%s%c/%s", PLAYER_DIR, tolower( ch->pcdata->filename[0] ), capitalize( ch->pcdata->filename ) );
act_comm.c:   sprintf( back, "%s%c/%s", BACKUP_DIR, tolower( ch->pcdata->filename[0] ), capitalize( ch->pcdata->filename ) );
act_comm.c:      if( strstr( argument, capitalize( ch->name ) ) || strstr( argument, strlower( ch->name ) ) )
act_comm.c:      for( vic = ch->in_room->first_person; vic; vic = vic->next_in_room )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   ms = ( ch->mental_state ? ch->mental_state : 1 )
act_info.c:      * ( IS_NPC( ch ) ? 1 : ( ch->pcdata->condition[COND_DRUNK] ? ( ch->pcdata->condition[COND_DRUNK] / 12 ) : 1 ) );
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:/*	if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:      if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   if( IS_NPC( victim ) && ch->questmob > 0 && victim->pIndexData->vnum == ch->questmob )
act_info.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:   if( IS_NPC( victim ) && ch->mount && ch->mount == victim && ch->in_room == ch->mount->in_room )
act_info.c:            if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:         if( ch->position == POS_SITTING || ch->position == POS_RESTING || 
act_info.c:             ch->position == POS_RECOVER )
act_info.c:         if( ch->position == POS_RESTING )
act_info.c:         else if( ch->position == POS_MOUNTED )
act_info.c:         if( ch->position == POS_SITTING )
act_info.c:         else if( ch->position == POS_RESTING )
act_info.c:   if( can_see( victim, ch ) && !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_WIZINVIS ) )
act_info.c:   else if( ch->pcdata->learned[gsn_peek] > 0 )
act_info.c:   for( rch = list; rch; rch = rch->next_in_room )
act_info.c:      else if( room_is_dark( ch->in_room ) && IS_AFFECTED( rch, AFF_INFRARED ) && !( !IS_NPC( rch ) && IS_IMMORTAL( rch ) ) )
act_info.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:      STRFREE( ch->in_room->name );
act_info.c:      DISPOSE( ch->in_room->description );
act_info.c:    * else if (xIS_SET(ch->act, PLR_HOLYLIGHT))
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:       && !xIS_SET( ch->act, PLR_HOLYLIGHT ) && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && 
act_info.c:room_is_dark( ch->in_room ) && !is_class(ch, CLASS_VAMPIRE) && ch->race != RACE_VAMPIRE )
act_info.c:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      switch ( ch->in_room->sector_type )
act_info.c:      troom = ch->in_room;
act_info.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:          * send_to_char( ch->in_room->name, ch );
act_info.c:      if( arg1[0] == '\0' || ( !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c:         showRoom( ch, ch->in_room );
act_info.c:          * if( !ch->in_room->compress )
act_info.c:          * ch_printf( ch, "%s", ch->in_room->description );
act_info.c:          * else if (xIS_SET(ch->act, PLR_HOLYLIGHT))
act_info.c:          * decompressRoom( ch->in_room );
act_info.c:          * ch_printf( ch, "&z&WCompressed&w -\r\n%s", ch->in_room->uncomp_desc );
act_info.c:          * DISPOSE( ch->in_room->uncomp_desc );
act_info.c:          * decompressRoom( ch->in_room );
act_info.c:          * ch_printf( ch, "%s", ch->in_room->uncomp_desc );
act_info.c:          * DISPOSE( ch->in_room->uncomp_desc );
act_info.c:       * if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOMAP) )  
act_info.c:	    if(ch->in_room->map != NULL)
act_info.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AUTOEXIT ) )
act_info.c:      else if( xIS_SET( ch->act, PLR_AUTOMAP ) )   /* config +map now works -Garinan */
act_info.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      if( !CAN_WEAR( obj, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
act_info.c:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:            for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                  original = ch->in_room;
act_info.c:   if( ( pdesc = get_extra_descr( arg1, ch->in_room->first_extradesc ) ) != NULL )
act_info.c:         original = ch->in_room;
act_info.c:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_info.c:         xREMOVE_BIT( ch->act, PLR_BRIEF );
act_info.c:   if( xIS_SET( ch->act, PLR_AUTOMAP ) )  // was commented
act_info.c:      prep_map( ch->in_room, min, max );
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:          * if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:      else if( !IS_NPC( ch ) && IS_SET( ch->in_room->area->flags, AFLAG_EXIT_NAMES ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   else if( fAuto && !xIS_SET( ch->act, PLR_HOLYLIGHT ) && !showmap )
act_info.c:   temp = ( ch->in_room->area->weather->temp + 3 * weath_unit - 1 ) / weath_unit;
act_info.c:   precip = ( ch->in_room->area->weather->precip + 3 * weath_unit - 1 ) / weath_unit;
act_info.c:   wind = ( ch->in_room->area->weather->wind + 3 * weath_unit - 1 ) / weath_unit;
act_info.c:      SET_BIT( ch->pcdata->flags, PCFLAG_HELPSTART );
act_info.c:   if( !ch->desc )
act_info.c:   switch ( ch->substate )
act_info.c:         if( ( pHelp = ch->dest_buf ) == NULL )
act_info.c:            bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
act_info.c:   ch->substate = SUB_HELP_EDIT;
act_info.c:   ch->dest_buf = pHelp;
act_info.c:      if( !wch->leader || wch->leader == wch || !wch->leader->desc ||
act_info.c:          IS_NPC( wch->leader ) || IS_IMMORTAL( wch ) || IS_IMMORTAL( 
act_info.c:           wch->leader ) )
act_info.c:         if( wch->leader && wch->leader != wch && wch->leader->desc &&
act_info.c:             !IS_NPC( wch->leader ) && !IS_IMMORTAL( wch ) &&
act_info.c:             !IS_IMMORTAL( wch->leader ) && ( whogr_t = find_whogr( wch->leader->desc, first_whogr ) ) )
act_info.c:      if( wch->level < iLevelLower || wch->level > iLevelUpper
act_info.c:          || ( fImmortalOnly && wch->level < LEVEL_IMMORTAL ) || ( fClassRestrict && !rgfClass[wch->class] ) || ( fClassRestrict && !rgfClass[wch->class2] ) || ( fClassRestrict && !rgfClass[wch->class3] ) || ( fRaceRestrict && !rgfRace[wch->race] ) || ( fClanMatch && ( pClan != wch->pcdata->clan ) )   /* SB */
act_info.c:          || ( ( fCouncilMatch && ( pCouncil != wch->pcdata->council ) )   /* SB */
act_info.c:               && ( fCouncilMatch && ( pCouncil != wch->pcdata->council2 ) ) ) /*RTD*/
act_info.c:          || ( fDeityMatch && ( pDeity != wch->pcdata->deity ) ) )
act_info.c:      if( fLeader && !( wch->pcdata->council &&
act_info.c:                        ( ( wch->pcdata->council->head2 &&
act_info.c:                            !str_cmp( wch->pcdata->council->head2, wch->name ) ) ||
act_info.c:                          ( wch->pcdata->council->head &&
act_info.c:                            !str_cmp( wch->pcdata->council->head, wch->name ) ) ) ) &&
act_info.c:          !( wch->pcdata->clan && ( ( wch->pcdata->clan->deity &&
act_info.c:                                      !str_cmp( wch->pcdata->clan->deity, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->leader
act_info.c:                                         && !str_cmp( wch->pcdata->clan->leader, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number1
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number1, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number2
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number2, wch->name ) ) ) ) )
act_info.c:      if( fGroup && !wch->leader && !IS_SET( wch->pcdata->flags, PCFLAG_GROUPWHO ) && ( !whogr_p || !whogr_p->indent ) )
act_info.c:      if( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
act_info.c:         sprintf( char_name, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:         strcpy( char_name, wch->name );
act_info.c:      if( wch->level2 == -1 )
act_info.c:         sprintf( class_text, "%3d %3.3s", wch->level,
act_info.c:                  !str_cmp( class_table[wch->class]->who_name, "Assassin" ) ? "Asn" : class_table[wch->class]->who_name );
act_info.c:      else if( wch->level3 == -1 )
act_info.c:                  wch->level,
act_info.c:                  !str_cmp( class_table[wch->class]->who_name, "Assassin" )
act_info.c:                  ? "Asn" : class_table[wch->class]->who_name,
act_info.c:                  wch->level2,
act_info.c:                  !str_cmp( class_table[wch->class2]->who_name, "Assassin" ) ? "Asn" : class_table[wch->class2]->who_name );
act_info.c:                  wch->level,
act_info.c:                  !str_cmp( class_table[wch->class]->who_name, "Assassin" ) ? "Asn" : class_table[wch->class]->who_name,
act_info.c:                   * wch->level2, 
act_info.c:                  !str_cmp( class_table[wch->class2]->who_name, "Assassin" ) ? "Asn" : class_table[wch->class2]->who_name,
act_info.c:                   * wch->level3, 
act_info.c:                  !str_cmp( class_table[wch->class3]->who_name, "Assassin" ) ? "Asn" : class_table[wch->class3]->who_name );
act_info.c:      switch ( wch->level )
act_info.c:      if( !str_cmp( wch->name, sysdata.guild_overseer ) )
act_info.c:      else if( !str_cmp( wch->name, sysdata.guild_advisor ) )
act_info.c:      else if( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c:         class = wch->pcdata->rank;
act_info.c:      if( IS_SET( wch->pcdata->flags, PCFLAG_ANONYMOUS ) && ( !ch || !IS_IMMORTAL( ch ) ) )
act_info.c:      if( wch->pcdata->clan )
act_info.c:         CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:           if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:           else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:      if( wch->pcdata->council )
act_info.c:         if( wch->pcdata->council->head2 == NULL || wch->pcdata->council->head2[0] == '\0' )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) || !str_cmp( wch->name, wch->pcdata->council->head2 ) )
act_info.c:         strcat( council_name, wch->pcdata->council_name );
act_info.c:      if( wch->pcdata->council2 )
act_info.c:         if( wch->pcdata->council2->head2 == NULL || wch->pcdata->council2->head2[0] == '\0' )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council2->head ) )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council2->head ) || !str_cmp( wch->name, wch->pcdata->council2->head2 ) )
act_info.c:         strcat( council2_name, wch->pcdata->council2_name );
act_info.c:      if( xIS_SET( wch->act, PLR_WIZINVIS ) )
act_info.c:         sprintf( invis_str, " &R(&W%d&R)&w", wch->pcdata->wizinvis );
act_info.c:            if( dcheck->character && wch->desc && dcheck->host == wch->desc->host )
act_info.c:                  IS_SET( wch->pcdata->flags, PCFLAG_DEADLY ) ? "&WP" : "-",
act_info.c:                  ( wch->fighting ? "&gF&W" : "-" ),
act_info.c:                  ( wch->position == POS_INCAP ) ? "&bI&W" : "-",
act_info.c:                  ( wch->pcdata->extraname ? wch->pcdata->extraname : "" ),
act_info.c:                  ( wch->pcdata->lastname ? wch->pcdata->lastname : "" ),
act_info.c:                  ( wch->pcdata->afkmsg ) ? wch->pcdata->afkmsg : wch->pcdata->title,
act_info.c:                  ( wch->bounty > 0 ) ? " &W(&RBOUNTY&W)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_MARRIED ) ? " &Y[&WWED&Y]&w " : "",
act_info.c:                  ( wch->desc && wch->desc->connected ) ? " &Y[&WWRITING&Y]&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_AFK ) ? " &Y[&WAWAY&Y]&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_ATTACKER ) ? " &R(&W^zATTACKER^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_COWARD ) ? " &R(&W^zCOWARD^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_KILLER ) ? " &R(&W^zKILLER^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_THIEF ) ? " &R(&W^zTHIEF^x&R)&w " : "" );
act_info.c:                  IS_SET( wch->pcdata->flags, PCFLAG_DEADLY ) ? "&WPK" : "&W--",
act_info.c:                  ( wch->pcdata->extraname ? wch->pcdata->extraname : "" ),
act_info.c:                  ( wch->pcdata->lastname ? wch->pcdata->lastname : "" ),
act_info.c:                  ( wch->pcdata->afkmsg ) ? wch->pcdata->afkmsg : wch->pcdata->title,
act_info.c:                  ( wch->bounty > 0 ) ? " &W(&RBOUNTY&W)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_MARRIED ) ? " &Y[&WWED&Y]&w " : "",
act_info.c:                  ( wch->desc && wch->desc->connected ) ? " &Y[&WWRITING&Y]&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_AFK ) ? " &Y[&WAWAY&Y]&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_ATTACKER ) ? " &R(&W^zATTACKER^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_COWARD ) ? " &R(&W^zCOWARD^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_KILLER ) ? " &R(&W^zKILLER^x&R)&w " : "",
act_info.c:                  xIS_SET( wch->act, PLR_THIEF ) ? " &R(&W^zTHIEF^x&R)&w " : "" );
act_info.c:         if( wch->leader || ( whogr_p && whogr_p->indent ) )
act_info.c:	for ( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:      pager_printf( ch, "\r\nPlayers near you in %s:\r\n", ch->in_room->area->name );
act_info.c:             && !IS_NPC( victim ) && victim->in_room && victim->in_room->area == ch->in_room->area && can_see( ch, victim ) )
act_info.c:             && victim->in_room->area == ch->in_room->area
act_info.c:   diff = victim->level - ch->level;
act_info.c:   diff = ( int )( victim->max_hit - ch->max_hit ) / 6;
act_info.c:    if ( ch->level < 2 )
act_info.c:                  && ( !IS_GUILDED( ch ) || ( ch->pcdata->clan->class != skill_table[sn]->guild ) ) ) )
act_info.c:         if( ch->level2 == -1 )
act_info.c:            if( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                || ( !IS_IMMORTAL( ch ) && skill_table[sn]->skill_level[ch->class] == 0 ) )
act_info.c:         else if( ch->level3 == -1 )
act_info.c:            if( ( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                  && ch->level < skill_table[sn]->skill_level[ch->class2] )
act_info.c:                || ( !IS_IMMORTAL( ch ) && ( skill_table[sn]->skill_level[ch->class] == 0
act_info.c:                                             && skill_table[sn]->skill_level[ch->class2] == 0 ) ) )
act_info.c:            if( ( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                  && ch->level < skill_table[sn]->skill_level[ch->class2]
act_info.c:                  && ch->level < skill_table[sn]->skill_level[ch->class3] )
act_info.c:                || ( !IS_IMMORTAL( ch ) && ( skill_table[sn]->skill_level[ch->class] == 0
act_info.c:                                             && skill_table[sn]->skill_level[ch->class2] == 0
act_info.c:                                             && skill_table[sn]->skill_level[ch->class3] == 0 ) ) )
act_info.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c:         if( ch->pcdata->learned[sn] == 0 )
act_info.c:         else if( ch->pcdata->learned[sn] > 0
act_info.c:                  && ( ch->pcdata->learned[sn] < skill_table[sn]->skill_adept[ch->class]
act_info.c:                       || ch->pcdata->learned[sn] < skill_table[sn]->skill_adept[ch->class2]
act_info.c:                       || ch->pcdata->learned[sn] < skill_table[sn]->skill_adept[ch->class3] ) )
act_info.c:         else if( ch->pcdata->learned[sn] > 0 )
act_info.c:         if( ch->pcdata->learned[sn] > 0 )
act_info.c:         pager_printf( ch, " &W%3d%%&w ", ch->pcdata->learned[sn] );
act_info.c:      pager_printf( ch, "&cYou have %d practice sessions left.\r\n", ch->practice );
act_info.c:      for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:      if( ch->practice <= 0 )
act_info.c:      if( ch->level2 == -1 )
act_info.c:         if( can_prac && ( ( sn == -1 ) || ( !IS_NPC( ch ) && ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                                              * &&  ch->level < skill_table[sn]->race_level[ch->race]
act_info.c:      else if( ch->level3 == -1 )
act_info.c:                       && ( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                            && ch->level < skill_table[sn]->skill_level[ch->class2] ) ) ) )
act_info.c:                       && ( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:                            && ch->level < skill_table[sn]->skill_level[ch->class2]
act_info.c:                            && ch->level < skill_table[sn]->skill_level[ch->class3] )
act_info.c:                        * &&  ch->level < skill_table[sn]->race_level[ch->race]
act_info.c:	     && ch->pcdata->clan->class != skill_table[sn]->guild )
act_info.c:       if ( mob->level < skill_table[sn]->skill_level[ch->class]
act_info.c:      adept = class_table[ch->class]->skill_adept * 0.2;
act_info.c:      if( ch->pcdata->learned[sn] >= adept )
act_info.c:         ch->practice--;
act_info.c:         ch->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c:         if( ch->pcdata->learned[sn] >= adept )
act_info.c:            ch->pcdata->learned[sn] = adept;
act_info.c:         wimpy = ( int )ch->max_hit / 2.25;
act_info.c:         wimpy = ( int )ch->max_hit / 1.2;
act_info.c:      wimpy = ( int )ch->max_hit / 5;
act_info.c:   if( IS_PKILL( ch ) && wimpy > ( int )ch->max_hit / 2.25 )
act_info.c:   else if( wimpy > ( int )ch->max_hit / 1.2 )
act_info.c:   ch->wimpy = wimpy;
act_info.c:    if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_info.c:   pwdnew = crypt( arg2, ch->name );
act_info.c:   DISPOSE( ch->pcdata->pwd );
act_info.c:   ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? "[+] PAGER" : "[-] pager", IS_SET( ch->pcdata->flags,
act_info.c:                 "[-] gag", xIS_SET( ch->act, PLR_BRIEF ) ? "[+] BRIEF" : "[-] brief", xIS_SET( ch->act,
act_info.c:                 : "[-] combine", xIS_SET( ch->act, PLR_BLANK ) ? "[+] BLANK" : "[-] blank", xIS_SET( ch->act,
act_info.c:                 "[+] PROMPT" : "[-] prompt", xIS_SET( ch->act, PLR_ANSI ) ? "[+] ANSI" : "[-] ansi", xIS_SET( ch->act,
act_info.c:                 "[+] RIP" : "[-] rip", xIS_SET( ch->act, PLR_NOMENU ) ? "[+] NOMENU" : "[-] nomenu",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NOBEEP ) ? "[+] NOBEEP" : "[-] nobeep", IS_SET( ch->pcdata->flags,
act_info.c:                 "[+] ANONYMOUS" : "[-] anonymous", xIS_SET( ch->act, PLR_AUTOMAP ) ? "[+] SHOWMAP" : "[-] showmap" );
act_info.c:                 xIS_SET( ch->act, PLR_AUTOSAC ) ? "[+] AUTOSAC"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOGOLD ) ? "[+] AUTOGOLD"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOLOOT ) ? "[+] AUTOLOOT"
act_info.c:                 : "[-] autoloot", xIS_SET( ch->act, PLR_AUTOEXIT ) ? "[+] AUTOEXIT" : "[-] autoexit" );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NORECALL ) ? "[+] NORECALL"
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NOSTUN ) ? "[+] NOSTUN"
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON ) ? "[+] NOSUMMON"
act_info.c:                 : "[-] nosummon", IS_SET( ch->pcdata->flags, PCFLAG_IMMPROOF ) ? "[+] IMMPROOF" : "[-] immproof" );
act_info.c:                 xIS_SET( ch->act, PLR_SHOVEDRAG ) ? "[+] DRAG"
act_info.c:                 : "[-] drag", xIS_SET( ch->act, PLR_NICE ) ? "[+] NICE" : "[-] nice" );
act_info.c:                 xIS_SET( ch->act, PLR_TELNET_GA ) ? "[+] TELNETGA"
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_GROUPWHO ) ? "[+] GROUPWHO"
act_info.c:                 : "[-] groupwho", IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) ? "[+] NOINTRO" : "[-] nointro" );
act_info.c:      ch_printf_color( ch, "Pager Length (%d)    Wimpy (&W%d&w)", ch->pcdata->pagerlen, ch->wimpy );
act_info.c:          * xIS_SET(ch->act, PLR_ROOMVNUM )      ? "+"
act_info.c:          * xIS_SET(ch->act, PLR_AUTOMAP  )      ? "+"
act_info.c:                    xIS_SET( ch->act, PLR_ROOMVNUM ) ? "[+] VNUM" : "[-] vnum", "", "" );
act_info.c:/*	xIS_SET( ch->act, PLR_AUTOMAP )			? "[+] MAP"
act_info.c:          * IS_SET( ch->pcdata->flags, PCFLAG_IMMPROOF )  ? "[+] IMMPROOF"
act_info.c:                 xIS_SET( ch->act, PLR_SILENCE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_EMOTE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_TELL ) ?
act_info.c:                 xIS_SET( ch->act, PLR_LITTERBUG ) ?
act_info.c:                 xIS_SET( ch->act, PLR_THIEF ) ?
act_info.c:                 xIS_SET( ch->act, PLR_KILLER ) ? " For the crime of murder you are sentenced to death...\r\n" : "" );
act_info.c:            xSET_BIT( ch->act, bit );
act_info.c:            xREMOVE_BIT( ch->act, bit );
act_info.c:            SET_BIT( ch->pcdata->flags, bit );
act_info.c:            REMOVE_BIT( ch->pcdata->flags, bit );
act_info.c:   if( xIS_SET( ch->act, PLR_AFK ) )
act_info.c:      xREMOVE_BIT( ch->act, PLR_AFK );
act_info.c:      if( ch->pcdata->afkmsg )
act_info.c:         STRFREE( ch->pcdata->afkmsg );
act_info.c:         ch->pcdata->afkmsg = NULL;
act_info.c:      xSET_BIT( ch->act, PLR_AFK );
act_info.c:         ch->pcdata->afkmsg = STRALLOC( buf );
act_info.c:   if( ch->class == CLASS_WARRIOR )
act_info.c:         if( ch->pcdata->learned[sn] < 1 || !skill->name || !skill->min_mana )
act_info.c:         if( ch->level >= skill->skill_level[ch->class] )
act_info.c:               if( ch->pcdata->condition[COND_BLOODTHIRST] >= BLOOD )
act_info.c:               if( ch->mana >= MANA )
act_info.c:            ch_printf( ch, "%s, '%s' doesn't use %s points.\r\n", ch->name, skill->name,
act_info.c:         if( ch->pcdata->learned[sn] < 1 )
act_info.c:            if( ch->level < skill->skill_level[ch->class] )
act_info.c:   classnum = ch->class;
act_info.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c:             && ( !charclass || ch->level2 == -1 || ch->level3 == -1
act_info.c:                  || i != skill_table[sn]->skill_level[ch->class2]
act_info.c:                  || i >= ch->level2 || i != skill_table[sn]->skill_level[ch->class3] || i >= ch->level3 ) )
act_info.c:         else if( i == skill_table[sn]->skill_level[ch->class2] )
act_info.c:            temp = ch->class2;
act_info.c:            temp = ch->class3;
act_info.c:                       skn, skill_table[sn]->name, ch->pcdata->learned[sn], skill_table[sn]->skill_adept[temp], buf );
act_info.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
act_info.c:         ch_printf( ch, "Pager is now enabled at %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:   ch->pcdata->pagerlen = atoi( arg );
act_info.c:   if( ch->pcdata->pagerlen < 5 )
act_info.c:      ch->pcdata->pagerlen = 5;
act_info.c:   ch_printf( ch, "Page pausing set to %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:      if( !ch->pcdata->first_ignored )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
act_info.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   else if( !strcmp( arg, "self" ) || nifty_is_name( arg, ch->name ) )
act_info.c:         if( !ch->reply )
act_info.c:            strcpy( arg, ch->reply->name );
act_info.c:      for( temp = ch->pcdata->first_ignored, i = 0; temp; temp = temp->next, i++ )
act_info.c:            UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:         LINK( new, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      if( nifty_is_name( temp->name, ign_ch->name ) )
act_info.c:      xSET_BIT( ch->act, PLR_NEEDHELP );
act_info.c:      sprintf( buf, "%s is requesting help: %s", ch->name, argument );
act_info.c:      ch->pcdata->help_message = str_dup( argument );
act_info.c:   for( track = 0; track < MAX_KILLTRACK && ch->pcdata->killed[track].vnum; track++ )
act_info.c:      tmob = get_mob_index( ch->pcdata->killed[track].vnum );
act_info.c:      ch_printf( ch, "    - killed %d times.\r\n", ch->pcdata->killed[track].count );
act_info.c:   fprintf( fp, "%s hit a DT in room %d.\n", ch->name, ch->in_room->vnum );
act_info.c:         if( ( !IS_NPC( ch ) ) && ( ch->race > 0 ) && ( ch->race < MAX_RACE ) )
act_info.c:            fprintf( fp, "     %s", race_table[ch->race]->where_name[iWear] );
act_info.c:   sprintf(buf, "cp -v %s%c/%s %sdt/%s.bak >> cp.out", PLAYER_DIR, tolower( ch->pcdata->filename[0] ), capitalize( ch->pcdata->filename ), PLAYER_DIR, capitalize( 
act_info.c:ch->pcdata->filename ));
act_move.c:   cur = ch->carry_weight;
act_move.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:       && ( !IS_AFFECTED( ch, AFF_FLYING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:         bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:      move_char( ch, get_exit( ch->in_room, DIR_DOWN ), ++fall );
act_move.c:   if( ch->on != NULL ) /* is char on floor ??? */
act_move.c:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
act_move.c:      if( ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 8 &&
act_move.c:          ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) &&
act_move.c:          number_percent(  ) > ( ch->pcdata->nuisance->flags * ch->pcdata->nuisance->power ) )
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:      sprintf( buf, "move_char: %s to door %d", ch->name, pexit->vdir );
act_move.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOUNTED ) )
act_move.c:   in_room = ch->in_room;
act_move.c:      if( drunk && ch->position != POS_MOUNTED
act_move.c:          && ch->in_room->sector_type != SECT_WATER_SWIM
act_move.c:          && ch->in_room->sector_type != SECT_WATER_NOSWIM
act_move.c:          && ch->in_room->sector_type != SECT_UNDERWATER && ch->in_room->sector_type != SECT_OCEANFLOOR )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->position = POS_INCAP;
act_move.c:   if( !fall && IS_AFFECTED( ch, AFF_CHARM ) && ch->master && in_room == ch->master->in_room )
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_hard_range )
act_move.c:         switch ( to_room->area->low_hard_range - ch->level )
act_move.c:      else if( ch->level > to_room->area->hi_hard_range )
act_move.c:   if( !IS_IMMORTAL( ch ) && IS_SET( to_room->area->flags, AFLAG_CLOSED ) && ch->in_room->area != to_room->area )
act_move.c:	    if ( iClass != ch->class
act_move.c:        &&   !IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL )
act_move.c:         if( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !ch->mount && !IS_AFFECTED( ch, AFF_FLYING ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || !IS_FLOATING( ch ) )
act_move.c:               if( ch->mount )
act_move.c:         if( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !found && !ch->mount )
act_move.c:            if( ( !IS_NPC( ch ) && number_percent(  ) > LEARNED( ch, gsn_climb ) ) || drunk || ch->mental_state < -90 )
act_move.c:      if( ch->mount )
act_move.c:         switch ( ch->mount->position )
act_move.c:         if( !IS_FLOATING( ch->mount ) )
act_move.c:         if( ch->mount->move < move )
act_move.c:         if( ch->move < move )
act_move.c:      if( ch->mount )
act_move.c:         ch->mount->move -= move;
act_move.c:         ch->move -= move;
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:            if( ch->mount && count == to_room->tunnel )
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:         if( ch->mount )
act_move.c:            if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:            else if( ch->position == POS_SHOVE )
act_move.c:            else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:   if( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:      if( char_died( ch->mount ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, to_room );
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:      else if( ch->mount )
act_move.c:         if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:         else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         else if( ch->position == POS_SHOVE )
act_move.c:         else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_soft_range )
act_move.c:      else if( ch->level > to_room->area->hi_soft_range )
act_move.c:   if( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_move.c:      xREMOVE_BIT( ch->act, PLR_BRIEF );
act_move.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_move.c:   if( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c://ch->position = POS_DEAD;      
act_move.c:snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:      for( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:         nextinroom = fch->next_in_room;
act_move.c:             && fch->master == ch && fch->position == POS_STANDING )
act_move.c:   if( ch->in_room->first_content )
act_move.c:      if( !IS_AFFECTED( ch, AFF_FLOATING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_EAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_WEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_UP ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_DOWN ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), 0 );
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( pexit = get_exit( ch->in_room, door ) ) == NULL )
act_move.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:         for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:       && ( ch->level < skill_table[gsn_bashdoor]->skill_level[ch->class]
act_move.c:            || ch->level < skill_table[gsn_bashdoor]->skill_level[ch->class2]
act_move.c:            || ch->level < skill_table[gsn_bashdoor]->skill_level[ch->class3] ) )
act_move.c:   if( ch->fighting )
act_move.c:          && ch->move >= 15 && number_percent(  ) < ( schance + 4 * ( get_curr_str( ch ) - 19 ) ) )
act_move.c:             && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:      damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:      if( ch->position == POS_FIGHTING )
act_move.c:         ch->fur_pos = FURNITURE_UNUSED;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         if( ch->on )
act_move.c:            for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:            for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:            ch->on = NULL;
act_move.c:      obj = get_obj_list( ch, arg, ch->in_room->first_content );
act_move.c:          || ( ( ch->on != obj ) && ( count_users( obj ) >= obj->value[0] ) ) )
act_move.c:      ch->on = obj;
act_move.c:      ch->fur_pos = type;
act_move.c:      for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:      for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         if( !ch->on )
act_move.c:   if( ch->on )
act_move.c:      ch->position = POS_STANDING;
act_move.c:      for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:      for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:      ch->on = NULL;
act_move.c:      ch->fur_pos = FURNITURE_UNUSED;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:            obj = get_obj_list( ch, arg, ch->in_room->first_content );
act_move.c:                || ( ( ch->on != obj ) && ( count_users( obj ) >= obj->value[0] ) ) )
act_move.c:            ch->position = POS_SITTING;
act_move.c:            if( ch->weight >= ( ( obj->value[0] * 300 ) + number_range( -30, 30 ) ) )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->on = obj;
act_move.c:               ch->fur_pos = type;
act_move.c:               for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:               for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:         ch->position = POS_SITTING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_RESTING;
act_move.c:            obj = get_obj_list( ch, arg, ch->in_room->first_content );
act_move.c:                || ( ( ch->on != obj ) && ( count_users( obj ) >= obj->value[0] ) ) )
act_move.c:            if( ch->weight >= ( ( obj->value[0] * 300 ) + number_range( -30, 30 ) ) )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->on = obj;
act_move.c:               ch->fur_pos = type;
act_move.c:               for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:               for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:   switch ( ch->position )
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 10 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 5 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && number_percent(  ) < ch->mental_state )
act_move.c:            obj = get_obj_list( ch, arg, ch->in_room->first_content );
act_move.c:                || ( ( ch->on != obj ) && ( count_users( obj ) >= obj->value[0] ) ) )
act_move.c:            if( ch->weight >= ( ( obj->value[0] * 300 ) + number_range( -30, 30 ) ) )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->position = POS_SLEEPING;
act_move.c:               ch->on = obj;
act_move.c:               ch->fur_pos = type;
act_move.c:               for( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:               for( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:   if( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      sprintf( buf, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:   ROOM_INDEX_DATA *start = ch->in_room, *dest;
act_move.c:      nch_next = nch->next_in_room;
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type != SECT_INSIDE && IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type == SECT_INSIDE || !IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( room = ch->in_room ) == NULL )
act_move.c:      bug( "pullcheck: %s not in a room?!?", ch->name );
act_move.c:               if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, xit->to_room );
act_move.c:            do_look( ch->mount, "auto" );
act_move.c:   switch ( ch->substate )
act_move.c:               sprintf( vnum, "(%d)", ch->pcdata->memorize[slot] );
act_move.c:               room = get_room_index( ch->pcdata->memorize[slot] );
act_move.c:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL ) )
act_move.c:         ch->tempnum = slot;
act_move.c:         ch->substate = SUB_NONE;
act_move.c:         if( ch->pcdata->memorize[ch->tempnum] > 0 )
act_move.c:         ch->pcdata->memorize[ch->tempnum] = ch->in_room->vnum;
act_move.c:         ch->substate = SUB_NONE;
act_obj.c:      if( ch->class == class )
act_obj.c:   if( ch->level2 == -1 )
act_obj.c:      if( ch->class == class )
act_obj.c:   else if( ch->level3 == -1 )
act_obj.c:      if( ch->class == class || ch->class2 == class )
act_obj.c:      if( ch->class == class || ch->class2 == class || ch->class3 == class )
act_obj.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) && ( ch->level < sysdata.level_getobjnotake ) )
act_obj.c:         if( ch->level - obj->value[5] > 5 || obj->value[5] - ch->level > 5 )
act_obj.c:   if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:   if( ch->carry_weight + weight > can_carry_w( ch ) )
act_obj.c:      if( IS_OBJ_STAT( container, ITEM_CLANCORPSE ) && !IS_NPC( ch ) && str_cmp( container->name + 7, ch->name ) )
act_obj.c:   if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && ( !container || container->carried_by == NULL ) )
act_obj.c:         if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      switch ( ch->race )
act_obj.c:         ch->gold += amt;
act_obj.c:         ch->copper += amt;
act_obj.c:         ch->silver += amt;
act_obj.c:      if( ( ch->carry_number + number ) > can_carry_n( ch ) )
act_obj.c:         obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:         save_house_by_vnum( ch->in_room->vnum );  /* House Object Saving */
act_obj.c:         if( IS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:         for( obj = ch->in_room->last_content; obj; obj = obj_next )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:            if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:                && !IS_NPC( ch ) && ( get_timer( ch, TIMER_PKILLED ) > 0 ) && str_cmp( name, ch->name ) )
act_obj.c:            sprintf( corpsename, "corpse %s", ch->name );
act_obj.c:                && str_cmp( container->action_desc, ch->name ) )
act_obj.c:               sprintf(buf, "You did not inflict the death blow upon this corpse\r\n debug %s %s\r\n", ch->name, corpsename);
act_obj.c:            if( IS_OBJ_STAT( container, ITEM_CLANCORPSE ) && !IS_NPC( ch ) /*&& IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) */
act_obj.c:                && container->value[4] - ch->level < 10 && container->value[4] - ch->level > -10 )
act_obj.c:            if( str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
act_obj.c:               for( gch = first_char; gch; gch = gch->next )
act_obj.c:                  if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
act_obj.c:            if( str_cmp( name, ch->name ) )
act_obj.c:               sprintf( buf, "%s is looting %s's corpse!  %s(room %d)", ch->name,
act_obj.c:                        "(ClanObject) " : "", ch->in_room->vnum );
act_obj.c:               sprintf( buf, "%s is looting %s's corpse at %s!", ch->name, capitalize( name ), ch->in_room->name );
act_obj.c:             && !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && str_cmp( ch->name, container->name + 7 ) )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:      if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:   if( xIS_SET( ch->act, PLR_LITTERBUG ) )
act_obj.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NODROP ) && ch != supermob )
act_obj.c:         if( type == 0 && ch->gold < number )
act_obj.c:         if( type == 1 && ch->silver < number )
act_obj.c:         if( type == 2 && ch->copper < number )
act_obj.c:            ch->gold -= number;
act_obj.c:            ch->silver -= number;
act_obj.c:            ch->copper -= number;
act_obj.c:         for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:            obj_to_room( create_money( number, 0 ), ch->in_room );
act_obj.c:            obj_to_room( create_money( number, 1 ), ch->in_room );
act_obj.c:            obj_to_room( create_money( number, 2 ), ch->in_room );
act_obj.c:      obj = obj_to_room( obj, ch->in_room );
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) || IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:                  obj_next = ch->first_carrying;
act_obj.c:            obj = obj_to_room( obj, ch->in_room );
act_obj.c:   save_house_by_vnum( ch->in_room->vnum );  /* House Object Saving */
act_obj.c:      if( type == 0 && ch->gold < amount )
act_obj.c:      if( type == 1 && ch->silver < amount )
act_obj.c:      if( type == 2 && ch->copper < amount )
act_obj.c:         ch->gold -= amount;
act_obj.c:         ch->silver -= amount;
act_obj.c:         ch->copper -= amount;
act_obj.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
act_obj.c:            ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:               ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:            ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:   if( !fReplace && ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:   if( IS_NPC( ch ) || ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:   for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:   if( ( ch->level2 == -1 || ch->level3 == -1 ) && obj->level > get_trust( ch ) )
act_obj.c:    * Note, ch->level HAS to be used as opposed to get_trust because ch->level
act_obj.c:   else if( ( ch->level2 != -1 || ch->level3 != -1 ) && obj->level > ch->level && !IS_IMMORTAL( ch ) )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_VAMPIRE ) && ch->race == RACE_VAMPIRE )
act_obj.c:         bug( "wear_obj: uknown/unused item_wear bit %d. %s room %d", bit, ch->name, ch->in_room->vnum );
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      for( obj = ch->first_carrying; obj != NULL; obj = obj_next )
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:    * || IS_NPC(ch) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_obj.c:   switch ( ch->in_room->sector_type )
act_obj.c:   if( move > ch->move )
act_obj.c:   ch->move -= move;
act_obj.c:         if( ch->level - obj->value[5] > 5 || obj->value[5] - ch->level > 5 )
act_obj.c:            obj_to_room( tmpObj, ch->in_room );
act_obj.c:   ch->copper += 1;
act_obj.c:   save_house_by_vnum( ch->in_room->vnum );  /* Prevent House Object Duplication */
act_obj.c:   if( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:   if( !IS_NPC( ch ) && ch->pcdata->deity && ch->pcdata->deity->name[0] != '\0' )
act_obj.c:      strcpy( name, ch->pcdata->deity->name );
act_obj.c:   else if( !IS_NPC( ch ) && ch->pcdata->clan && ch->pcdata->clan->deity[0] != '\0' )
act_obj.c:      strcpy( name, ch->pcdata->clan->deity );
act_obj.c:      for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:      obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:         vch_next = vch->next_in_room;
act_obj.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:   if( arg[0] == '\0' && !ch->fighting )
act_obj.c:      if( ch->fighting )
act_obj.c:      templvl = ch->level;
act_obj.c:      ch->level = LEVEL_HERO; /* make sure EQ doesn't get lost */
act_obj.c:      contents = ch->in_room->last_content;
act_obj.c:      ch->level = templvl;
act_obj.c:   if( ch->level < 3 )
act_obj.c:         if( ch->level < auction->item->level )
act_obj.c:         chwealth = get_value( ch->gold, ch->silver, ch->copper );
act_obj.c:         if( ch->gold < gbid || ch->silver < sbid || ch->copper < cbid )
act_obj.c:            ch->gold -= gbid;
act_obj.c:            ch->silver -= sbid;
act_obj.c:            ch->copper -= cbid;
act_obj.c:            for( rch = obj->in_room->first_person; rch; rch = rch->next_in_room, chcnt++ )
act_obj.c:            damage( vch, vch, dam * vch->level, TYPE_UNDEFINED );
act_obj.c:   obj = recursive_note_find( ch->first_carrying, argument );
act_obj.c:    * if ( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:    * if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      if( !can_drop_obj( ch, obj ) && ch->level < LEVEL_IMMORTAL )
act_obj.c:      new_ob = create_object( get_obj_index( first_ob->value[2] ), ch->level );
act_wiz.c://    for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:          * pager_printf( ch, "Saving %-s...\r\n", vch->name ); 
act_wiz.c:      sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->player_site && !str_cmp( arg2, pw->player_site ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:         if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:      sprintf( buf, "%s restricting %s to level %d", ch->name, cmd->name, level );
act_wiz.c:      victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:      DISPOSE( ch->pcdata->bamfin );
act_wiz.c:      ch->pcdata->bamfin = str_dup( argument );
act_wiz.c:            strcpy( newbamf, ch->name );
act_wiz.c:            strcat( newbamf, ch->name );
act_wiz.c:         a += strlen( ch->name );
act_wiz.c:   DISPOSE( ch->pcdata->bamfin );
act_wiz.c:   ch->pcdata->bamfin = str_dup( newbamf );
act_wiz.c:      DISPOSE( ch->pcdata->bamfout );
act_wiz.c:      ch->pcdata->bamfout = str_dup( argument );
act_wiz.c:            strcpy( newbamf, ch->name );
act_wiz.c:            strcat( newbamf, ch->name );
act_wiz.c:         a += strlen( ch->name );
act_wiz.c:   DISPOSE( ch->pcdata->bamfout );
act_wiz.c:   ch->pcdata->bamfout = str_dup( newbamf );
act_wiz.c:   if( ch->level2 != -1 )
act_wiz.c:      if( ch->level < LEVEL_PCAVATAR )
act_wiz.c:   DISPOSE( ch->pcdata->rank );
act_wiz.c:      ch->pcdata->rank = str_dup( "" );
act_wiz.c:      ch->pcdata->rank = str_dup( argument );
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\r\n", ch->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\r\n", ch->name );
act_wiz.c:      sprintf( arg, "Forceclose issued by %s on %s", ch->name, argument );
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:      echo_to_room( color, ch->in_room, argument );
act_wiz.c:      echo_to_room( AT_IMMORT, ch->in_room, argument );
act_wiz.c:      location = ch->in_room;
act_wiz.c:   sprintf( buf, "%d", ch->regoto );
act_wiz.c:   if( ( wch = get_char_world( ch, arg ) ) == NULL || !IS_NPC( wch ) || wch->in_room == NULL )
act_wiz.c:   location = wch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:      location = ch->in_room;
act_wiz.c:   location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:   if( ch->in_room != location && room_is_private( location ) )
act_wiz.c:    * switch( ch->in_room->sector_type ) {
act_wiz.c:    * if( !ch->in_room->compress )
act_wiz.c:    * decompressRoom( ch->in_room );
act_wiz.c:    * DISPOSE( ch->in_room->uncomp_desc );
act_wiz.c:   showRoom( ch, ch->in_room );
act_wiz.c:   for( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:         one_argument( rch->name, buf );
act_wiz.c:   sprintf( buf, "Reboot by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Reboot by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Shutdown by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:         if( d->snoop_by == ch->desc )
act_wiz.c:   if( ch->desc )
act_wiz.c:      for( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:   victim->desc->snoop_by = ch->desc;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( ch->desc->original )
act_wiz.c:   if( !IS_NPC( victim ) && ch->level < LEVEL_GREATER )
act_wiz.c:   if( ch->level <= victim->level )
act_wiz.c:   ch->desc->character = victim;
act_wiz.c:   ch->desc->original = ch;
act_wiz.c:   victim->desc = ch->desc;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:   ch->switched = victim;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( !ch->desc->original )
act_wiz.c:      xREMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:   ch->desc->character = ch->desc->original;
act_wiz.c:   ch->desc->original = NULL;
act_wiz.c:   ch->desc->character->desc = ch->desc;
act_wiz.c:   ch->desc->character->switched = NULL;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:   char_to_room( victim, ch->in_room );
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:      obj = obj_to_room( obj, ch->in_room );
act_wiz.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:      for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:      save_house_by_vnum( ch->in_room->vnum );  /* Prevent House Object Duplication */
act_wiz.c:      sprintf( buf2, "%s balzhuring %s", ch->name, buf );
act_wiz.c:            sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:            sprintf( buf, "%s%s", GOD_DIR, capitalize( ch->name ) );
act_wiz.c:   sprintf( arg, "elevate issued by %s on %s", ch->name, argument );
act_wiz.c:      if( !ch->pcdata )
act_wiz.c:      ch->pcdata->restore_time = current_time;
act_wiz.c:         vch_next = vch->next;
act_wiz.c:            vch->hit = vch->max_hit;
act_wiz.c:            vch->mana = vch->max_mana;
act_wiz.c:            vch->move = vch->max_move;
act_wiz.c:            vch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + vch->level );
act_wiz.c:   if( !ch->pcdata )
act_wiz.c:   if( !ch->pcdata->restore_time )
act_wiz.c:   time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:      ch_printf( victim, "%s is attempting to freeze you.\r\n", ch->name );
act_wiz.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:      if( rch->fighting )
act_wiz.c:   for( pwatch = first_watch; pwatch; pwatch = pwatch->next )
act_wiz.c:      fprintf( fp, "%d %s~%s~%s~\n", pwatch->imm_level, pwatch->imm_name,
act_wiz.c:               pwatch->target_name ? pwatch->target_name : " ", pwatch->player_site ? pwatch->player_site : " " );
act_wiz.c:         vch_next = vch->next;
act_wiz.c:         ch->pcdata->wizinvis = level;
act_wiz.c:         ch->mobinvis = level;
act_wiz.c:      if( ch->pcdata->wizinvis < 2 )
act_wiz.c:         ch->pcdata->wizinvis = ch->level;
act_wiz.c:      if( ch->mobinvis < 2 )
act_wiz.c:         ch->mobinvis = ch->level;
act_wiz.c:   if( xIS_SET( ch->act, PLR_WIZINVIS ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:      xSET_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:   if( xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:      xSET_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:   ch_printf( victim, "%s has assigned you the room vnum range %d - %d.\r\n", ch->name, r_lo, r_hi );
act_wiz.c:   ch_printf( victim, "%s has assigned you the object vnum range %d - %d.\r\n", ch->name, o_lo, o_hi );
act_wiz.c:   ch_printf( victim, "%s has assigned you the monster vnum range %d - %d.\r\n", ch->name, m_lo, m_hi );
act_wiz.c:   char_to_room( d->character, ch->in_room );
act_wiz.c:      sprintf( buf2, "%s mortalizing %s", ch->name, buf );
act_wiz.c:            sprintf( buf2, "%s mortalizing %s", ch->name, buf );
act_wiz.c:      char_to_room( d->character, ch->in_room );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the area: %s\r\n", ch->name, argument );
act_wiz.c:      ch_printf( victim, "%s has removed your bestowed commands.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the command(s): %s\r\n", ch->name, arg_buf );
act_wiz.c:      ech_next = ech->next;
act_wiz.c:      if( ech->fighting )
act_wiz.c:         if( URANGE( pArea->low_m_vnum, ech->pIndexData->vnum, pArea->hi_m_vnum ) == ech->pIndexData->vnum
act_wiz.c:             || ( ech->in_room && ech->in_room->area == pArea ) )
act_wiz.c:      if( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:      drop_artifacts( ch, ch->last_carrying );
act_wiz.c:      sprintf( lockerpath, "%s%s", LOCKER_DIR, capitalize( ch->name ) );
act_wiz.c:         sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:         sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:      if( ch->pcdata->council )
act_wiz.c:         ch->pcdata->council->num_members--;
act_wiz.c:         rem_council_member( ch->pcdata->council, ch->name );
act_wiz.c:      if( ch->pcdata->council2 )
act_wiz.c:         ch->pcdata->council->num_members--;
act_wiz.c:         rem_council_member( ch->pcdata->council, ch->name );
act_wiz.c:      if( ch->pcdata->clan )
act_wiz.c:         ch->pcdata->clan->num_members--;
act_wiz.c:         rem_clan_member( ch->pcdata->clan, ch->name );
act_wiz.c:               sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:      sprintf( buf, "%s destroying %s", ch->name, arg );
act_wiz.c:      return ch->name;
act_wiz.c:   one_argument( ch->name, name );  /* copy the first word into name */
act_wiz.c:   for( rch = ch->in_room->first_person; rch && ( rch != ch ); rch = rch->next_in_room )
act_wiz.c:      if( is_name( name, rch->name ) )
act_wiz.c:            old_room = ch->in_room;
act_wiz.c:               old_room = ch->in_room;
act_wiz.c:   victim->pcdata->helled_by = STRALLOC( ch->name );
act_wiz.c:   location = ch->in_room;
act_wiz.c:/*ch->in_room = get_room_index(8);*/
act_wiz.c:/*ch->in_room = location;          The case of unhell self, etc.*/
act_wiz.c:      location = ch->in_room;
act_wiz.c:      if( str_cmp( ch->name, victim->pcdata->helled_by ) )
act_wiz.c:      if( get_trust( ch ) > LEVEL_SUB_IMPLEM || !str_cmp( ch->name, "Nivek" ) )
act_wiz.c:   if( ( get_trust( ch ) > LEVEL_GREATER || !str_cmp( ch->name, "Nivek" ) )
act_wiz.c:   else if( command->level > get_trust( ch ) && str_cmp( ch->name, "Nivek" ) )
act_wiz.c:   if( get_trust( ch ) <= LEVEL_SUB_IMPLEM && str_cmp( ch->name, "Nivek" ) )
act_wiz.c:      if( ( str_cmp( ch->pcdata->council_name, "Quest Council" )
act_wiz.c:            || str_cmp( ch->pcdata->council2_name, "Quest Council" ) ) && ( get_trust( ch ) < LEVEL_DEMI ) )
act_wiz.c:               t->tm_mon + 1, t->tm_mday, ch->in_room ? ch->in_room->vnum : 0,
act_wiz.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_wiz.c:   ch_printf( ch, "Kill history for %s:\r\n", vch->name );
act_wiz.c:   for( track = 0; track < MAX_KILLTRACK && vch->pcdata->killed[track].vnum; track++ )
act_wiz.c:      tmob = get_mob_index( vch->pcdata->killed[track].vnum );
act_wiz.c:      ch_printf( ch, "    - killed %d times.\r\n", vch->pcdata->killed[track].count );
act_wiz.c:   if( !ch->desc )
act_wiz.c:   switch ( ch->substate )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( ch->dest_buf != ch->pnote )
act_wiz.c:            bug( "do_project: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
act_wiz.c:         STRFREE( ch->pnote->text );
act_wiz.c:         ch->pnote->text = copy_buffer( ch );
act_wiz.c:         if( !ch->dest_buf )
act_wiz.c:            bug( "do_project: sub_project_desc: NULL ch->dest_buf", 0 );
act_wiz.c:            ch->substate = SUB_NONE;
act_wiz.c:         pproject = ch->dest_buf;
act_wiz.c:         ch->substate = ch->tempnum;
act_wiz.c:         if( MINE && ( !pproject->owner || str_cmp( ch->name, pproject->owner ) )
act_wiz.c:             && ( !pproject->coder || str_cmp( ch->name, pproject->coder ) ) )
act_wiz.c:          str_cmp( ch->name, "Kali" )
act_wiz.c:          && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:               || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:          str_cmp( ch->name, "Kali" )
act_wiz.c:          && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:               || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:      ch->tempnum = SUB_NONE;
act_wiz.c:      ch->substate = SUB_PROJ_DESC;
act_wiz.c:      ch->dest_buf = pproject;
act_wiz.c:      if( str_cmp( ch->name, "Kali" )
act_wiz.c:          && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:               || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) && get_trust( ch ) < LEVEL_ASCENDANT )
act_wiz.c:      if( pproject->taken && pproject->owner && !str_cmp( pproject->owner, ch->name ) )
act_wiz.c:      pproject->owner = STRALLOC( ch->name );
act_wiz.c:      if( pproject->coder && !str_cmp( ch->name, pproject->coder ) )
act_wiz.c:      pproject->coder = str_dup( ch->name );
act_wiz.c:      if( pproject->owner && str_cmp( pproject->owner, ch->name ) &&
act_wiz.c:          && pproject->coder && str_cmp( pproject->coder, ch->name ) &&
act_wiz.c:          str_cmp( ch->name, "Kali" )
act_wiz.c:          && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:               || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:         ch->substate = SUB_WRITING_NOTE;
act_wiz.c:         ch->dest_buf = ch->pnote;
act_wiz.c:         start_editing( ch, ch->pnote->text );
act_wiz.c:         STRFREE( ch->pnote->subject );
act_wiz.c:         ch->pnote->subject = STRALLOC( argument );
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) &&
act_wiz.c:             get_trust( ch ) < LEVEL_GREATER && str_cmp( ch->name, "Kali" ) &&
act_wiz.c:             ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:               || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( !ch->pnote->subject )
act_wiz.c:         ch->pnote->date = STRALLOC( strtime );
act_wiz.c:         ch->pnote->sender = ch->name;
act_wiz.c:         plog = ch->pnote;
act_wiz.c:         ch->pnote = NULL;
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder )
act_wiz.c:             && str_cmp( ch->name, "Kali" )
act_wiz.c:             && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:                  || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) &&
act_wiz.c:             str_cmp( ch->name, "Kali" )
act_wiz.c:             && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:                  || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder )
act_wiz.c:             && str_cmp( ch->name, "Kali" )
act_wiz.c:             && ( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:                  || str_cmp( ch->pcdata->council2_name, "Code Council" ) ) )
act_wiz.c:      if( inroom && ch->in_room != d->character->in_room )
act_wiz.c:      if( inarea && ch->in_room->area != d->character->in_room->area )
act_wiz.c:   ch->pcdata->smited++;
act_wiz.c:   adjust_hiscore( "smiter", ch, ch->pcdata->smited );
act_wiz.c:   if( str_cmp( ch->name, "Kratas" ) )
act_wiz.c:      sprintf( buf, "Your Trust is %d.\r\n", ch->trust );
act_wiz.c:   if( ch->trust == 0 )
act_wiz.c:      ch->trust = ch->level;
act_wiz.c:   if( level <= ch->level )
act_wiz.c:      temp_prac = ch->practice;
act_wiz.c:      ch->level = 1;
act_wiz.c:      ch->exp = exp_level( ch, ch->level );
act_wiz.c:      ch->max_hit = 20;
act_wiz.c:      ch->max_mana = 100;
act_wiz.c:      ch->max_move = 100;
act_wiz.c:      ch->practice = 0;
act_wiz.c:      ch->hit = ch->max_hit;
act_wiz.c:      ch->mana = ch->max_mana;
act_wiz.c:      ch->move = ch->max_move;
act_wiz.c:      ch->practice = temp_prac;
act_wiz.c:   for( iLevel = ch->level; iLevel < level; iLevel++ )
act_wiz.c:      ch->level += 1;
act_wiz.c:   sprintf( buf, "You are now level %d.\r\n", ch->level );
act_wiz.c:   ch->exp = exp_level( ch, ch->level ) * UMAX( 1, ch->level );
act_wiz.c:   if( ch->level < 103 )
act_wiz.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_wiz.c:         if( victim->level > ch->level )
act_wiz.c:         sprintf( buf, "The Immortal %s has removed %s from their clan!", ch->name, victim->name );
act_wiz.c:            if( victim->level > ch->level )
act_wiz.c:                  ch_printf( victim, "%s instructs you in the ways of %s.\r\n", ch->name, skill_table[sn]->name );
act_wiz.c:      ch_printf( victim, "%s has removed your vnum range.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has assigned you the vnum range %d - %d.\r\n", ch->name, lo, hi );
act_wiz.c:      AREA_DATA *pArea = ch->in_room->area;
act_wiz.c:   ch_printf( victim, "%s has flushed your area data and reset it.\r\n", ch->name );
act_wiz.c:   if( victim->level >= ch->level )
antitank.c:   for( lowbie = ch->in_room->first_person; lowbie; lowbie = lowbie->next_in_room )
antitank.c:                  tanker->name, lowbie->name, ch->pIndexData->vnum );
arena.c:            sprintf( buf, "%s has ^zOPENED^x the arena with a MAX level of %d!", ch->name, hi_level );
arena.c:            sprintf( buf, "%s has ^zOPENED^x the arena with a MIN level of %d!", ch->name, low_level );
arena.c:            sprintf( buf, "%s has ^zOPENED^x the arena!", ch->name );
arena.c:            sprintf( buf, "%s has ^zOPENED^x the arena for levels %d through %d!", ch->name, low_level, hi_level );
arena.c:            sprintf( buf, "%s has closed betting.  Let the games begin!", ch->name );
arena.c:         sprintf( buf, "%s has canceled the arena match!", ch->name );
arena.c:         if( ch->pcdata->arena )
arena.c:            switch ( ch->pcdata->arena->status )
arena.c:         if( ( ch->gold < arena_fee ) && !IS_IMMORTAL( ch ) )
arena.c:         if( ch->level < low_level && low_level != -1 )
arena.c:         if( ch->level > hi_level && hi_level != -1 )
arena.c:         if( ch->fighting )
arena.c:               bug( "Cannot find a room in the arena for %s!", ch->name );
arena.c:         ch->position = POS_STANDING;
arena.c:         ch->retran = ch->in_room->vnum;
arena.c:               sprintf( buf, "Bill Gates donates %d coins for %s\'s entrance fee!", arena_fee, ch->name );
arena.c:               ch->gold -= arena_fee;
arena.c:         sprintf( buf, "%s has joined the arena match!", ch->name );
arena.c:         CREATE( ch->pcdata->arena, ARENA_DATA, 1 );
arena.c:         ch->pcdata->arena->status = 2;
arena.c:         if( !ch->pcdata->arena )
arena.c:         if( ch->pcdata->arena->status != 2 )
arena.c:         if( ch->fighting )
arena.c:         ch->position = POS_STANDING;
arena.c:         char_to_room( ch, get_room_index( ch->retran ) );
arena.c:         sprintf( buf, "%s has wimped out of the arena match!", ch->name );
arena.c:         DISPOSE( ch->pcdata->arena );
arena.c:         if( ch->pcdata->arena )
arena.c:         if( ch->gold < betamt )
arena.c:         CREATE( ch->pcdata->arena, ARENA_DATA, 1 );
arena.c:         ch->pcdata->arena->bet = betamt;
arena.c:         ch->gold -= ch->pcdata->arena->bet;
arena.c:         ch->pcdata->arena->bet_on = victim;
arena.c:            ch->pcdata->arena->bet_on->pcdata->arena->num_bets++;
arena.c:         arena_total_bets += ch->pcdata->arena->bet;
arena.c:         ch->pcdata->arena->status = 1;
arena.c:            if( ch->pcdata->arena && ch->pcdata->arena->status == 2 )
arena.c:            if( sysdata.arena == 1 && ( ch->pcdata->arena && ch->pcdata->arena->status == 0 ) )
arena.c:         if( ch->pcdata->arena && ch->pcdata->arena->status == 2 )
arena.c:         if( !ch->pcdata->arena )
arena.c:         switch ( ch->pcdata->arena->status )
arena.c:               if( ch->pcdata->arena->bet_on != arena_winner )
arena.c:               if( ch->pcdata->arena->bet_on->pcdata->arena->num_bets <= 0 )
arena.c:                  ch->pcdata->arena->bet_on->pcdata->arena->num_bets = 1;
arena.c:                * percent = ch->pcdata->arenabet/arena_total_bets;
arena.c:                * percent = (arena_total_bets/ch->pcdata->arenabet);
arena.c:                  percent = 1 / ch->pcdata->arena->bet_on->pcdata->arena->num_bets;
arena.c:                  amount = ch->pcdata->arena->bet * percent;
arena.c:                  gold = ch->pcdata->arena->bet + amount;
arena.c:               ch->gold += gold;
arena.c:               DISPOSE( ch->pcdata->arena );
arena.c:                  sprintf( buf, "%s has ^zWON^x the arena match, and ^z%d^x coins!", ch->name, arena_prize );
arena.c:                  ch->gold += arena_prize;
arena.c:                  ch->pcdata->arena_wins++;
arena.c:                  adjust_hiscore( "arena_pkill", ch, ch->pcdata->arena_wins );
arena.c:               ch->position = POS_STANDING;
arena.c:               ch->hit = ch->max_hit;
arena.c:               ch->mana = ch->max_mana;
arena.c:               ch->move = ch->max_move;
arena.c:               ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
arena.c:               char_to_room( ch, get_room_index( ch->retran ) );
arena.c:               DISPOSE( ch->pcdata->arena );
arena.c:               DISPOSE( ch->pcdata->arena );
arena.c:               DISPOSE( ch->pcdata->arena );
arena.c:      sprintf( buf, "%s has been defeated by %s in the arena!", victim->name, ch->name );
arena.c:               victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
arena.c:      ch->pcdata->arena_kills++;
assa.c:   if( ( IS_NPC( ch ) && ( ch->desc->original ) ) || ( IS_AFFECTED( ch, AFF_POSSESS ) ) )
assa.c:   if( ch->mount )
assa.c:   percent = number_percent(  ) + UMAX( 0, ( victim->level - ch->level ) * 2 );
assa.c:   if( IS_NPC( ch ) || percent < ch->pcdata->learned[gsn_assassinate] )
axsmaug.c:    	tarea=ch->in_room->area;	
ban.c:   if( !ch->desc )   /* No desc means no go :) */
ban.c:   switch ( ch->substate )
ban.c:         ch->tempnum = SUB_NONE;
ban.c:   if( !ch->desc )   /* No desc is a bad thing */
ban.c:   if( !ch->desc )
ban.c:   switch ( ch->substate )
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:         ch->substate = SUB_BAN_DESC;
ban.c:         ch->dest_buf = pban;
ban.c:         pban = ( BAN_DATA * ) ch->dest_buf;
ban.c:            bug( "%s", "do_ban: sub_ban_desc: NULL ch->dest_buf" );
ban.c:            ch->substate = SUB_NONE;
ban.c:         ch->substate = ch->tempnum;
ban.c:         for( i = 0; i < ( int )( strlen( ch->desc->host ) ); i++ )
ban.c:            new_host[i] = LOWER( ch->desc->host[i] );
ban.c:      if( type == BAN_CLASS && ( pban->flag == ch->class || pban->flag == ch->class2 || pban->flag == ch->class3 ) )
ban.c:         if( ch->level > pban->level )
ban.c:               sprintf( buf, "%s class logging in from %s.", pban->name, ch->desc->host );
ban.c:      if( type == BAN_RACE && pban->flag == ch->race )
ban.c:         if( ch->level > pban->level )
ban.c:               sprintf( buf, "%s race logging in from %s.", pban->name, ch->desc->host );
ban.c:         if( fMatch && pban->user && str_cmp( pban->user, ch->desc->user ) )
ban.c:            if( ch->level > pban->level )
ban.c:                  sprintf( buf, "%s logging in from site %s.", ch->name, ch->desc->host );
bank.c:   for( banker = ch->in_room->first_person; banker; banker = banker->next_in_room )
bank.c:      sprintf( buf, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      sprintf( buf, "%s How much do you wish to deposit?", ch->name );
bank.c:      sprintf( buf, "%s How much do you wish to deposit?", ch->name );
bank.c:      sprintf( buf, "%s You must specify gold, silver, or copper.", ch->name );
bank.c:      sprintf( buf, "%s I don't trade in that currency.", ch->name );
bank.c:      isgold ? ( amount = ch->gold ) : issilver ? ( amount = ch->silver ) : ( amount = ch->copper );
bank.c:   if( ( amount > ch->gold && isgold ) || ( amount > ch->silver && issilver ) || ( amount > ch->copper && iscopper ) )
bank.c:      sprintf( buf, "%s Sorry, but you don't have that much %s to deposit.", ch->name,
bank.c:      sprintf( buf, "%s Oh, I see.. I didn't know i was doing business with a comedian.", ch->name );
bank.c:         if( ch->pcdata->gbalance == 500 )
bank.c:         if( ch->pcdata->gbalance + amount > 500 )
bank.c:            amount = 500 - ch->pcdata->gbalance;
bank.c:         if( ch->pcdata->sbalance == 50000 )
bank.c:         if( ch->pcdata->sbalance + amount > 50000 )
bank.c:            amount = 50000 - ch->pcdata->sbalance;
bank.c:         if( ch->pcdata->balance == 5000000 )
bank.c:         if( ch->pcdata->balance + amount > 5000000 )
bank.c:            amount = 5000000 - ch->pcdata->balance;
bank.c:      ch->gold -= amount;
bank.c:      ch->pcdata->gbalance += amount;
bank.c:      ch->silver -= amount;
bank.c:      ch->pcdata->sbalance += amount;
bank.c:      ch->copper -= amount;
bank.c:      ch->pcdata->balance += amount;
bank.c:      sprintf( buf, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      sprintf( buf, "%s How much do you wish to withdraw?", ch->name );
bank.c:      sprintf( buf, "%s How much do you wish to withdraw?", ch->name );
bank.c:      sprintf( buf, "%s You must specify gold, silver, or copper.", ch->name );
bank.c:      thebalance = ch->pcdata->gbalance;
bank.c:      thebalance = ch->pcdata->sbalance;
bank.c:      thebalance = ch->pcdata->balance;
bank.c:      isgold ? ( amount = ch->pcdata->gbalance ) : issilver ? ( amount = ch->pcdata->sbalance ) : ( amount =
bank.c:                                                                                                    ch->pcdata->balance );
bank.c:      sprintf( buf, "%s But you do not have that much %s in your account!", ch->name, isgold ? "gold" : issilver ? "silver" :
bank.c:      sprintf( buf, "%s Oh I see.. I didn't know i was doing business with a comedian.", ch->name );
bank.c:      ch->pcdata->balance -= amount;
bank.c:      ch->copper += amount;
bank.c:      ch->pcdata->gbalance -= amount;
bank.c:      ch->gold += amount;
bank.c:      ch->pcdata->sbalance -= amount;
bank.c:      ch->silver += amount;
bank.c:      sprintf( buf, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:   sprintf( buf, "&YGold: %d.\r\n&WSilver: %d.\r\n&RCopper: %d.\r\n\r\n", ch->pcdata->gbalance, ch->pcdata->sbalance,
bank.c:            ch->pcdata->balance );
bank.c:      sprintf( buf, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      sprintf( buf, "%s How much do you wish to send to who?", ch->name );
bank.c:      sprintf( buf, "%s How much do you wish to send to who?", ch->name );
bank.c:      thebalance = ch->pcdata->gbalance;
bank.c:      thebalance = ch->pcdata->sbalance;
bank.c:      thebalance = ch->pcdata->balance;
bank.c:      sprintf( buf, "%s I don't trade in that currency.", ch->name );
bank.c:      sprintf( buf, "%s %s could not be located.", ch->name, capitalize( arg2 ) );
bank.c:      sprintf( buf, "%s We do not do business with mobiles...", ch->name );
bank.c:      isgold ? ( amount = ch->pcdata->gbalance ) : issilver ? ( amount = ch->pcdata->sbalance ) : ( amount =
bank.c:                                                                                                    ch->pcdata->balance );
bank.c:      sprintf( buf, "%s You are very generous, but you don't have that much %s!", ch->name, isgold ? "gold" : issilver ?
bank.c:      sprintf( buf, "%s Oh I see.. I didn't know I was doing business with a comedian.", ch->name );
bank.c:      ch->pcdata->gbalance -= amount;
bank.c:      ch->pcdata->sbalance -= amount;
bank.c:      ch->pcdata->balance -= amount;
bank.c:            ch->name, amount, isgold ? "gold" : issilver ? "silver" : "copper", ( amount != 1 ) ? "s" : "" );
bits.c:   for( bit = ch->first_abit; bit; bit = bit->next )
bits.c:   for( bit = ch->pcdata->first_qbit; bit; bit = bit->next )
bits.c:      LINK( bit, ch->first_abit, ch->last_abit, next, prev );
bits.c:      LINK( bit, ch->pcdata->first_qbit, ch->pcdata->last_qbit, next, prev );
bits.c:   if( !ch->first_abit )
bits.c:   bit = ch->first_abit;
bits.c:         UNLINK( tmp, ch->first_abit, ch->last_abit, next, prev );
bits.c:   if( !ch->pcdata->first_qbit )
bits.c:   bit = ch->pcdata->first_qbit;
bits.c:         UNLINK( tmp, ch->pcdata->first_qbit, ch->pcdata->last_qbit, next, prev );
bits.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
bits.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
boards.c:      if( is_name( ch->name, board->extra_removers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->read_group ) )
boards.c:      if( ch->pcdata->council2 && !str_cmp( ch->pcdata->council2->name, board->read_group ) )
boards.c:      if( is_name( ch->name, board->extra_readers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->post_group ) )
boards.c:      if( ch->pcdata->council2 && !str_cmp( ch->pcdata->council2->name, board->post_group ) )
boards.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
boards.c:    if ( !str_cmp( ch->name, pnote->sender ) )
boards.c:    if ( is_name( ch->name, pnote->to_list ) )
boards.c:   if( ch->pnote )
boards.c:   pnote->sender = QUICKLINK( ch->name );
boards.c:   ch->pnote = pnote;
boards.c:   for( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:   switch ( ch->substate )
boards.c:   switch ( ch->substate )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:         ed = ch->dest_buf;
boards.c:                  if( ch->copper < 10 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                     ch->copper -= 10;
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:      if( is_name( ch->name, buf ) )
boards.c:         sprintf( buf, "%s %s", pnote->yesvotes, ch->name );
boards.c:         sprintf( buf, "%s %s", pnote->novotes, ch->name );
boards.c:         sprintf( buf, "%s %s", pnote->abstentions, ch->name );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:      sprintf( buf, "\r\n&w[Note Number &W1&w]\r\n\r\n" "&wTo:       &W%s\r\n" "&wFrom:     &W%s\r\n" "&wDate:     &W(Date Only Supplied When Posted)\r\n" "&wSubject:  &W%-70.70s\r\n\r\n&w", to_list, ch->name, subject );  /* to_list name subject */
boards.c:      pnote->sender = QUICKLINK( ch->name );
boards.c:               if( ch->copper < 50 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                  ch->copper -= 50;
bounty.c:   for( bounty = ch->in_room->first_person; bounty; bounty = bounty->next_in_room )
bounty.c:         else if( ch->bounty > 0 )
bounty.c:            ch_printf( ch, "&YYou have a bounty worth %d gold on your head.\r\n", ch->bounty );
bounty.c:         else if( ch->bowed > 0 )
bounty.c:            ch_printf( ch, "&YYou are owed %d gold in bounty earnings.\r\n", ch->bowed );
bounty.c:      sprintf( buf, "We don't deal with your kind %s.", ch->short_descr );
bounty.c:         else if( ch->bounty > 0 )
bounty.c:            ch_printf( ch, "&YYou have a bounty worth %d gold on your head.\r\n", ch->bounty );
bounty.c:         else if( ch->bowed > 0 )
bounty.c:            ch_printf( ch, "&YYou are owed %d gold in bounty earnings.\r\n", ch->bowed );
bounty.c:            sprintf( buf, "%s %s's bounty is worth %d gold.", ch->name, victim->name, victim->bounty );
bounty.c:         sprintf( buf, "%s That player has no bounty.", ch->name );
bounty.c:      if( ch->belig == 0 )
bounty.c:         sprintf( buf, "%s You are already uneligible to have a bounty on your head!", ch->name );
bounty.c:      if( ch->gold < cost )
bounty.c:         sprintf( buf, "%s I'm sorry, you can't afford this.", ch->name );
bounty.c:      ch->gold -= cost;
bounty.c:      ch->belig = 0;
bounty.c:      sprintf( buf, "%s You are no longer eligible to have a bounty on your head.", ch->name );
bounty.c:      if( ch->bowed <= 0 )
bounty.c:         sprintf( buf, "%s I owe you nothing %s!", ch->name, ch->name );
bounty.c:      ch->gold += ch->bowed;
bounty.c:      sprintf( buf, "&YYou collect %d gold worth of bounties.\r\n", ch->bowed );
bounty.c:      ch->bowed = 0;
bounty.c:      sprintf( buf, "%s A pleasure doing business with you.", ch->name );
bounty.c:      amount = ch->gold;
bounty.c:   if( amount > ch->gold )
bounty.c:      sprintf( buf, "%s Check your pockets and try again, you don't have that much gold!", ch->name );
bounty.c:      sprintf( buf, "%s That amount is too frugal, try again!", ch->name );
bounty.c:      sprintf( buf, "%s How do you expect me to stay in business at those prices!?", ch->name );
bounty.c:      sprintf( buf, "%s That would exceed the maximum allowable bounty of %d gold!", ch->name, bountymax );
bounty.c:      sprintf( buf, "%s You may not place a bounty on the head of an immortal!", ch->name );
bounty.c:      sprintf( buf, "%s You may only place a bounty on the head of a pkiller, or an eligible peaceful.", ch->name );
bounty.c:      sprintf( buf, "%s Place a bounty on yourself? Ever considered suicide?", ch->name );
bounty.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && ch->belig == 0 )
bounty.c:      sprintf( buf, "%s By doing this you are now eligible to have bounties set on your own head!", ch->name );
bounty.c:      sprintf( buf, "%s You can become uneligible again by typing bounty buy, at a cost of %d gold", ch->name, cost );
bounty.c:      ch->belig = 1;
bounty.c:   ch->gold -= amount;
bounty.c:      sprintf( buf, "%s The bounty on %s has been increased by %d gold!", ch->name, victim->name, amount );
bsnip.c:    tarea = ch->in_room->area;
bsnip.c:    tarea = ch->in_room->area;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->desc )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:      bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
build.c:   if( ch->editor )
build.c:   ch->editor = edit;
build.c:   ch->desc->connected = CON_EDITING;
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      strcpy( tmp, ch->editor->line[x] );
build.c:   DISPOSE( ch->editor );
build.c:   ch->editor = NULL;
build.c:   ch->dest_buf = NULL;
build.c:   ch->spare_ptr = NULL;
build.c:   ch->substate = SUB_NONE;
build.c:   if( !ch->desc )
build.c:   ch->desc->connected = CON_PLAYING;
build.c:      if( get_trust( ch ) < LEVEL_CREATOR || vnum < 1 || IS_NPC( ch ) || !ch->pcdata->area )
build.c:         if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( !( location = make_room( vnum, ch->pcdata->area ) ) )
build.c:      location->area = ch->pcdata->area;
build.c:   in_room = ch->in_room;
build.c:   if( ch->fighting )
build.c:   if( ch->position != POS_STANDING )
build.c:   sprintf( buf2, "%s leaves in a swirling mist.", ch->name );
build.c:      fch_next = fch->next_in_room;
build.c:          && ( ( get_trust( fch ) >= ( IS_NPC( ch ) ? ch->level : ch->pcdata->wizinvis ) )
build.c:               || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
build.c:         sprintf( buf, "&Y%s&w\r\n", ( ch->pcdata && ch->pcdata->bamfout
build.c:                                       && ch->pcdata->bamfout[0] != '\0' ) ? ch->pcdata->bamfout : buf2 );
build.c:   ch->regoto = ch->in_room->vnum;
build.c:   if( ch->mount )
build.c:      char_from_room( ch->mount );
build.c:      char_to_room( ch->mount, location );
build.c:   sprintf( buf2, "&Y%s appears in a swirling mist.&w", ch->name );
build.c:   for( fch = ch->in_room->first_person; fch; fch = fch_next )
build.c:      fch_next = fch->next_in_room;
build.c:          && ( ( get_trust( fch ) >= ( IS_NPC( ch ) ? ch->level : ch->pcdata->wizinvis ) )
build.c:               || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
build.c:         sprintf( buf, "&Y%s&w\r\n", ( ch->pcdata && ch->pcdata->bamfin
build.c:                                       && ch->pcdata->bamfin[0] != '\0' ) ? ch->pcdata->bamfin : buf2 );
build.c:   if( ch->in_room == in_room )
build.c:      fch_next = fch->next_in_room;
build.c:      if( fch->master == ch && IS_IMMORTAL( fch ) )
build.c:      else if( IS_NPC( fch ) && fch->master == ch )
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_mset: sub_mob_desc: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         victim = ch->dest_buf;
build.c:         ch->substate = ch->tempnum;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      victim = ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = victim;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      ch->pcdata->balance = value;
build.c:      pwdnew = crypt( arg3, ch->name );
build.c:      ch_printf( victim, "Your password has been changed by %s.\r\n", ch->name );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_MOB_DESC;
build.c:      ch->dest_buf = victim;
build.c:            else if( value == ACT_PROTOTYPE && ch->level < sysdata.level_modify_proto )
build.c:      if( ch->pcdata->wedto )
build.c:         STRFREE( ch->pcdata->wedto );
build.c:         ch->pcdata->wedto = STRALLOC( arg3 );
build.c:         ch->pcdata->wedto = NULL;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_mset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_extra: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         ed = ch->dest_buf;
build.c:         tmpobj = ch->spare_ptr;
build.c:         ch->dest_buf = tmpobj;
build.c:         ch->substate = ch->tempnum;
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_long: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         obj = ch->dest_buf;
build.c:         tmpobj = ch->spare_ptr;
build.c:         ch->substate = ch->tempnum;
build.c:         ch->dest_buf = tmpobj;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      obj = ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = obj;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_LONG;
build.c:      ch->dest_buf = obj;
build.c:                && get_trust( ch ) < LEVEL_GREATER && !is_name( "protoflag", ch->pcdata->bestowments ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_oset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         location = ch->dest_buf;
build.c:            bug( "redit: sub_room_desc: NULL ch->dest_buf", 0 );
build.c:            location = ch->in_room;
build.c:         ch->substate = ch->tempnum;
build.c:         ed = ch->dest_buf;
build.c:            bug( "redit: sub_room_extra: NULL ch->dest_buf", 0 );
build.c:         ch->substate = ch->tempnum;
build.c:   location = ch->in_room;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:         ch->substate = SUB_NONE;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_DESC;
build.c:      ch->dest_buf = location;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_redit;
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   char_to_room( mob, ch->in_room );
build.c:   if( ( d = ch->desc ) == NULL )
build.c:   if( ch->substate <= SUB_PAUSE )
build.c:      bug( "Edit_buffer: illegal ch->substate (%d)", ch->substate );
build.c:   if( !ch->editor )
build.c:   edit = ch->editor;
build.c:   if( ch->substate == SUB_MPROG_EDIT || ch->substate == SUB_HELP_EDIT )
build.c:         int substate = ch->substate;
build.c:         last_cmd = ch->last_cmd;
build.c:         ch->substate = SUB_RESTRICTED;
build.c:         ch->substate = substate;
build.c:         ch->last_cmd = last_cmd;
build.c:         if( !ch->last_cmd )
build.c:         ( *ch->last_cmd ) ( ch, "" );
build.c:      if( !ch->last_cmd )
build.c:      ( *ch->last_cmd ) ( ch, "" );
build.c:   if( get_trust( ch ) > LEVEL_IMMORTAL && ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
build.c:      tarea = ch->pcdata->area;
build.c:      sprintf( taf, "%s.are", capitalize( ch->name ) );
build.c:         sprintf( buf, "Creating area entry for %s", ch->name );
build.c:         log_string_plus( buf, LOG_NORMAL, ch->level );
build.c:         sprintf( buf, "{PROTO} %s's area in progress", ch->name );
build.c:         sprintf( buf2, "%s", ch->name );
build.c:         sprintf( buf, "Updating area entry for %s", ch->name );
build.c:         log_string_plus( buf, LOG_NORMAL, ch->level );
build.c:      tarea->low_r_vnum = ch->pcdata->r_range_lo;
build.c:      tarea->low_o_vnum = ch->pcdata->o_range_lo;
build.c:      tarea->low_m_vnum = ch->pcdata->m_range_lo;
build.c:      tarea->hi_r_vnum = ch->pcdata->r_range_hi;
build.c:      tarea->hi_o_vnum = ch->pcdata->o_range_hi;
build.c:      tarea->hi_m_vnum = ch->pcdata->m_range_hi;
build.c:      ch->pcdata->area = tarea;
build.c:      ch->pcdata->area = NULL;
build.c:      if( !ch->pcdata->area )
build.c:       || ( is_name( buf, ch->pcdata->bestowments ) && get_trust( ch ) >= sysdata.level_modify_proto ) )
build.c:                || is_name( tmp->filename, ch->pcdata->bestowments ) ||
build.c:                ( ch->pcdata->council && is_name( "aassign",
build.c:                                                  ch->pcdata->council->powers ) )
build.c:                || ( ch->pcdata->council2 && is_name( "aassign", ch->pcdata->council2->powers ) ) )
build.c:   ch->pcdata->area = tarea;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:         tarea = ch->in_room->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_mpedit: sub_mprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ch->dest_buf;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ch->dest_buf;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ch->dest_buf;
build.c:   if( !can_rmodify( ch, ch->in_room ) )
build.c:   mprog = ch->in_room->mudprogs;
build.c:            xCLEAR_BITS( ch->in_room->progtypes );
build.c:               xSET_BIT( ch->in_room->progtypes, mprg->type );
build.c:         mprg_next = ch->in_room->mudprogs;
build.c:         ch->in_room->mudprogs = mprg_next->next;
build.c:            xREMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:         xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:            xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:      xSET_BIT( ch->in_room->progtypes, mptype );
build.c:       && ( location->vnum < ch->pcdata->r_range_lo || location->vnum > ch->pcdata->r_range_hi ) )
build.c:       && ( obj->vnum < ch->pcdata->o_range_lo || obj->vnum > ch->pcdata->o_range_hi ) )
build.c:       && ( mob->vnum < ch->pcdata->m_range_lo || mob->vnum > ch->pcdata->m_range_hi ) )
build.c:   else if( !ch->in_room )
build.c:   else if( !ch->in_room->area )
build.c:   else if( !ch->in_room->area->weather )
build.c:   area = ch->in_room->area;
build.c:   tarea = ch->in_room->area;
build.c:   tarea = ch->in_room->area;
cbackup.c:   sprintf( buf, "BACKUP(%s): %s file written, moved to backup directory.", ch->name, backup_fname_strings[type] );
changes.c:   changes_table[maxChanges - 1].coder = str_dup( ch->name );
changes.c:   if( !ch->desc || NULLSTR( arg1 ) )
channels.c:      ch_printf( ch, "%s\r\n", ch->pcdata->chan_listen );
channels.c:         if( ch->level >= channel->level && !hasname( ch->pcdata->chan_listen, channel->name ) )
channels.c:            addname( &ch->pcdata->chan_listen, channel->name );
channels.c:         if( ch->level >= channel->level && hasname( ch->pcdata->chan_listen, channel->name ) )
channels.c:            removename( &ch->pcdata->chan_listen, channel->name );
channels.c:   if( hasname( ch->pcdata->chan_listen, argument ) )
channels.c:      removename( &ch->pcdata->chan_listen, argument );
channels.c:      if( channel->level > ch->level )
channels.c:      addname( &ch->pcdata->chan_listen, argument );
channels.c:      if( ch->level >= channel->level )
channels.c:         if( hasname( ch->pcdata->chan_listen, channel->name ) == 0 )
channels.c:      if( ch->level >= offchannel->level )
channels.c:         if( hasname( ch->pcdata->chan_listen, offchannel->name ) == 1 )
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) &&  !IS_IMMORTAL(ch) )
channels.c:      if( ch->master )
channels.c:         send_to_char( "I don't think so...\r\n", ch->master );
channels.c:   if( !IS_NPC( ch ) && !ch->pcdata->clan && channel->type == CHAN_GUILD )
channels.c:                  if( IS_AFFECTED( ch, AFF_DETECT_INVIS ) || xIS_SET( ch->act, PLR_HOLYLIGHT ) )
channels.c:                  if( ch->level >= channel->hinvis[x] )
channels.c:   if( xIS_SET( ch->act, PLR_SILENCE ) )
channels.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
channels.c:      sprintf( log_buf, "&w[&%s%s&w] &%s%s %s\r\n", clr, capitalize( channel->name ), clr, ch->name, argument + 1 );
channels.c:         sprintf( buf, "Profanity attempt by %s on channel %s: %s", ch->name, channel->name, argument );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:      sprintf( buf2, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument, channel->name );
channels.c:         if( xIS_SET( ch->act, PLR_WIZINVIS ) )
channels.c:               channel->history[x][0] = str_dup( ch->short_descr );
channels.c:               channel->history[x][0] = str_dup( ch->name );
channels.c:               channel->hinvis[x] = ch->pcdata->wizinvis;
channels.c:               channel->history[x][0] = str_dup( ch->short_descr );
channels.c:               channel->history[x][0] = str_dup( ch->name );
channels.c:               channel->hinvis[x] = ch->pcdata->wizinvis;
channels.c:   for( vch = first_char; vch; vch = vch->next )
channels.c:      if( IS_NPC( vch ) || vch == ch || !vch->desc )
channels.c:      if( vch->desc->connected == CON_PLAYING && hasname( vch->pcdata->chan_listen, channel->name ) )
channels.c:         if( vch->level < channel->level )
channels.c:         if( !str_cmp( channel->name, "newbiechat" ) && ( !IS_IMMORTAL( vch ) && vch->level < 5 ) )
channels.c:         if( !str_cmp( channel->name, "avtalk" ) && vch->level < LEVEL_AVATAR )
channels.c:         if( IS_SET( vch->in_room->room_flags, ROOM_SILENCE ) )
channels.c:         if( channel->type == CHAN_ZONE && vch->in_room->area != ch->in_room->area )
channels.c:            if( vch->pcdata->clan != ch->pcdata->clan )
channels.c:            if( vch->pcdata->council != ch->pcdata->council )
channels.c:         position = vch->position;
channels.c:         vch->position = POS_STANDING;
channels.c:         if( xIS_SET( ch->act, PLR_WIZINVIS ) && can_see( vch, ch ) && IS_IMMORTAL( vch ) )
channels.c:            sprintf( lbuf, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
channels.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:            int speakswell = UMIN( knows_language( vch, ch->speaking ), knows_language( ch, ch->speaking ) );
channels.c:         if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
channels.c:            sbuf = scramble( argument, ch->speaking );
channels.c:            if( !IS_IMMORTAL( ch ) || vch->level > ch->level )
channels.c:         vch->position = position;
channels.c:      if( vch->level < level )
channels.c:      if( d->connected == CON_PLAYING && vch->level >= channel->level && hasname( vch->pcdata->chan_listen, channel->name ) )
channels.c:   if( ch->level < channel->level )
channels.c:   if( !IS_NPC( ch ) && !hasname( ch->pcdata->chan_listen, command ) )
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_IMMORTAL(ch) )
channels.c:   actflags = ch->act;
channels.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
channels.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
channels.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", ch->name );
channels.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:         int speakswell = UMIN( knows_language( vch, ch->speaking ), knows_language( ch, ch->speaking ) );
channels.c:      if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
channels.c:         sbuf = scramble( argument, ch->speaking );
channels.c:   ch->act = actflags;
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:      sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:         if( ch->pcdata->say_history[x] == NULL )
channels.c:         sprintf( buffer, " &c%s&w\r\n", ch->pcdata->say_history[x] );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_IMMORTAL(ch) )
channels.c:   actflags = ch->act;
channels.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
channels.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
channels.c:            ch_printf( vch, "You attempt to ignore %s, but" " are unable to do so.\r\n", ch->name );
channels.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:         int speakswell = UMIN( knows_language( vch, ch->speaking ),
channels.c:                                knows_language( ch, ch->speaking ) );
channels.c:      if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
channels.c:         sbuf = scramble( argument, ch->speaking );
channels.c:            if( vch->pcdata->say_history[x] == '\0' )
channels.c:               vch->pcdata->say_history[x] = strdup( tmpbuf );
channels.c:                  DISPOSE( vch->pcdata->say_history[i - 1] );
channels.c:                  vch->pcdata->say_history[i - 1] = strdup( vch->pcdata->say_history[i] );
channels.c:               DISPOSE( vch->pcdata->say_history[x] );
channels.c:               vch->pcdata->say_history[x] = strdup( tmpbuf );
channels.c:   ch->act = actflags;
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:      sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
channels.c:         if( ch->pcdata->tell_histories[x] == NULL )
channels.c:            ch->pcdata->tell_histories[x] = str_dup( arg );
channels.c:               DISPOSE( ch->pcdata->tell_histories[i - 1] );
channels.c:               ch->pcdata->tell_histories[i - 1] = str_dup( ch->pcdata->tell_histories[i] );
channels.c:            ch->pcdata->tell_histories[x] = str_dup( arg );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:      REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_IMMORTAL(ch) )
channels.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
channels.c:         if( ch->pcdata->tell_histories[x] == NULL )
channels.c:         sprintf( buf + strlen( buf ), "%s\r\n", ch->pcdata->tell_histories[x] );
channels.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
channels.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", ch->name );
channels.c:   ch->retell = victim;
channels.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
channels.c:      sprintf( buf, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
channels.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
channels.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:      int speakswell = UMIN( knows_language( victim, ch->speaking ),
channels.c:                             knows_language( ch, ch->speaking ) );
channels.c:            capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:            && victim->in_room != ch->in_room ) || ( !NOT_AUTHED( ch ) && NOT_AUTHED( victim ) && !IS_IMMORTAL( ch ) ) )
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_IMMORTAL(ch) )
channels.c:   actflags = ch->act;
channels.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
channels.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
channels.c:            ch_printf( vch, "You attempt to ignore %s, but" " are unable to do so.\r\n", ch->name );
channels.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:         int speakswell = UMIN( knows_language( vch, ch->speaking ),
channels.c:                                knows_language( ch, ch->speaking ) );
channels.c:      if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
channels.c:         sbuf = scramble( argument, ch->speaking );
channels.c:   ch->act = actflags;
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:      sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:   REMOVE_BIT( ch->deaf, CHANNEL_WHISPER );
channels.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", ch->name );
channels.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:      int speakswell = UMIN( knows_language( victim, ch->speaking ),
channels.c:                             knows_language( ch, ch->speaking ) );
channels.c:   if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
channels.c:if( !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
channels.c:if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:            IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:      REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_IMMORTAL(ch) )
channels.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
channels.c:   if( ( victim = ch->reply ) == NULL )
channels.c:         ch_printf( victim, "You attempt to ignore %s, but " "are unable to do so.\r\n", ch->name );
channels.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:      int speakswell = UMIN( knows_language( victim, ch->speaking ),
channels.c:                             knows_language( ch, ch->speaking ) );
channels.c:   if( knows_language( victim, ch->speaking ) || ( IS_NPC( ch ) && !ch->speaking ) )
channels.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
channels.c:   sprintf( buf2, "&R%s told you &r'&R%s&r'&w", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
channels.c:   ch->retell = victim;
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
channels.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
channels.c:      sprintf( buf, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
channels.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:      REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE) && !IS_IMMORTAL(ch) )
channels.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
channels.c:   victim = ch->retell;
channels.c:         ch_printf( victim, "You attempy to ignore %s, but " "are unable to do so.\r\n", ch->name );
channels.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
channels.c:      sprintf( buf, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
channels.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
channels.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:      int speakswell = UMIN( knows_language( victim, ch->speaking ),
channels.c:                             knows_language( ch, ch->speaking ) );
channels.c:   if( knows_language( victim, ch->speaking ) || ( IS_NPC( ch ) && !ch->speaking ) )
channels.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
channels.c:   if( IS_NPC( ch ) || !IS_IMMORTAL( ch ) || !ch->pcdata->tell_history )
channels.c:      tindex = ch->pcdata->lt_index;
channels.c:   if( ch->pcdata->tell_history[tindex] )
channels.c:      send_to_char( ch->pcdata->tell_history[tindex], ch );
channels.c:      if( ch->speaking & lang_array[lang] )
channels.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
channels.c:   actflags = ch->act;
channels.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
channels.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
channels.c:            ch_printf( vch, "You attempt to ignore %s, but" " are unable to do so.\r\n", ch->name );
channels.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
channels.c:         int speakswell = UMIN( knows_language( vch, ch->speaking ),
channels.c:                                knows_language( ch, ch->speaking ) );
channels.c:      if( !knows_language( vch, ch->speaking ) && ( !IS_NPC( ch ) && ch->speaking != 0 ) )
channels.c:         sbuf = scramble( buf, ch->speaking );
channels.c:   ch->act = actflags;
channels.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
channels.c:      sprintf( buf, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( str_cmp( ch->name, clan->leader ) && str_cmp( ch->name, clan->deity )
clans.c:    ||   (str_cmp( ch->name, clan->number1 )
clans.c:    || str_cmp( ch->name, clan->number2 ))) ) */
clans.c:       && str_cmp( ch->name, clan->number1 ) && str_cmp( ch->name, clan->number2 ) )
clans.c:      obj = obj_to_room( obj, ch->in_room );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "induct", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader )
clans.c:       || !str_cmp( ch->name, clan->number1 )
clans.c:       || !str_cmp( ch->name, clan->number2 ) || IS_SET( ch->pcdata->flags, PCFLAG_INDUCTOR ) )
clans.c:	if ( victim->level > ch->level )
clans.c:            ch_printf( victim, "%s instructs you in the ways of %s.\r\n", ch->name, skill_table[sn]->name );
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( council != ch->pcdata->council && council != ch->pcdata->council2 )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:      ch_printf( ch, "Your status within %s has saved you from being outcast.\r\n", ch->pcdata->clan->name );
clans.c:   clan = ch->pcdata->clan;
clans.c:         if( skill_table[sn]->guild == ch->pcdata->clan->class && skill_table[sn]->name != NULL )
clans.c:            ch->pcdata->learned[sn] = 0;
clans.c:   if( ch->speaking & LANG_CLAN )
clans.c:      ch->speaking = LANG_COMMON;
clans.c:   REMOVE_BIT( ch->speaks, LANG_CLAN );
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   ch->pcdata->clan = NULL;
clans.c:   STRFREE( ch->pcdata->clan_name );
clans.c:   ch->pcdata->clan_name = STRALLOC( "" );
clans.c:      sprintf( buf, "%s has been outcasted from %s!", ch->name, clan->name );
clans.c:   rem_clan_member( clan, ch->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "outcast", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader )
clans.c:       || !str_cmp( ch->name, clan->number1 )
clans.c:       || !str_cmp( ch->name, clan->number2 ) || IS_SET( ch->pcdata->flags, PCFLAG_INDUCTOR ) )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( victim->level > ch->level )
clans.c:   if( victim->pcdata->clan != ch->pcdata->clan )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->deity ) )
clans.c:      STRFREE( ch->pcdata->clan->deity );
clans.c:      ch->pcdata->clan->deity = STRALLOC( "" );
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( council != ch->pcdata->council && council != ch->pcdata->council2 )
clans.c:   if( council->head2 && !str_cmp( victim->name, ch->pcdata->council->head2 ) )
clans.c:      STRFREE( ch->pcdata->council->head2 );
clans.c:      ch->pcdata->council->head2 = NULL;
clans.c:   if( !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( !str_cmp( ch->name, order->deity )
clans.c:       || !str_cmp( ch->name, order->leader )
clans.c:       || !str_cmp( ch->name, order->number1 ) || !str_cmp( ch->name, order->number2 ) )
clans.c:   if( !str_cmp( ch->name, guild->deity )
clans.c:       || !str_cmp( ch->name, guild->leader )
clans.c:       || !str_cmp( ch->name, guild->number1 ) || !str_cmp( ch->name, guild->number2 ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
clans.c:      sprintf( filename, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
clans.c:      if( !str_cmp( ch->name, ch->pcdata->clan->leader ) && !str_cmp( argument, "clean" ) )
clans.c:    || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ch->level - victim->level > 10 || victim->level - ch->level > 10 )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->class == CLASS_WARRIOR )
clans.c:   if( ch->class == CLASS_VAMPIRE )
clans.c:   if( ch->class == CLASS_RANGER )
clans.c:   if( ch->class == CLASS_DRUID )
clans.c:   if( ch->class == CLASS_CLERIC )
clans.c:   if( ch->class == CLASS_THIEF )
clans.c:   if( ch->class == CLASS_MAGE )
clans.c:   if( ch->class == CLASS_AUGURER )
clans.c:   if( ch->class == CLASS_PALADIN )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == RACE_ELF )
clans.c:   if( ch->race == RACE_DWARF )
clans.c:   if( ch->race == RACE_HALFLING )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_HALF_OGRE )
clans.c:   if( ch->race == RACE_HALF_ORC )
clans.c:   if( ch->race == RACE_HALF_TROLL )
clans.c:   if( ch->race == RACE_HALF_ELF )
clans.c:   if( ch->race == RACE_GITH )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_DROW )
clans.c:   if( ch->race == RACE_SEA_ELF )
clans.c:   if( ch->race == RACE_LIZARDMAN )
clans.c:   if( ch->race == RACE_GNOME )
clans.c:   move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   if( ch->level - victim->level > 10 || victim->level - ch->level > 10 )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->class == CLASS_WARRIOR )
clans.c:   if( ch->class == CLASS_VAMPIRE )
clans.c:   if( ch->class == CLASS_RANGER )
clans.c:   if( ch->class == CLASS_DRUID )
clans.c:   if( ch->class == CLASS_CLERIC )
clans.c:   if( ch->class == CLASS_THIEF )
clans.c:   if( ch->class == CLASS_MAGE )
clans.c:   if( ch->class == CLASS_AUGURER )
clans.c:   if( ch->class == CLASS_PALADIN )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == RACE_ELF )
clans.c:   if( ch->race == RACE_DWARF )
clans.c:   if( ch->race == RACE_HALFLING )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_HALF_OGRE )
clans.c:   if( ch->race == RACE_HALF_ORC )
clans.c:   if( ch->race == RACE_HALF_TROLL )
clans.c:   if( ch->race == RACE_HALF_ELF )
clans.c:   if( ch->race == RACE_GITH )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_DROW )
clans.c:   if( ch->race == RACE_SEA_ELF )
clans.c:   if( ch->race == RACE_LIZARDMAN )
clans.c:   if( ch->race == RACE_GNOME )
clans.c:      move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:      move_char( ch, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:   clan = ch->pcdata->clan;
clans.c:   name = capitalize( ch->name );
clans.c:   if( str_cmp( ch->name, clan->leader ) )
comm.c:      ch_next = ch->next;
comm.c:         for( ch = room->first_person; ch; ch = ch->next )
comm.c:      watch_next = watch->next;
comm.c:      if( watch->imm_name )
comm.c:         DISPOSE( watch->imm_name );
comm.c:      if( watch->player_site )
comm.c:         DISPOSE( watch->player_site );
comm.c:      if( watch->target_name )
comm.c:         DISPOSE( watch->target_name );
comm.c:      for( vch = first_char; vch; vch = vch->next )
comm.c:      for( vch = first_char; vch; vch = vch->next )
comm.c:           ch ? ch->name : d->host, dclose, first_descriptor );
comm.c:            bug( "Close_socket: %s desc:%p found, prev should be:%p, fixing.", ch ? ch->name : d->host, dclose, dp );
comm.c:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c:           ch ? ch->name : d->host, dclose, last_descriptor );
comm.c:            bug( "Close_socket: %s desc:%p found, next should be:%p, fixing.", ch ? ch->name : d->host, dclose, dn );
comm.c:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c:      drop_artifacts( ch, ch->last_carrying );
comm.c:      sprintf( log_buf, "Closing link to %s.", ch->pcdata->filename );
comm.c:      log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:	if ( ch->level < LEVEL_DEMI )
comm.c:	  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );
comm.c:         ch->desc = NULL;
comm.c:         ch->desc = NULL;
comm.c:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( ch->dest_buf )
comm.c:      argument = ch->dest_buf;
comm.c:   switch ( ch->substate )
comm.c:         if( ch->pcdata->sendmail )
comm.c:            STRFREE( ch->pcdata->sendmail );
comm.c:         ch->pcdata->sendmail = STRALLOC( "" );
comm.c:         ch->substate = SUB_WRITING_EMAIL;
comm.c:         ch->dest_buf = passargument;
comm.c:         start_editing( ch, ch->pcdata->sendmail );
comm.c:         STRFREE( ch->pcdata->sendmail );
comm.c:         ch->pcdata->sendmail = copy_buffer( ch );
comm.c:         send_email( &arg1[0], &arg2[0], ch->pcdata->sendmail, ch );
comm.c:         bug( "-------------%s is sending an email to %s-------------\r\n", ch->name, arg2 );
comm.c:         if( xIS_SET( ch->act, PLR_DENY ) )
comm.c:            STRFREE( ch->name );
comm.c:            ch->name = STRALLOC( argument );
comm.c:         if( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:         if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c:          * if ( check_login( d, ch->pcdata->filename ) )
comm.c:         chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c:         strcpy( buf, ch->pcdata->filename );
comm.c:         if( ch->position == POS_FIGHTING
comm.c:             || ch->position == POS_EVASIVE
comm.c:             || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c:            ch->position = POS_STANDING;
comm.c:         sprintf( log_buf, "%s@%s(%s) has connected.", ch->pcdata->filename, d->host, d->user );
comm.c:         if( ch->level < LEVEL_DEMI )
comm.c:             * to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );
comm.c:            log_string_plus( log_buf, LOG_COMM, ch->level );
comm.c:            sprintf( log_buf, "%-20s     %-24s    %s", ch->pcdata->filename, day, d->host );
comm.c:                        "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c:         pwdnew = crypt( argument, ch->name );
comm.c:         DISPOSE( ch->pcdata->pwd );
comm.c:         ch->pcdata->pwd = str_dup( pwdnew );
comm.c:         if( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:               ch->sex = SEX_MALE;
comm.c:               ch->sex = SEX_FEMALE;
comm.c:               ch->sex = SEX_NEUTRAL;
comm.c:         STRFREE( ch->pcdata->hair_color );
comm.c:               ch->pcdata->hair_color = STRALLOC( "" );
comm.c:         STRFREE( ch->pcdata->hair_length );
comm.c:               ch->pcdata->hair_length = STRALLOC( "" );
comm.c:         STRFREE( ch->pcdata->eye_color );
comm.c:               ch->pcdata->eye_color = STRALLOC( "" );
comm.c:         STRFREE( ch->pcdata->skin_tone );
comm.c:               ch->pcdata->skin_tone = STRALLOC( "" );
comm.c:         STRFREE( ch->pcdata->ch_build );
comm.c:               ch->pcdata->ch_build = STRALLOC( "" );
comm.c:         STRFREE( ch->pcdata->ch_height );
comm.c:               ch->pcdata->ch_height = STRALLOC( "" );
comm.c:               ch->class = iClass;
comm.c:                && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->class )
comm.c:               ch->race = iRace;
comm.c:             || IS_SET( race_table[iRace]->class_restriction, 1 << ch->class )
comm.c:               xSET_BIT( ch->act, PLR_ANSI );
comm.c:         sprintf( log_buf, "%s@%s new %s %s.", ch->name, d->host,
comm.c:                  race_table[ch->race]->race_name, class_table[ch->class]->who_name );
comm.c:         ch->level = 0;
comm.c:         ch->position = POS_STANDING;
comm.c:         if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c:            SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:            REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:         if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:         if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:         if( ch->level >= 104 )
comm.c:         else if( ch->level >= 101 )
comm.c:         else if( ch->level >= 50 )
comm.c:         else if( ch->level >= 2 )
comm.c:         if( xIS_SET( ch->act, PLR_NOMENU ) || ( ch->level < 2 ) )
comm.c:         if( ch->level < 2 )
comm.c:         if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:         if( !xIS_SET( ch->act, PLR_NOMENU ) )
comm.c:               if( ch->level >= 104 )
comm.c:               else if( ch->level >= 101 )
comm.c:               else if( ch->level >= 50 )
comm.c:               else if( ch->level >= 2 )
comm.c:         if( ch->level == 0 )
comm.c:            ch->day = time_info.day;
comm.c:            ch->month = time_info.month;
comm.c:            ch->year = time_info.year - 17;
comm.c:            ch->age = 17;
comm.c:            ch->age_bonus = 0;
comm.c:            ch->pcdata->clan_name = STRALLOC( "" );
comm.c:            ch->pcdata->clan = NULL;
comm.c:            switch ( class_table[ch->class]->attr_prime )
comm.c:                  ch->perm_str = 16;
comm.c:                  ch->perm_int = 16;
comm.c:                  ch->perm_wis = 16;
comm.c:                  ch->perm_dex = 16;
comm.c:                  ch->perm_con = 16;
comm.c:                  ch->perm_cha = 16;
comm.c:                  ch->perm_lck = 16;
comm.c:            ch->perm_str += race_table[ch->race]->str_plus;
comm.c:            ch->perm_int += race_table[ch->race]->int_plus;
comm.c:            ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c:            ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c:            ch->perm_con += race_table[ch->race]->con_plus;
comm.c:            ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c:            ch->affected_by = race_table[ch->race]->affected;
comm.c:            ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c:            ch->armor += race_table[ch->race]->ac_plus;
comm.c:            ch->alignment += ( race_table[ch->race]->alignment + class_table[ch->class]->alignment ) / 2;
comm.c:            ch->attacks = race_table[ch->race]->attacks;
comm.c:            ch->defenses = race_table[ch->race]->defenses;
comm.c:            ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c:            ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c:            ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c:            ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c:            ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c:            ch->height = number_range( race_table[ch->race]->height * .9, race_table[ch->race]->height * 1.1 );
comm.c:            ch->weight = number_range( race_table[ch->race]->weight * .9, race_table[ch->race]->weight * 1.1 );
comm.c:               ch->pcdata->learned[iLang] = 100;
comm.c:            if( race_table[ch->race] )
comm.c:                  if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c:                        ch->pcdata->learned[uLang] = 100;
comm.c:            ch->level = 1;
comm.c:            ch->exp = 0;
comm.c:            ch->hit = ch->max_hit;
comm.c:            ch->mana = ch->max_mana;
comm.c:            ch->hit += race_table[ch->race]->hit;
comm.c:            ch->mana += race_table[ch->race]->mana;
comm.c:            ch->move = ch->max_move;
comm.c:            if( ch->pcdata->clan )
comm.c:               ch->pcdata->memorize[0] = ch->pcdata->clan->recall;
comm.c:               ch->pcdata->memorize[0] = ROOM_VNUM_TEMPLE;
comm.c:            sprintf( buf, "the %s", title_table[ch->class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:            xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c:            xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c:            ch->pcdata->chan_listen = STRALLOC( "chat auction quest music newbiechat guildtalk clantalk ordertalk ooc icc" );
comm.c:               ch->pcdata->auth_state = 0;
comm.c:               SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c:            ch->pcdata->prompt = STRALLOC( "" );
comm.c:         else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c:            if( ch->in_room->vnum == 6 )
comm.c:               char_to_room( ch, ch->in_room );
comm.c:         else if( ch->in_room && ( IS_IMMORTAL( ch ) || !IS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c:            char_to_room( ch, ch->in_room );
comm.c:         ch->pcdata->outputprefix = NULL;
comm.c:         ch->pcdata->outputsuffix = NULL;
comm.c:         ch->pcdata->alias_queue = NULL;
comm.c:         if( !xIS_SET( ch->act, PLR_NEWMONEY ) )
comm.c:            ch->gold = ( ch->gold / 5000 );
comm.c:            xSET_BIT( ch->act, PLR_NEWMONEY );
comm.c:         sprintf( buf, "%s has entered the realm.", ch->name );
comm.c:          * log_string_plus( buf, LOG_COMM, ch->level+1 );
comm.c:         if( ch->pcdata->pet )
comm.c:            act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c:            act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c:         SET_BIT( ch->pcdata->flags, PCFLAG_IMMPROOF );
comm.c:         if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:            ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:         else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:            ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:         else if( !ch->was_in_room )
comm.c:            ch->was_in_room = ch->in_room;
comm.c:   for( ch = first_char; ch; ch = ch->next )
comm.c:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c:         if( fConn && ch->switched )
comm.c:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:            ch->desc = d;
comm.c:            ch->timer = 0;
comm.c:            sprintf( log_buf, "%s@%s(%s) reconnected.", ch->pcdata->filename, d->host, d->user );
comm.c:            log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:            if( ch->pcdata->in_progress )
comm.c:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_NOTE_TO ) )
comm.c:            sprintf( log_buf, "%s already connected.", ch->pcdata->filename );
comm.c:         ch->desc = d;
comm.c:         ch->timer = 0;
comm.c:         if( ch->switched )
comm.c:            do_return( ch->switched, "" );
comm.c:         ch->switched = NULL;
comm.c:         sprintf( log_buf, "%s@%s reconnected, kicking off old link.", ch->pcdata->filename, d->host );
comm.c:         log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:       || !ch->desc
comm.c:       || ch->desc->connected != CON_PLAYING || !ch->was_in_room || ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:   ch->timer = 0;
comm.c:   was_in_room = ch->was_in_room;
comm.c:   if( !txt || !ch->desc )
comm.c:   d = ch->desc;
comm.c:   if( !txt || !ch->desc )
comm.c:   d = ch->desc;
comm.c:   if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
comm.c:   if( !ch || !ch->desc )
comm.c:   och = ( ch->desc->original ? ch->desc->original : ch );
comm.c:   if( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) )
comm.c:      ch->desc->prevcolor = AType;  /* added this, was in 1.02 */
comm.c:      ch->desc->pagecolor = AType;  /* cooridnate page & nopage shogar */
comm.c:      write_to_buffer( ch->desc, buf, strlen( buf ) );
comm.c:   if( !ch || !ch->desc )
comm.c:   och = ( ch->desc->original ? ch->desc->original : ch );
comm.c:   if( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) )
comm.c:      ch->desc->pagecolor = AType;
comm.c:      ch->desc->prevcolor = AType;  /* cooridnate page & nopage shogar */
comm.c:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c:      return ch->morph->morph->short_desc;
comm.c:               if( ch->morph == NULL )
comm.c:               if( vch->morph == NULL )
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                  i = he_she[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                  i = he_she[URANGE( 0, vch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                  i = him_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                  i = him_her[URANGE( 0, vch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                  i = his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                  i = his_her[URANGE( 0, vch->sex, 2 )];
comm.c:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:   if( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c:         bug( "%s (%s)", ch->name, format );
comm.c:      if( !vch->in_room )
comm.c:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:/*	to = vch->in_room->first_person;*/
comm.c:                                 ( !IS_IMMORTAL( to ) && !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_WIZINVIS )
comm.c:                                                                                 ( ch->pcdata ? ch->pcdata->
comm.c:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c:   if( !str_cmp( ch->name, argument ) )
comm.c:   STRFREE( ch->name );
comm.c:   ch->name = STRALLOC( argument );
comm.c:   STRFREE( ch->pcdata->filename );
comm.c:   ch->pcdata->filename = STRALLOC( argument );
comm.c:   ch->pcdata->auth_state = 0;
comm.c:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c:      prompt = ch->pcdata->subprompt;
comm.c:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c:   else if( ch->fighting )
comm.c:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c:         prompt = ch->pcdata->fprompt;
comm.c:      prompt = ch->pcdata->prompt;
comm.c:                  if( ch->level >= 10 )
comm.c:                     pstat = ch->alignment;
comm.c:                  pstat = ch->hit;
comm.c:                  pstat = ch->max_hit;
comm.c:                     pstat = ch->mana;
comm.c:                     pstat = ch->max_mana;
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c:                     pstat = ch->level + 10;
comm.c:                  pstat = ch->move;
comm.c:                  pstat = ch->max_move;
comm.c:                  pstat = ch->gold;
comm.c:                  pstat = ch->silver;
comm.c:                  pstat = ch->copper;
comm.c:                     pstat = ch->in_room->vnum;
comm.c:                     sprintf( pbuf, "%s", flag_string( ch->in_room->room_flags, r_flags ) );
comm.c:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c:                     sprintf( pbuf, "<#%d> ", ch->in_room->vnum );
comm.c:                  if( xIS_SET( ch->act, PLR_AFK ) )
comm.c:                  pstat = ch->exp;
comm.c:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c:                  if( ch->style == STYLE_BERSERK )
comm.c:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c:                  else if( ch->style == STYLE_EVASIVE )
comm.c:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c:                     sprintf( pbuf, "(Invis %d) ", ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c:                           : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c:   ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   sprintf( buf, "\r\n[INFO] COPYOVER by %s - please remain seated!\r\n\a", ch->name );
comm.c:         fprintf( fp, "%d %s %s\n", d->descriptor, och->name, d->host );
comm.c:         if( och->level == 1 )
comm.c:            och->level++;  /* Advance_level doesn't do that */
comments.c: * save.c:107:     if ( ch->comments )                                              (* saves comments *)
comments.c: * save.c:411:    ch->comments                        = NULL;                   (* nulls ch->comments *)
comments.c:   if( !ch->desc )
comments.c:   if( ch->desc->connected == CON_EDITING || ch->desc->connected == CON_NOTE_TO )
comments.c:   switch ( ch->substate )
comments.c:         if( !ch->pnote )
comments.c:         if( ch->dest_buf != ch->pnote )
comments.c:            bug( "do_comment: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
comments.c:         STRFREE( ch->pnote->text );
comments.c:         ch->pnote->text = copy_buffer( ch );
comments.c:      ch->substate = SUB_WRITING_NOTE;
comments.c:      ch->dest_buf = ch->pnote;
comments.c:      start_editing( ch, ch->pnote->text );
comments.c:      STRFREE( ch->pnote->subject );
comments.c:      ch->pnote->subject = STRALLOC( argument );
comments.c:      STRFREE( ch->pnote->to_list );
comments.c:      ch->pnote->to_list = STRALLOC( argument );
comments.c:      if( ch->pnote )
comments.c:         STRFREE( ch->pnote->text );
comments.c:         STRFREE( ch->pnote->subject );
comments.c:         STRFREE( ch->pnote->to_list );
comments.c:         STRFREE( ch->pnote->date );
comments.c:         STRFREE( ch->pnote->sender );
comments.c:         DISPOSE( ch->pnote );
comments.c:      ch->pnote = NULL;
comments.c:      if( !ch->pnote )
comments.c:      sprintf( buf, "%s: %s\r\nTo: %s\r\n", ch->pnote->sender, ch->pnote->subject, ch->pnote->to_list );
comments.c:      send_to_char( ch->pnote->text, ch );
comments.c:      if( !ch->pnote )
comments.c:      ch->pnote->date = STRALLOC( strtime );
comments.c:      pnote = ch->pnote;
comments.c:      ch->pnote = NULL;
comments.c:   if( !ch->comments )
comments.c:   for( pnote = ch->comments; pnote; pnote = pnote->next )
comments.c:      pnote->next = ch->comments;
comments.c:      ch->comments = pnote;
copyover.c:	sprintf (buf, "\n\r&R[&WINFO&R] &cCOPYOVER initiated by %s, sorry for the inconvenience!\n\r", ch->name);
copyover.c:			fprintf (fp, "%d %s %s\n", d->descriptor, och->name, d->host);
copyover.c:			if (och->level == 1)
copyover.c:				och->level++; /* Advance_level doesn't do that */
db.c:         for( pch = first_char; pch; pch = pch->next )
db.c:                && pch->in_room && pch->in_room->area == pArea && ( pch->desc && pch->desc->connected == CON_PLAYING ) )
db.c:   ch->editor = NULL;
db.c:   ch->hunting = NULL;
db.c:   ch->fearing = NULL;
db.c:   ch->hating = NULL;
db.c:   ch->name = NULL;
db.c:   ch->short_descr = NULL;
db.c:   ch->long_descr = NULL;
db.c:   ch->description = NULL;
db.c:   ch->next = NULL;
db.c:   ch->prev = NULL;
db.c:   ch->reply = NULL;
db.c:   ch->retell = NULL;
db.c:   ch->first_carrying = NULL;
db.c:   ch->last_carrying = NULL;
db.c:   ch->next_in_room = NULL;
db.c:   ch->prev_in_room = NULL;
db.c:   ch->fighting = NULL;
db.c:   ch->switched = NULL;
db.c:   ch->first_affect = NULL;
db.c:   ch->last_affect = NULL;
db.c:   ch->prev_cmd = NULL; /* maps */
db.c:   ch->last_cmd = NULL;
db.c:   ch->dest_buf = NULL;
db.c:   ch->alloc_ptr = NULL;
db.c:   ch->spare_ptr = NULL;
db.c:   ch->mount = NULL;
db.c:   ch->morph = NULL;
db.c:   xCLEAR_BITS( ch->affected_by );
db.c:   ch->logon = current_time;
db.c:   ch->armor = 100;
db.c:   ch->position = POS_STANDING;
db.c:   ch->practice = 0;
db.c:   ch->hit = 20;
db.c:   ch->max_hit = 20;
db.c:   ch->mana = 100;
db.c:   ch->max_mana = 100;
db.c:   ch->move = 100;
db.c:   ch->max_move = 100;
db.c:   ch->height = 72;
db.c:   ch->weight = 180;
db.c:   ch->xflags = 0;
db.c:   ch->race = 0;
db.c:   ch->class = 3;
db.c:   ch->class2 = 0;
db.c:   ch->class3 = 0;
db.c:   ch->level2 = -1;
db.c:   ch->level3 = -1;
db.c:   ch->speaking = LANG_COMMON;
db.c:   ch->speaks = LANG_COMMON;
db.c:   ch->barenumdie = 1;
db.c:   ch->baresizedie = 4;
db.c:   ch->substate = 0;
db.c:   ch->tempnum = 0;
db.c:   ch->perm_str = 13;
db.c:   ch->perm_dex = 13;
db.c:   ch->perm_int = 13;
db.c:   ch->perm_wis = 13;
db.c:   ch->perm_cha = 13;
db.c:   ch->perm_con = 13;
db.c:   ch->perm_lck = 13;
db.c:   ch->mod_str = 0;
db.c:   ch->mod_dex = 0;
db.c:   ch->mod_int = 0;
db.c:   ch->mod_wis = 0;
db.c:   ch->mod_cha = 0;
db.c:   ch->mod_con = 0;
db.c:   ch->mod_lck = 0;
db.c:   if( ch->desc )
db.c:   if( ch->morph )
db.c:      DISPOSE( ch->morph );
db.c:   while( ( obj = ch->last_carrying ) != NULL )
db.c:   while( ( paf = ch->last_affect ) != NULL )
db.c:   while( ( timer = ch->first_timer ) != NULL )
db.c:   if( ch->editor )
db.c:   STRFREE( ch->name );
db.c:   STRFREE( ch->short_descr );
db.c:   STRFREE( ch->long_descr );
db.c:   STRFREE( ch->description );
db.c:   if( ch->pnote )
db.c:      free_note( ch->pnote );
db.c:   if( ch->pcdata )
db.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
db.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
db.c:      STRFREE( ch->pcdata->filename );
db.c:      STRFREE( ch->pcdata->deity_name );
db.c:      STRFREE( ch->pcdata->clan_name );
db.c:      STRFREE( ch->pcdata->council_name );
db.c:      STRFREE( ch->pcdata->council2_name );
db.c:      DISPOSE( ch->pcdata->pwd );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfin );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfout );  /* no hash */
db.c:      DISPOSE( ch->pcdata->rank );
db.c:      STRFREE( ch->pcdata->title );
db.c:      STRFREE( ch->pcdata->bio );
db.c:      STRFREE( ch->pcdata->hair_color );
db.c:      STRFREE( ch->pcdata->eye_color );
db.c:      STRFREE( ch->pcdata->skin_tone );
db.c:      STRFREE( ch->pcdata->ch_build );
db.c:      STRFREE( ch->pcdata->hair_length );
db.c:      STRFREE( ch->pcdata->ch_height );
db.c:      if( ch->pcdata->hometown )
db.c:         ch->pcdata->hometown = NULL;
db.c:      if( ch->pcdata->nation )
db.c:         ch->pcdata->nation = NULL;
db.c:      if( ch->pcdata->wedto )
db.c:         STRFREE( ch->pcdata->wedto );
db.c:      if( ch->pcdata->in_progress )
db.c:         free_global_note( ch->pcdata->in_progress );
db.c:      if( ch->pcdata->extraname )
db.c:         STRFREE( ch->pcdata->extraname );
db.c:      if( ch->pcdata->lastname )
db.c:         STRFREE( ch->pcdata->lastname );
db.c:      for( count = 0; ch->pcdata->alias[count]; count++ )
db.c:         DISPOSE( ch->pcdata->alias[count] );
db.c:         DISPOSE( ch->pcdata->alias_sub[count] );
db.c:      if( ch->pcdata->outputprefix )
db.c:         DISPOSE( ch->pcdata->outputprefix );
db.c:      if( ch->pcdata->outputsuffix )
db.c:         DISPOSE( ch->pcdata->outputsuffix );
db.c:      for( alias = ch->pcdata->first_alias; alias; alias = alias_next )
db.c:      if( ch->pcdata->arena )
db.c:         DISPOSE( ch->pcdata->arena );
db.c:         if( ch->pcdata->say_history[x] )
db.c:            DISPOSE( ch->pcdata->say_history[x] );
db.c:      DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c:      DISPOSE( ch->pcdata->homepage ); /* no hash */
db.c:      DISPOSE( ch->pcdata->email ); /* no hash */
db.c:      STRFREE( ch->pcdata->authed_by );
db.c:      STRFREE( ch->pcdata->prompt );
db.c:      STRFREE( ch->pcdata->fprompt );
db.c:      if( ch->pcdata->helled_by )
db.c:         STRFREE( ch->pcdata->helled_by );
db.c:      if( ch->pcdata->subprompt )
db.c:         STRFREE( ch->pcdata->subprompt );
db.c:      if( ch->pcdata->tell_history )
db.c:            if( ch->pcdata->tell_history[i] )
db.c:               STRFREE( ch->pcdata->tell_history[i] );
db.c:         DISPOSE( ch->pcdata->tell_history );
db.c:      DISPOSE( ch->pcdata );
db.c:   for( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:   for( comments = ch->comments; comments; comments = comments_next )
db.c:      fprintf( fp, "[%5d] %-10s: %s\n", ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:      ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      pwatch->imm_level = number;
db.c:      pwatch->imm_name = fread_string_nohash( fp );
db.c:      pwatch->target_name = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->target_name ) < 2 )
db.c:         DISPOSE( pwatch->target_name );
db.c:      pwatch->player_site = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->player_site ) < 2 )
db.c:         DISPOSE( pwatch->player_site );
db.c:      if( pwatch->target_name )
db.c:         for( cmd = command_hash[( int )pwatch->target_name[0]]; cmd; cmd = cmd->next )
db.c:            if( !str_cmp( pwatch->target_name, cmd->name ) )
deity.c:   switch ( ch->substate )
deity.c:         deity = ch->dest_buf;
deity.c:         ch->substate = ch->tempnum;
deity.c:      if( ch->substate == SUB_REPEATCMD )
deity.c:         ch->tempnum = SUB_REPEATCMD;
deity.c:         ch->tempnum = SUB_NONE;
deity.c:      ch->substate = SUB_DEITYDESC;
deity.c:      ch->dest_buf = deity;
deity.c:   if( ch->level < 5 )
deity.c:      if( !ch->pcdata->deity )
deity.c:      --ch->pcdata->deity->worshippers;
deity.c:      if( ch->pcdata->deity->worshippers < 0 )
deity.c:         ch->pcdata->deity->worshippers = 0;
deity.c:      ch->pcdata->favor = -2500;
deity.c:      ch->mental_state = -80;
deity.c:      xREMOVE_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      REMOVE_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      save_deity( ch->pcdata->deity );
deity.c:      ch->pcdata->deity = NULL;
deity.c:      STRFREE( ch->pcdata->deity_name );
deity.c:      ch->pcdata->deity_name = STRALLOC( "" );
deity.c:   if( ch->pcdata->deity )
deity.c:   if( ( deity->sex != -1 ) && ( deity->sex != ch->sex ) )
deity.c:      if( ( deity->race != ch->race ) && ( deity->race2 != ch->race ) )
deity.c:    if ( ch->pcdata->deity )
deity.c:	--ch->pcdata->deity->worshippers;
deity.c:	ch->pcdata->favor = -2500;
deity.c:	xREMOVE_BITs( ch->affected_by, ch->pcdata->deity->affected );
deity.c:	REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:	save_deity(ch->pcdata->deity);
deity.c:   STRFREE( ch->pcdata->deity_name );
deity.c:   ch->pcdata->deity_name = QUICKLINK( deity->name );
deity.c:   ch->pcdata->deity = deity;
deity.c:   if( ch->pcdata->favor > deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   act( AT_MAGIC, "Body and soul, you devote yourself to $t!", ch, ch->pcdata->deity_name, NULL, TO_CHAR );
deity.c:   ++ch->pcdata->deity->worshippers;
deity.c:   save_deity( ch->pcdata->deity );
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->scorpse )
deity.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
deity.c:      sprintf( buf2, "the corpse of %s", ch->name );
deity.c:            obj = obj_to_room( obj, ch->in_room );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->savatar )
deity.c:      char_to_room( victim, ch->in_room );
deity.c:      sprintf( buf, victim->short_descr, ch->pcdata->deity->name );
deity.c:      sprintf( buf, victim->long_descr, ch->pcdata->deity->name );
deity.c:      sprintf( buf, victim->description, ch->pcdata->deity->name );
deity.c:      victim->hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      victim->alignment = ch->pcdata->deity->alignment;
deity.c:      victim->max_hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->savatar;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->sdeityobj )
deity.c:      obj = create_object( pObjIndex, ch->level );
deity.c:         obj = obj_to_room( obj, ch->in_room );
deity.c:      sprintf( buf, "sigil %s", ch->pcdata->deity->name );
deity.c:      sprintf( buf, obj->short_descr, ch->pcdata->deity->name );
deity.c:      sprintf( buf, obj->description, ch->pcdata->deity->name );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->sdeityobj;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      switch ( ch->pcdata->deity->objstat )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->suplift )
deity.c:      if( IS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:      if( ( ch->hit ) > ( ch->max_hit / 10 ) )
deity.c:      ch->hit += 10;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->srecall )
deity.c:      if( IS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:      if( ch->position == POS_FIGHTING )
deity.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
deity.c:         location = get_room_index( ch->pcdata->clan->recall );
deity.c:      if( ch->mount )
deity.c:         char_from_room( ch->mount );
deity.c:         char_to_room( ch->mount, location );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->srecall;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:   if( ( ch->alignment - ch->pcdata->deity->alignment > 650
deity.c:         || ch->alignment - ch->pcdata->deity->alignment < -650 ) && ch->pcdata->deity->alignment != 0 )
deity.c:      ch->pcdata->favor -= 2;
deity.c:      ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_magic / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->sac / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->bury_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid_spell / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->steal / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->backstab / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->spell_aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->dig_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcfoe / mod );
deity.c:   ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:       ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:       ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
disable.c:      disabled->who = STRALLOC( ch->name );
familiar.c:   if( ch->pcdata->pet != NULL )
familiar.c:   if( ch->position == POS_FIGHTING )
familiar.c:   if( ch->in_room->sector_type == SECT_INSIDE
familiar.c:       || ch->in_room->sector_type == SECT_WATER_SWIM
familiar.c:       || ch->in_room->sector_type == SECT_WATER_NOSWIM || ch->in_room->sector_type == SECT_AIR )
familiar.c:   mount->level = number_fuzzy( ( ch->level + ch->mod_cha ) / 2 );   // charisma bonus added by G
familiar.c:   mount->hit = mount->max_hit = number_fuzzy( ( ch->max_hit / 2 ) + ch->mod_cha );
familiar.c:   mount->armor = number_fuzzy( ch->armor - 10 );
familiar.c:   mount->hitroll = number_fuzzy( ch->level / 30 );
familiar.c:   mount->damroll = number_fuzzy( ch->level / 30 );
familiar.c:   switch ( ch->in_room->sector_type )
familiar.c:   char_to_room( mount, ch->in_room );
familiar.c:   ch->pcdata->pet = mount;
familiar.c:   ch->move -= ( mount->level / 2 );   /* physically draining lose of move */
fear.c:   if( !ch->fighting )
fear.c:   victim = ch->fighting->who;
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->arena && sysdata.arena != 2 )
fight.c:   hitroll = ch->hitroll + str_app[get_curr_str( ch )].tohit + 2 - ( abs( ( ch )->mental_state ) / 10 );
fight.c:   damroll = ch->damroll + ch->damplus + str_app[get_curr_str( ch )].todam
fight.c:      + ( ( ch->mental_state > 5 && ch->mental_state < 15 ) ? 1 : 0 );
fight.c:   if( !ch->hunting || ch->hunting->who != victim )
fight.c:   if( !ch->hating || ch->hating->who != victim )
fight.c:   if( !ch->fearing || ch->fearing->who != victim )
fight.c:   if( ch->hunting )
fight.c:      STRFREE( ch->hunting->name );
fight.c:      DISPOSE( ch->hunting );
fight.c:      ch->hunting = NULL;
fight.c:   if( ch->hating )
fight.c:      STRFREE( ch->hating->name );
fight.c:      DISPOSE( ch->hating );
fight.c:      ch->hating = NULL;
fight.c:   if( ch->fearing )
fight.c:      STRFREE( ch->fearing->name );
fight.c:      DISPOSE( ch->fearing );
fight.c:      ch->fearing = NULL;
fight.c:   if( ch->hunting )
fight.c:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:   ch->hunting->name = QUICKLINK( victim->name );
fight.c:   ch->hunting->who = victim;
fight.c:   if( ch->hating )
fight.c:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c:   ch->hating->name = QUICKLINK( victim->name );
fight.c:   ch->hating->who = victim;
fight.c:   if( ch->fearing )
fight.c:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:   ch->fearing->name = QUICKLINK( victim->name );
fight.c:   ch->fearing->who = victim;
fight.c:      if( ch == first_char && ch->prev )
fight.c:         ch->prev = NULL;
fight.c:      gch_prev = ch->prev;
fight.c:         sprintf( buf, "FATAL: violence_update: %s->prev->next doesn't point to ch.", ch->name );
fight.c:         ch->prev = NULL;
fight.c:      if( !ch->in_room || !ch->name )
fight.c:         log_printf( "ch: %ld  ch->in_room: %ld  ch->prev: %ld  ch->next: %ld",
fight.c:                     ( long )ch, ( long )ch->in_room, ( long )ch->prev, ( long )ch->next );
fight.c:            log_printf( "lst_ch: %ld  lst_ch->prev: %ld  lst_ch->next: %ld",
fight.c:                        ( long )lst_ch, ( long )lst_ch->prev, ( long )lst_ch->next );
fight.c:      if( ch->fighting )
fight.c:         if( ( ++ch->fighting->duration % 24 ) == 0 )
fight.c:            ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c:               DISPOSE( ch->pcdata->nuisance );
fight.c:               tempsub = ch->substate;
fight.c:               ch->substate = timer->value;
fight.c:               ch->substate = tempsub;
fight.c:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c:               ch->desc->character = ch->desc->original;
fight.c:               ch->desc->original = NULL;
fight.c:               ch->desc->character->desc = ch->desc;
fight.c:               ch->desc->character->switched = NULL;
fight.c:               ch->desc = NULL;
fight.c:         if( ch->pcdata->arena && ch->pcdata->arena->status == 2 && sysdata.arena != 2 )
fight.c:      if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:         sprintf( buf, "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:       * if( !IS_NPC( ch ) && ch->pcdata->condition[COND_BLEEDING] > 0 && number_range( 1, 4 ) == 1 )
fight.c:       *    damage( ch, ch, ch->pcdata->condition[COND_BLEEDING], TYPE_UNDEFINED );
fight.c:         if( !xIS_EMPTY( ch->attacks ) )
fight.c:            if( 30 + ( ch->level / 4 ) >= number_percent(  ) )
fight.c:                  if( xIS_SET( ch->attacks, attacktype ) )
fight.c:                     retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_spiral_blast( skill_lookup( "spiral blast" ), ch->level, ch, victim );
fight.c:                     retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c:                      * retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c:                      * retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c:                     retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c:                     retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c:                     retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c:                     retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c:                     retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c:                     retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c:                     retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c:                     retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c:                     retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c:         if( !xIS_EMPTY( ch->defenses ) )
fight.c:            if( 50 + ( ch->level / 4 ) > number_percent(  ) )
fight.c:                  if( xIS_SET( ch->defenses, attacktype ) )
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c:                        retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c:                     retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c:                        retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c:      for( rch = ch->in_room->first_person; rch; rch = rch_next )
fight.c:         rch_next = rch->next_in_room;
fight.c:             && ( rch->fighting )
fight.c:             && ( who_fighting( rch->fighting->who ) == ch )
fight.c:             && ( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) ) && ( rch->style < ch->style ) )
fight.c:            rch->fighting->who->fighting->who = rch;
fight.c:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c:               if( ( ( !IS_NPC( rch ) && rch->desc )
fight.c:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !xIS_SET( rch->act, ACT_NOASSIST )
fight.c:                && !xIS_SET( rch->act, ACT_PET ) )
fight.c:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c:                  for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
fight.c:                        if( vch->mount && vch->mount == rch )
fight.c:      if( xIS_SET( ch->act, PLR_NICE ) )
fight.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_NOATTACK ) )
fight.c:      dual_bonus = IS_NPC( ch ) ? ( ch->level / 10 ) : ( LEARNED( ch, gsn_dual_wield ) / 10 );
fight.c:      schance = IS_NPC( ch ) ? ch->level : LEARNED( ch, gsn_dual_wield );
fight.c:   if( ch->move < 10 )
fight.c:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_attack ) + dual_bonus ) / 1.5 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_attack ) + ( dual_bonus * 1.5 ) ) / 2 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_attack ) + ( dual_bonus * 2 ) ) / 3 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_attack ) + ( dual_bonus * 3 ) ) / 4 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_sixth_attack ) + ( dual_bonus * 3.5 ) ) / 5 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_seventh_attack ) + ( dual_bonus * 4 ) ) / 6 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_eighth_attack ) + ( dual_bonus * 4.5 ) ) / 7 );
fight.c:   schance = IS_NPC( ch ) ? ( int )( ch->level / 2 ) : 0;
fight.c:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c:      if( ch->move )
fight.c:         ch->move = UMAX( 0, ch->move - move );
fight.c:   if( !IS_NPC( ch ) && ch->level > 5 && wield )
fight.c:       * ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000 );
fight.c:         bonus -= ch->pcdata->favor / -400;
fight.c:      lvl = UMAX( 1, ( ch->level - 10 ) / 2 );
fight.c:            return ch->level;
fight.c:      lvl = ch->level / 2;
fight.c:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:   if( ch->fighting  /* make sure fight is already started */
fight.c:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && !xIS_EMPTY( ch->attacks ) )
fight.c:         if( xIS_SET( ch->attacks, attacktype ) )
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->class]->thac0_32;
fight.c://    thac0     = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL(ch);
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - get_hitroll( ch, FALSE );
fight.c:   if( ch->fighting && ch->fighting->who == victim )
fight.c:      short times = ch->fighting->timeskilled;
fight.c:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c:   if( ch->position == POS_BERSERK )
fight.c:   else if( ch->position == POS_AGGRESSIVE )
fight.c:   else if( ch->position == POS_DEFENSIVE )
fight.c:   else if( ch->position == POS_EVASIVE )
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 8 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 16 );
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->class]->thac0_32;
fight.c:   //    thac0     = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL(ch) + (dist*2);
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - get_hitroll( ch, FALSE ) + ( dist * 2 );
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
fight.c:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
fight.c:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
fight.c:      sprintf( buf, "Damage: null victim! Player: %s", ch->name );
fight.c:      if( ch->next )
fight.c:         if( ch->next->prev != ch )
fight.c:            bug( "who_fighting: ch->next->prev != ch. Shortcutting!!", 0 );
fight.c:            ch->next->prev = ch;
fight.c:      if( ch->prev )
fight.c:         if( ch->prev->next != ch )
fight.c:            bug( "who_fighting: ch->prev->next != ch. Shortcutting!!", 0 );
fight.c:            ch->prev->next = ch;
fight.c:               victim->hunting->name = QUICKLINK( ch->name );
fight.c:            victim->hating->name = QUICKLINK( ch->name );
fight.c:      maxdam = ( ch->level2 == -1 ) ? ch->level * 160 : ( ch->level3 == -1 ) ? ch->level2 * 80 : ch->level3 * 80;
fight.c:      maxdam = ( ch->level2 == -1 ) ? ch->level * 80 : ( ch->level3 == -1 ) ? ch->level2 * 40 : ch->level3 * 40;
fight.c:   if( dam > maxdam && !( ch->level >= 115 ) && !IS_NPC( ch ) )
fight.c:      sprintf( buf, "** %s (lvl %d) -> %s **", ch->name, ch->level, victim->name );
fight.c:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c:         if( !ch->fighting && victim->in_room == ch->in_room )
fight.c:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:         lch = ch->leader ? ch->leader : ch;
fight.c:               for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:               for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                 ( ch->leader == victim ) ? victim : ch, NULL,
fight.c:                 ( ch->leader == victim ) ? victim->master : ch->master, TO_NOTVICT );
fight.c:            if( ch->leader == victim )
fight.c:         if( ch->leader != NULL && !IS_NPC( ch->leader ) && !IS_PKILL( ch->leader ) )
fight.c:            act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, ch->master, TO_NOTVICT );
fight.c:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, gch->master, TO_NOTVICT );
fight.c:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", gch, NULL, gch->master, TO_NOTVICT );
fight.c:	for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:	for ( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c:      if( dt >= TYPE_HIT && ch->in_room == victim->in_room )
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->defenses, DFND_DISARM ) && ch->level > 9 && number_percent(  ) < ch->level / 3 ) /* Was 2 try this --Shaddai */
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_TRIP ) && ch->level > 5 && number_percent(  ) < ch->level / 2 )
fight.c:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c:      if( ch->fighting->who == victim )
fight.c:         xp_gain = ( int )( ch->fighting->xp * dam ) / victim->max_hit;
fight.c:       && is_wielding_poisoned( ch ) && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->level, victim ) )
fight.c:         if( !IS_NPC( ch ) && !IS_NPC( victim ) && victim->bounty > 0 && ch != victim && ch->name != victim->name )
fight.c:            ch->bowed += victim->bounty;
fight.c:            ch->bkills++;
fight.c:               adjust_hiscore( "bounty", ch, ch->bkills );
fight.c:            sprintf( log_buf, "%s has claimed the bounty from the head of %s!", ch->name, victim->name );
fight.c:         sprintf( log_buf, "%s has been killed by %s!", victim->name, ( IS_NPC( ch ) ? ch->short_descr : ch->name ) );
fight.c:                  victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c:         if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c:             && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD && victim != ch )
fight.c:            sprintf( filename, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c:                     ch->level,
fight.c:                     ch->name,
fight.c:                     "&P(&WUnclanned&P)", victim->name, ch->in_room->area->name );
fight.c:            if( victim->pcdata->clan && victim->pcdata->clan->name == ch->pcdata->clan->name )
fight.c:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      if( ch->in_room == victim->in_room )
fight.c:         if( xIS_SET( ch->act, PLR_AUTOGOLD ) )
fight.c:            init_gold = ch->gold;
fight.c:            init_silver = ch->silver;
fight.c:            init_copper = ch->copper;
fight.c:            new_gold = ch->gold;
fight.c:            new_silver = ch->silver;
fight.c:            new_copper = ch->copper;
fight.c:         if( xIS_SET( ch->act, PLR_AUTOLOOT ) && victim != ch )   /* prevent nasty obj problems -- Blodkai */
fight.c:         if( xIS_SET( ch->act, PLR_AUTOSAC ) )
fight.c:      bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c:   if( ( get_age( ch ) < 1 || ch->level < 5 ) && !in_arena( ch ) )   /* Scion arenacode */
fight.c:/*    if ( ch->level - victim->level > 5 
fight.c:    ||   victim->level - ch->level > 5 )
fight.c:   if( ( ch->level - victim->level > 10 || victim->level - ch->level > 10 ) && ( !in_arena( ch ) || !in_arena( victim ) ) )
fight.c:   if( IS_NPC( ch ) && !ch->master )
fight.c:/*    &&    IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) 
fight.c:            level_ratio = URANGE( 1, ch->level, MAX_LEVEL );
fight.c:            level_ratio = URANGE( 1, ch->level / victim->level, MAX_LEVEL );
fight.c:         if( ch->pcdata->clan )
fight.c:            ch->pcdata->clan->mkills++;
fight.c:         ch->pcdata->mkills++;
fight.c:            adjust_hiscore( "mkill", ch, ch->pcdata->mkills );
fight.c:         ch->in_room->area->mkills++;
fight.c:         if( ch->pcdata->deity )
fight.c:            if( victim->race == ch->pcdata->deity->npcrace )
fight.c:            else if( victim->race == ch->pcdata->deity->npcfoe )
fight.c:   if( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c:         ch->pcdata->pkills++;
fight.c:            adjust_hiscore( "pkill", ch, ch->pcdata->pkills );
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:            adjust_hiscore( "pkill", ch, ch->pcdata->pkills );
fight.c:         ch->in_room->area->pkills++;
fight.c:/*    &&    IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )
fight.c:      if( !ch->pcdata->clan
fight.c:          || ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c:               && victim->pcdata->clan->clan_type != CLAN_NOKILL && ch->pcdata->clan != victim->pcdata->clan ) )
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:            adjust_hiscore( "pkill", ch, ch->pcdata->pkills );
fight.c:         ch->hit = ch->max_hit;
fight.c:         ch->mana = ch->max_mana;
fight.c:         ch->move = ch->max_move;
fight.c:         if( ch->pcdata )
fight.c:            ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
fight.c:            if( ch->level < 10 )
fight.c:            else if( ch->level < 15 )
fight.c:            else if( ch->level < 20 )
fight.c:            else if( ch->level < 30 )
fight.c:            else if( ch->level < 40 )
fight.c:            else if( ch->level < 50 )
fight.c:      if( !ch->master )
fight.c:         sprintf( buf, "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:      if( ch->master )
fight.c:         check_killer( ch->master, victim );
fight.c:         level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c:            if( ch->race == victim->pcdata->deity->npcrace )
fight.c:            else if( ch->race == victim->pcdata->deity->npcfoe )
fight.c:      if( ch->pcdata->clan )
fight.c:         ch->pcdata->clan->illegal_pk++;
fight.c:      ch->pcdata->illegal_pk++;
fight.c:      ch->in_room->area->illegal_pk++;
fight.c:         if( ch->level < 10 )
fight.c:         else if( ch->level < 15 )
fight.c:         else if( ch->level < 20 )
fight.c:         else if( ch->level < 30 )
fight.c:         else if( ch->level < 40 )
fight.c:         else if( ch->level < 50 )
fight.c:   if( xIS_SET( ch->act, PLR_KILLER ) )
fight.c:   xSET_BIT( ch->act, PLR_KILLER );
fight.c:   if( xIS_SET( ch->act, PLR_ATTACKER ) )
fight.c:      xREMOVE_BIT( ch->act, PLR_ATTACKER );
fight.c:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c:      if( !ch->master )
fight.c:         sprintf( buf, "Check_attacker: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:       * xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c:       || ch == victim || ch->level >= LEVEL_IMMORTAL || xIS_SET( ch->act, PLR_ATTACKER ) || xIS_SET( ch->act, PLR_KILLER )
fight.c:   xSET_BIT( ch->act, PLR_ATTACKER );
fight.c:   if( ch->fighting )
fight.c:      sprintf( buf, "Set_fighting: %s -> %s (already fighting %s)", ch->name, victim->name, ch->fighting->who->name );
fight.c:   ch->num_fighting = 1;
fight.c:   ch->fighting = fight;
fight.c:    * ch->position = POS_FIGHTING; 
fight.c:      ch->position = POS_FIGHTING;
fight.c:      switch ( ch->style )
fight.c:            ch->position = POS_EVASIVE;
fight.c:            ch->position = POS_DEFENSIVE;
fight.c:            ch->position = POS_AGGRESSIVE;
fight.c:            ch->position = POS_BERSERK;
fight.c:            ch->position = POS_FIGHTING;
fight.c:   if( !ch->fighting )
fight.c:   if( ch->next )
fight.c:      if( ch->next->prev != ch )
fight.c:         bug( "who_fighting: ch->next->prev != ch. Shortcutting!!", 0 );
fight.c:         ch->next->prev = ch;
fight.c:   if( ch->prev )
fight.c:      if( ch->prev->next != ch )
fight.c:         bug( "who_fighting: ch->prev->next != ch. Shortcutting!!", 0 );
fight.c:         ch->prev->next = ch;
fight.c:   return ch->fighting->who;
fight.c:   if( ch->fighting )
fight.c:      if( !char_died( ch->fighting->who ) )
fight.c:         --ch->fighting->who->num_fighting;
fight.c:      DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if( ch->mount )
fight.c:      ch->position = POS_MOUNTED;
fight.c:      ch->position = POS_STANDING;
fight.c:   for( fch = first_char; fch; fch = fch->next )
fight.c:         for( i = 0; i < 32 && ch->xflags; i++ )
fight.c:      name = IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c:      obj = obj_to_room( obj, ch->in_room );
fight.c:   was_in_room = ch->in_room;
fight.c:         ch->in_room = pexit->to_room;
fight.c:   ch->in_room = was_in_room;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:   if( xIS_SET( ch->act, PLR_QUESTOR ) && IS_NPC( victim ) )
fight.c:      if( ch->questmob == victim->pIndexData->vnum )
fight.c:         ch->questmob = -1;
fight.c:   lch = ch->leader ? ch->leader : ch;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      if( gch->level - lch->level > 8 )
fight.c:      if( gch->level - lch->level < -8 )
fight.c:      if( !gch->fighting )
fight.c:      gch->alignment = align_compute( gch, victim );
fight.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
fight.c:             || ( IS_OBJ_STAT( obj, ITEM_ANTI_NEUTRAL ) && IS_NEUTRAL( ch ) ) || obj->level > ch->level )
fight.c:            obj = obj_to_room( obj, ch->in_room );
fight.c:   if( gch->level <= 5 )
fight.c:      return gch->alignment;
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > -350 && gch->alignment < 350 )
fight.c:      newalign = UMIN( gch->alignment + ( align - 500 ) / divalign, 1000 );
fight.c:      newalign = UMAX( gch->alignment + ( align + 500 ) / divalign, -1000 );
fight.c:      newalign = gch->alignment - ( int )( gch->alignment / divalign );
fight.c:   int gchlev = gch->level;
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > 300 && align < 250 )
fight.c:      xp_ratio = ( int )gch->played / gchlev;
fight.c:   if( ch->in_room != victim->in_room )
fight.c:      was_in_room = ch->in_room;
fight.c:      sprintf( bugbuf, "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c:         sprintf( bugbuf, "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:         sprintf( bugbuf, "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:      if( ch->master == victim )
fight.c:         if( ch->master )
fight.c:            xSET_BIT( ch->master->act, PLR_ATTACKER );
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:   if( !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
fight.c:      sprintf( log_buf, "%s: murder %s.", ch->name, victim->name );
fight.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
fight.c:   if( IS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:   if( IS_SET( ch->in_room->area->flags, AFLAG_FREEKILL ) )
fight.c:   if( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c:      if( ( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) || !IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) ||
fight.c:             */ ch->level - victim->level > 10
fight.c:             * || !IS_SET(ch->pcdata->flags, PCFLAG_DEADLY)
fight.c:            sprintf( buf, " (%s)", ch->name );
fight.c:            illegal_pkill->name = ch->name;
fight.c:         if( victim->bounty > 0 && !( ch->level - victim->level ) > 10 )
fight.c:         if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && ch->belig == 0 )
fight.c:            ch->belig = 1;
fight.c:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IMMPROOF );
fight.c:      if( ch->position == POS_FIGHTING
fight.c:          || ch->position == POS_EVASIVE
fight.c:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:         if( ch->mount )
fight.c:            ch->position = POS_MOUNTED;
fight.c:            ch->position = POS_STANDING;
fight.c:   if( ch->move <= 0 )
fight.c:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c:   was_in = ch->in_room;
fight.c:      xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c:      if( ch->mount && ch->mount->fighting )
fight.c:         stop_fighting( ch->mount, TRUE );
fight.c:      if( ( now_in = ch->in_room ) == was_in )
fight.c:      ch->in_room = was_in;
fight.c:      ch->in_room = now_in;
fight.c:         los = ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.0015;
fight.c:         if( ch->level < LEVEL_AVATAR )
fight.c:         if( wf && ch->pcdata->deity )
fight.c:            int level_ratio = URANGE( 1, wf->level / ch->level, LEVEL_AVATAR );
fight.c:            if( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c:            else if( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c:   los = ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.005;
fight.c:   if( ch->level < LEVEL_AVATAR )
fight.c:      if( ch->position == POS_FIGHTING
fight.c:          || ch->position == POS_EVASIVE
fight.c:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:         if( ch->mount )
fight.c:            ch->position = POS_MOUNTED;
fight.c:            ch->position = POS_STANDING;
fight.c:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c:      if( ch->level < 100 )
fight.c:         los = ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.5;
fight.c:     *   if( victim && ch->pcdata->deity )
fight.c:     *      int level_ratio = URANGE( 1, victim->level / ch->level, 50 );
fight.c:     *      if( victim && victim->race == ch->pcdata->deity->npcrace )
fight.c:     *      else if( victim && victim->race == ch->pcdata->deity->npcfoe )
fight.c:         if( !( xIS_SET( ch->act, PLR_COWARD ) ) )
fight.c:            xSET_BIT( ch->act, PLR_COWARD );
fight.c:         if( ch->pcdata->clan && ch->pcdata->clan != NULL )
fight.c:            sprintf( cname, "%s", ch->pcdata->clan_name );
fight.c:         if( ( !ch->pcdata->clan || ( ch->pcdata->clan == NULL ) ) && WIClan )
fight.c:      for( victim = ch->in_room->first_person; victim; victim = victim->next_in_room )
gamble.c:	if( ch->in_room != room )
gamble.c:		sprintf(buf, "%s You can't bet now! Wait till it stops rolling, please.", ch->name );
gamble.c:	if( ch->gold < amount )
gamble.c:			ch->name, 
gamble.c:	ch->gold -= amount;
gamble.c:	bet->player_name	= QUICKLINK( ch->name );
gamble.c:		ch->name, amount, get_bet_name( bet_type), ch->name );
gamble.c:				ch->gold += gain;
gamble.c:	for( ch = room->first_person ; ch ; ch = ch->next_in_room )
gboards.c:   if( !str_cmp( ch->name, note->sender ) )
gboards.c:   if( is_full_name( ch->name, note->to_list ) )
gboards.c:   if( !ch->desc )
gboards.c:   if( ch->substate == SUB_RESTRICTED )
gboards.c:      bug( "NOT GOOD: start_editing_note: ch->substate == SUB_RESTRICTED", 0 );
gboards.c:   if( ch->editor )
gboards.c:   ch->editor = edit;
gboards.c:   ch->desc->connected = CON_NOTE_TEXT;
gboards.c:   if( !ch->editor )
gboards.c:   for( x = 0; x < ch->editor->numlines; x++ )
gboards.c:      strcpy( tmp, ch->editor->line[x] );
gboards.c:   last_read = ch->pcdata->last_note[board_number( board )];
gboards.c:   if( get_trust( ch ) < ch->pcdata->board->write_level )
gboards.c:   if( ch->pcdata->in_progress && ( !ch->pcdata->in_progress->text ) )
gboards.c:      free_global_note( ch->pcdata->in_progress );
gboards.c:      ch->pcdata->in_progress = NULL;
gboards.c:   if( !ch->pcdata->in_progress )
gboards.c:      ch->pcdata->in_progress = new_note(  );
gboards.c:      ch->pcdata->in_progress->sender = STRALLOC( ch->name );
gboards.c:      ch->pcdata->in_progress->date = str_dup( strtime );
gboards.c:            ch->pcdata->in_progress->text ? "continuing" : "posting", ch->pcdata->board->short_name );
gboards.c:   sprintf( buf, "&YFrom&w:    %s\r\n\r\n", ch->name );
gboards.c:   if( !ch->pcdata->in_progress->text )   /* Are we continuing an old note or not? */
gboards.c:      switch ( ch->pcdata->board->force_type )
gboards.c:                     ch->pcdata->board->names );
gboards.c:                     ch->pcdata->board->names );
gboards.c:            sprintf( buf, "The recipient of this note must NOT include: \"&W%s&w\".", ch->pcdata->board->names );
gboards.c:      ch->desc->connected = CON_NOTE_TO;
gboards.c:               ch->pcdata->in_progress->to_list,
gboards.c:               ctime( &ch->pcdata->in_progress->expire ), ch->pcdata->in_progress->subject );
gboards.c:      send_to_char_color( ch->pcdata->in_progress->text, ch );
gboards.c:      ch->substate = SUB_GBOARD_NOTE;
gboards.c:      ch->dest_buf = ch->pcdata;
gboards.c:      ch->pcdata->in_progress->text = str_dup( "" );
gboards.c:      start_editing_note( ch, ch->pcdata->in_progress->text );
gboards.c:      ch->desc->connected = CON_NOTE_TEXT;
gboards.c:   time_t *last_note = &ch->pcdata->last_note[board_number( ch->pcdata->board )];
gboards.c:      for( p = ch->pcdata->board->note_first; p; p = p->next )
gboards.c:      for( p = ch->pcdata->board->note_first; p; p = p->next, count++ )
gboards.c:         sprintf( buf, "Changed to next board, %s.\r\n", ch->pcdata->board->short_name );
gboards.c:   p = find_note( ch, ch->pcdata->board, atoi( argument ) );
gboards.c:   if( str_cmp( ch->name, p->sender ) && ( get_trust( ch ) < LEVEL_IMPLEMENTOR ) )
gboards.c:   unlink_note( ch->pcdata->board, p );
gboards.c:   save_board( ch->pcdata->board ); /* save the board */
gboards.c:      for( p = ch->pcdata->board->note_first; p; p = p->next )
gboards.c:   last_note = ch->pcdata->last_note[board_number( ch->pcdata->board )];
gboards.c:   for( p = ch->pcdata->board->note_first; p; p = p->next )
gboards.c:   for( p = ch->pcdata->board->note_first; p && p->next; p = p->next );
gboards.c:      ch->pcdata->last_note[board_number( ch->pcdata->board )] = p->date_stamp;
gboards.c:      if( ch->pcdata->board == NULL )
gboards.c:         ch->pcdata->board = &boards[DEFAULT_BOARD];
gboards.c:      sprintf( buf, "\r\nYou current board is &W%s&w.\r\n", ch->pcdata->board->short_name );
gboards.c:      if( ch->pcdata->board->read_level > get_trust( ch ) )
gboards.c:      else if( ch->pcdata->board->write_level > get_trust( ch ) )
gboards.c:   if( ch->pcdata->in_progress )
gboards.c:         ch->pcdata->board = &boards[i];
gboards.c:   ch->pcdata->board = &boards[i];
gboards.c:   int i = board_number( ch->pcdata->board ) + 1;
gboards.c:      ch->pcdata->board = &boards[0];
gboards.c:      ch->pcdata->board = &boards[i];
gboards.c:   if( !ch->pcdata->in_progress )
gboards.c:   switch ( ch->pcdata->board->force_type )
gboards.c:            ch->pcdata->in_progress->to_list = STRALLOC( ch->pcdata->board->names );
gboards.c:            sprintf( buf, "Assumed default recipient: &W%s&w\r\n", ch->pcdata->board->names );
gboards.c:            ch->pcdata->in_progress->to_list = STRALLOC( buf );
gboards.c:         if( !is_full_name( ch->pcdata->board->names, buf ) )
gboards.c:            strcat( buf, ch->pcdata->board->names );
gboards.c:            ch->pcdata->in_progress->to_list = STRALLOC( buf );
gboards.c:                     "&YNew To&w :  %s&w\r\n", ch->pcdata->board->names, ch->pcdata->in_progress->to_list );
gboards.c:            ch->pcdata->in_progress->to_list = STRALLOC( buf );
gboards.c:         if( is_full_name( ch->pcdata->board->names, buf ) )
gboards.c:                     "&YTo&w:      ", ch->pcdata->board->names );
gboards.c:            ch->pcdata->in_progress->to_list = STRALLOC( buf );
gboards.c:   if( !ch->pcdata->in_progress )
gboards.c:      ch->pcdata->in_progress->subject = str_dup( buf );
gboards.c:                  "&YExpire&w:  ", ch->pcdata->board->purge_days );
gboards.c:         ch->pcdata->in_progress->expire = current_time + ch->pcdata->board->purge_days * 24L * 3600L;
gboards.c:         sprintf( buf, "This note will expire %s\r", ctime( &ch->pcdata->in_progress->expire ) );
gboards.c:         ch->substate = SUB_GBOARD_NOTE;
gboards.c:         ch->dest_buf = ch->pcdata;
gboards.c:         ch->pcdata->in_progress->text = str_dup( "" );
gboards.c:         start_editing_note( ch, ch->pcdata->in_progress->text );
gboards.c:   if( !ch->pcdata->in_progress )
gboards.c:      days = ch->pcdata->board->purge_days;
gboards.c:   ch->pcdata->in_progress->expire = expire;
gboards.c:   ch->substate = SUB_GBOARD_NOTE;
gboards.c:   ch->dest_buf = ch->pcdata;
gboards.c:   ch->pcdata->in_progress->text = str_dup( "" );
gboards.c:   start_editing_note( ch, ch->pcdata->in_progress->text );
gboards.c:   if( ( d = ch->desc ) == NULL )
gboards.c:   if( !ch->editor )
gboards.c:   edit = ch->editor;
gboards.c:   if( ch->substate == SUB_MPROG_EDIT || ch->substate == SUB_HELP_EDIT )
gboards.c:         free_global_note( ch->pcdata->in_progress );
gboards.c:         ch->pcdata->in_progress = NULL;
gboards.c:         int substate = ch->substate;
gboards.c:         last_cmd = ch->last_cmd;
gboards.c:         ch->substate = SUB_RESTRICTED;
gboards.c:         ch->substate = substate;
gboards.c:         ch->last_cmd = last_cmd;
gboards.c:         NOTE_DATA *note = ch->pcdata->in_progress;
gboards.c:            free_global_note( ch->pcdata->in_progress );
gboards.c:            ch->pcdata->in_progress = NULL;
gboards.c:      NOTE_DATA *note = ch->pcdata->in_progress;
gboards.c:   if( !ch->pcdata->in_progress )
gboards.c:         ch->substate = SUB_GBOARD_NOTE;
gboards.c:         ch->dest_buf = ch->pcdata;
gboards.c:         ch->pcdata->in_progress->text = str_dup( "" );
gboards.c:         start_editing_note( ch, ch->pcdata->in_progress->text );
gboards.c:         if( ch->pcdata->in_progress->text )
gboards.c:            send_to_char_color( ch->pcdata->in_progress->text, ch );
gboards.c:         finish_note( ch->pcdata->board, ch->pcdata->in_progress );
gboards.c:         ch->pcdata->in_progress = NULL;
gboards.c:         free_global_note( ch->pcdata->in_progress );
gboards.c:         ch->pcdata->in_progress = NULL;
grub.c:            if( d->snoop_by == ch->desc )
grub.c:      victim->desc->snoop_by = ch->desc;
grub.c:                 "name=%s affected_by=%d perm_str=%d mod_str=%d\r\n", ch->name, ch->affected_by, ch->perm_str, ch->mod_str );
grub.c:      for( pa = ch->first_affect; pa; pa = pa->next )
handler.c:   return ch->exp;
handler.c:   exp = ch->level * ch->level * ch->level * 5;
handler.c:   exp += ch->max_hit;
handler.c:   exp -= ( ch->armor - 50 ) * 2;
handler.c:   exp += ( ch->barenumdie * ch->baresizedie + get_damroll( ch, FALSE ) ) * 50;
handler.c:   exp += get_hitroll( ch, FALSE ) * ch->level * 10;
handler.c:   return class_table[ch->class]->exp_base;
handler.c:   if(  /*!IS_NPC(ch) && */ ch->desc != NULL && ch->desc->original != NULL )
handler.c:      ch = ch->desc->original;
handler.c:   if( ch->trust != 0 )
handler.c:      return ch->trust;
handler.c:   if( IS_NPC( ch ) && ch->level >= LEVEL_AVATAR )
handler.c:   if( ch->level >= LEVEL_NEOPHYTE && IS_RETIRED( ch ) )
handler.c:   if( ch->level2 != -1 && ch->level2 > ch->level )
handler.c:      return ch->level2;
handler.c:   if( ch->level3 != -1 && ch->level3 > ( ch->level && ch->level2 ) )
handler.c:      return ch->level3;
handler.c:   return ch->level;
handler.c:   return ( ( race_table[ch->race]->base_age ) + 17 + ( ch->played + ( current_time - ch->logon ) ) / 7200 );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_STR )
handler.c:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_INT )
handler.c:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_WIS )
handler.c:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_DEX )
handler.c:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_CON )
handler.c:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_CHA )
handler.c:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->class]->attr_prime == APPLY_LCK )
handler.c:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PET ) )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:      return ch->level * 200;
handler.c:   return URANGE( 5, ( ch->level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PET ) )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:   else if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c:         ch->pcdata->learned[sn] += mod;
handler.c:         ch->pcdata->learned[sn] = URANGE( 0, ch->pcdata->learned[sn] + mod, GET_ADEPT( ch, sn ) );
handler.c:      bug( "affect modify on %s", ch->name );
handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:            xSET_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:         xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:            xREMOVE_BIT( ch->affected_by, mod );
handler.c:            REMOVE_BIT( ch->resistant, mod );
handler.c:            REMOVE_BIT( ch->immune, mod );
handler.c:            REMOVE_BIT( ch->susceptible, mod );
handler.c:            SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         ch->mod_str += mod;
handler.c:         ch->mod_dex += mod;
handler.c:         ch->mod_int += mod;
handler.c:         ch->mod_wis += mod;
handler.c:         ch->mod_con += mod;
handler.c:         ch->mod_cha += mod;
handler.c:         ch->mod_lck += mod;
handler.c:         ch->sex = ( ch->sex + mod ) % 3;
handler.c:         if( ch->sex < 0 )
handler.c:            ch->sex += 2;
handler.c:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:         ch->height += mod;
handler.c:         ch->weight += mod;
handler.c:         ch->max_mana += mod;
handler.c:         ch->max_hit += mod;
handler.c:         ch->max_move += mod;
handler.c:         ch->armor += mod;
handler.c:         ch->hitroll += mod;
handler.c:         ch->damroll += mod;
handler.c:         ch->saving_poison_death += mod;
handler.c:         ch->saving_wand += mod;
handler.c:         ch->saving_para_petri += mod;
handler.c:         ch->saving_breath += mod;
handler.c:         ch->saving_spell_staff += mod;
handler.c:         SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         xSET_BIT( ch->affected_by, mod );
handler.c:         SET_BIT( ch->resistant, mod );
handler.c:         SET_BIT( ch->immune, mod );
handler.c:         SET_BIT( ch->susceptible, mod );
handler.c:         REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:               ch->pcdata->condition[COND_FULL] = 40;
handler.c:               ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:               ch->pcdata->condition[COND_THIRST] = 40;
handler.c:               ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c:               URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level + 10 );
handler.c:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_WEARSPELL && !fAdd ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_REMOVESPELL && !fAdd ) || saving_char == ch /* so save/quit doesn't trigger */
handler.c:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->level, ch, ch ) ) == rCHAR_DIED || char_died( ch ) )
handler.c:      bug( "Affect_to_char(%s, NULL)", ch->name );
handler.c:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:   if( !ch->first_affect )
handler.c:      bug( "Affect_remove(%s, %d): no affect.", ch->name, paf ? paf->type : 0 );
handler.c:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
handler.c:         SET_BIT( ch->resistant, paf->modifier );
handler.c:         SET_BIT( ch->immune, paf->modifier );
handler.c:         SET_BIT( ch->susceptible, paf->modifier );
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   ch->resistant = 0;
handler.c:   ch->immune = 0;
handler.c:   ch->susceptible = 0;
handler.c:   xCLEAR_BITS( ch->no_affected_by );
handler.c:   ch->no_resistant = 0;
handler.c:   ch->no_immune = 0;
handler.c:   ch->no_susceptible = 0;
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   SET_BIT( ch->resistant, race_table[ch->race]->resist );
handler.c:   SET_BIT( ch->susceptible, race_table[ch->race]->suscept );
handler.c:   if( ch->pcdata->deity )
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
handler.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
handler.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
handler.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
handler.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:   if( ch->in_room ) /* non-existant char booboo-fix --TRI */
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   if( ch->morph )
handler.c:      xSET_BITS( ch->affected_by, ch->morph->affected_by );
handler.c:      SET_BIT( ch->immune, ch->morph->immune );
handler.c:      SET_BIT( ch->resistant, ch->morph->resistant );
handler.c:      SET_BIT( ch->susceptible, ch->morph->suscept );
handler.c:      xSET_BITS( ch->no_affected_by, ch->morph->no_affected_by );
handler.c:      SET_BIT( ch->no_immune, ch->morph->no_immune );
handler.c:      SET_BIT( ch->no_resistant, ch->morph->no_resistant );
handler.c:      SET_BIT( ch->no_susceptible, ch->morph->no_suscept );
handler.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
handler.c:   if( !ch->in_room )
handler.c:      --ch->in_room->area->nplayer;
handler.c:       && obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   ch->in_room->area->ttl = 18;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:      room_affect( ch->in_room, paf, FALSE );
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c://    CHECK_LINKS( ch->in_room->first_person, ch->in_room->last_person,
handler.c:   ch->was_in_room = ch->in_room;
handler.c:   ch->in_room = NULL;
handler.c:   ch->next_in_room = NULL;
handler.c:   ch->prev_in_room = NULL;
handler.c:      bug( "Char_to_room: %s -> NULL room!  Putting char in limbo (%d)", ch->name, ROOM_VNUM_LIMBO );
handler.c:   ch->in_room = pRoomIndex;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   if( !ch->was_in_room )
handler.c:      ch->was_in_room = ch->in_room;
handler.c:      if( !IS_IMMORTAL( ch ) && ( IS_NPC( ch ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c:         return obj_to_room( obj, ch->in_room );
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:      if( !IS_NPC( ch ) || !ch->pIndexData->pShop )
handler.c:         LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:         for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:            LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:      ch->carry_number += onum;
handler.c:      ch->carry_weight += oweight;
handler.c:      ch->carry_weight += oweight;
handler.c:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:   ch->carry_weight -= get_obj_weight( obj );
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      bug( "Equip_char: already equipped %s->%s Room %d.", obj->short_descr, ch->name, ch->in_room->vnum );
handler.c:      obj_to_room( obj, ch->in_room );
handler.c:   ch->armor -= apply_ac( obj, iWear );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:      ch->carry_weight -= get_obj_weight( obj );
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room )
handler.c:      ++ch->in_room->light;
handler.c:   ch->carry_number += get_obj_number( obj );
handler.c:      ch->carry_weight += get_obj_weight( obj );
handler.c:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   if( !ch->in_room )
handler.c:      bug( "Extract_char: %s in NULL room.", ch->name ? ch->name : "???" );
handler.c:      bug( "extract_char: %s already died!", ch->name );
handler.c:      gch_prev = ch->prev;
handler.c:    if ( fPull && !xIS_SET(ch->act, ACT_POLYMORPHED))
handler.c:   if( ch->mount )
handler.c:      xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:      ch->mount = NULL;
handler.c:      ch->position = POS_STANDING;
handler.c:      for( wch = first_char; wch; wch = wch->next )
handler.c:         if( wch->mount == ch )
handler.c:            wch->mount = NULL;
handler.c:            wch->position = POS_STANDING;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:         if( wch->pcdata && wch->pcdata->pet == ch )
handler.c:            wch->pcdata->pet = NULL;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:   xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:   while( ( obj = ch->last_carrying ) != NULL )
handler.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
handler.c:         location = get_room_index( ch->pcdata->clan->recall );
handler.c:         sprintf( buf, "Welcome back to the land of the living, %s", capitalize( ch->name ) );
handler.c:      ch->position = POS_RESTING;
handler.c:      --ch->pIndexData->count;
handler.c:    if ( ch->morph )
handler.c:   if( ch->desc && ch->desc->original )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( wch->reply == ch )
handler.c:         wch->reply = NULL;
handler.c:      if( wch->retell == ch )
handler.c:         wch->retell = NULL;
handler.c:   if( ch->desc )
handler.c:      if( ch->desc->character != ch )
handler.c:         ch->desc->character = NULL;
handler.c:         close_socket( ch->desc, FALSE );
handler.c:         ch->desc = NULL;
handler.c:   for( fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room )
handler.c:      if( fch->on == obj )
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:          && ( nifty_is_name( arg, PERS( wch, ch ) ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:   int ms = ch->mental_state;
handler.c:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c:      if( ch->pcdata->council2 && !str_cmp( ch->pcdata->council2->name, "Newbie Council" ) )
handler.c:   if( get_trust( ch ) < victim->ghost_level && ch->in_room == victim->in_room )
handler.c:   if( ch->level < victim->incog_level && ch->in_room != victim->in_room )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == 3 )
handler.c:   if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == 3 )
handler.c:   if( !ch->in_room || !ch->in_room->first_content )
handler.c:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:   for( x = 0; x < strlen( ch->name ); x++ )
handler.c:      c = ch->name[x] + x;
handler.c:            ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c:            ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c:            ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c:            ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c:            ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c:            ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c:            ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c:            ch->perm_str = UMAX( 9, ch->perm_str - a );
handler.c:            ch->perm_dex = UMAX( 9, ch->perm_dex - a );
handler.c:            ch->perm_wis = UMAX( 9, ch->perm_wis - a );
handler.c:            ch->perm_int = UMAX( 9, ch->perm_int - a );
handler.c:            ch->perm_con = UMAX( 9, ch->perm_con - a );
handler.c:            ch->perm_cha = UMAX( 9, ch->perm_cha - a );
handler.c:            ch->perm_lck = UMAX( 9, ch->perm_lck - a );
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   ch->mental_state = -10;
handler.c:   ch->hit = UMAX( 1, ch->hit );
handler.c:   ch->mana = UMAX( 1, ch->mana );
handler.c:   ch->move = UMAX( 1, ch->move );
handler.c:   ch->armor = 100;
handler.c:   ch->mod_str = 0;
handler.c:   ch->mod_dex = 0;
handler.c:   ch->mod_wis = 0;
handler.c:   ch->mod_int = 0;
handler.c:   ch->mod_con = 0;
handler.c:   ch->mod_cha = 0;
handler.c:   ch->mod_lck = 0;
handler.c:   ch->damroll = 0;
handler.c:   ch->hitroll = 0;
handler.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c:   ch->saving_breath = 0;
handler.c:   ch->saving_wand = 0;
handler.c:   ch->saving_para_petri = 0;
handler.c:   ch->saving_spell_staff = 0;
handler.c:   ch->saving_poison_death = 0;
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   ch->carry_weight = 0;
handler.c:   ch->carry_number = 0;
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:         ch->carry_number += get_obj_number( obj );
handler.c:         ch->carry_weight += get_obj_weight( obj );
handler.c:   cur_room = ch->in_room;
handler.c:   ccd->room = ch->in_room;
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   else if( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c:       || victim->level >= ch->level + 15
handler.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c:   else if( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   ms = 10 - abs( ch->mental_state );
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 2 )
handler.c:      c += .4 * ( ( ch->pcdata->nuisance->flags - 2 ) * ch->pcdata->nuisance->power );
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:      ch->mental_state -= c;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         if( ch->pcdata->killed[x].count < 50 )
handler.c:            ++ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c:   ch->pcdata->killed[0].vnum = vnum;
handler.c:   ch->pcdata->killed[0].count = 1;
handler.c:      ch->pcdata->killed[track].vnum = 0;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         return ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   age = ch->played / 86400;  /* Calculate realtime number of days played */
handler.c:   ch->day = ( number_range( 1, 30 ) - 1 );  /* Assign random day of birth */
handler.c:   ch->month = ( number_range( 1, 12 ) - 1 );   /* Assign random month of birth */
handler.c:   ch->year = time_info.year - age; /* Assign birth year based on calculations above */
handler.c:   ch_days = ( ch->month + 1 ) * 30;
handler.c:   ch_days += ch->day;
handler.c:   age = time_info.year - ch->year;
healer.c:   for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
healer.c:   if( cost > ch->silver )
healer.c:   ch->silver -= cost;
healer.c:      ch->mana += dice( 2, 8 ) + ch->level / 3;
healer.c:      ch->mana += UMIN( ch->level, ch->max_mana - ch->mana );
healer.c:   spell( sn, ch->level, mob, ch );
hiscores.c:   old_pos = get_position( keyword, ch->name );
hiscores.c:   add_hiscore( keyword, ch->name, score );
hiscores.c:   pos = get_position( keyword, ch->name );
hiscores.c:      for( vch = first_char; vch; vch = vch->next )
hiscores.c:         sprintf( buf, "&R[&WINFO&R]&c %s has reached position %d in the table of '%s'", ch->name, pos, table->desc );
hometowns.c:   switch ( ch->substate )
hometowns.c:         ch->substate = ch->tempnum;
hometowns.c:         if( ch->substate == SUB_REPEATCMD )
hometowns.c:            ch->tempnum = SUB_REPEATCMD;
hometowns.c:            ch->tempnum = SUB_NONE;
hometowns.c:         ch->substate = SUB_HTOWN_DESC;
hometowns.c:   switch ( ch->substate )
hometowns.c:         ch->substate = ch->tempnum;
hometowns.c:         if( ch->substate == SUB_REPEATCMD )
hometowns.c:            ch->tempnum = SUB_REPEATCMD;
hometowns.c:            ch->tempnum = SUB_NONE;
hometowns.c:         ch->substate = SUB_NATION_DESC;
hometowns.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
hometowns.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
hometowns.c:   if( ch->pcdata->htown_vnum > -1 )
hometowns.c:         if( hometown_list[i]->vnum == ch->pcdata->htown_vnum )
hometowns.c:            ch->pcdata->hometown = hometown_list[i];
hometowns.c:               ch->pcdata->nation = hometown_list[i]->nation;
hometowns.c:               ch->pcdata->nation_vnum = hometown_list[i]->nation->vnum;
hometowns.c:      if( ch->pcdata->hometown == NULL )
hometowns.c:         sprintf( buf, "update_char_hometown(): (%s) invaild vnum for hometown (%d)", ch->name, ch->pcdata->htown_vnum );
hometowns.c:         ch->pcdata->htown_vnum = -1;
house.c:   switch ( ch->substate )
house.c:         location = ch->dest_buf;
house.c:            bug( "house: sub_room_desc: NULL ch->dest_buf", 0 );
house.c:            location = ch->in_room;
house.c:         ch->substate = ch->tempnum;
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:         if( homedata->vnum[i] == ch->in_room->vnum )
house.c:            location = ch->in_room;
house.c:      ch->tempnum = SUB_NONE;
house.c:      ch->substate = SUB_ROOM_DESC;
house.c:      ch->dest_buf = location;
house.c:      if( ch->pcdata->balance + ch->gold < ADDITIONAL_ROOM_COST )
house.c:      if( ch->gold < ADDITIONAL_ROOM_COST )
house.c:      if( ch->pcdata->balance < ADDITIONAL_ROOM_COST )
house.c:         ch->gold -= ADDITIONAL_ROOM_COST - ch->pcdata->balance;
house.c:         ch->pcdata->balance = 0;
house.c:         ch->pcdata->balance -= ADDITIONAL_ROOM_COST;
house.c:      ch->gold -= ADDITIONAL_ROOM_COST;
house.c:   if( !ch->desc )
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
house.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
house.c:   switch ( ch->position )
house.c:   sprintf( buf, "%s disappears to their private sanctuary.", ch->name );
house.c:            ch->name );
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:      if( ch->pcdata->balance + ch->gold < tmpacc->price )
house.c:      if( ch->gold < tmpacc->price )
house.c:         if( ch->in_room->vnum == homedata->vnum[i] )
house.c:            location = ch->in_room;
house.c:      if( ch->pcdata->balance < tmpacc->price )
house.c:         ch->gold -= tmpacc->price - ch->pcdata->balance;
house.c:         ch->pcdata->balance = 0;
house.c:         ch->pcdata->balance -= tmpacc->price;
house.c:      ch->gold -= ADDITIONAL_ROOM_COST;
house.c:      if( !str_cmp( tmphome->name, ch->name ) && !IS_IMMORTAL( ch ) )
house.c:         sprintf( buf, "%s has decided to sell %s %s.", ch->name, ch->sex == 1 ? "his" : ch->sex == 2 ? "her" :
house.c:         if( !str_cmp( tmphome->name, ch->name ) )
house.c:         if( !str_cmp( checkhome->bidder, ch->name ) )
house.c:      if( !str_cmp( tmpres->seller, ch->name ) )
house.c:      if( ch->pcdata->balance + ch->gold < atoi( argument ) )
house.c:      if( ch->gold < atoi( argument ) )
house.c:      tmpres->bidder = STRALLOC( ch->name );
house.c:      if( !str_cmp( tmphome->name, ch->name ) )
house.c:   if( !ch || !ch->name || vnum <= 0 )
house.c:   tmphome->name = STRALLOC( ch->name );
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:   if( !ch || IS_NPC( ch ) || ch->desc != NULL || ch->switched != NULL )
house.c:   if( ch->position == POS_MOUNTED )
house.c:   if( !ch->in_room || ( get_room_index( ch->in_room->vnum ) ) == NULL )
house.c:      ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
house.c:   if( sysdata.save_pets && ch->pcdata && ch->pcdata->pet )
house.c:      extract_char( ch->pcdata->pet, TRUE );
house.c:   if( ch->pcdata && ch->pcdata->clan )
house.c:      save_clan( ch->pcdata->clan );
house.c:      if( !str_cmp( tmpmsg->name, ch->name ) )
house.c:         sprintf( buf, "Error: Unknown Homebuy login msg: %d for %s.", tmpmsg->type, ch->name );
hskelter.c:      if( !str_cmp( hpk->name, ch->name ) )
hskelter.c:      hpk->name = STRALLOC( ch->name );
i3.c:   if( I3ISINVIS( ch ) || i3ignoring( ch, buf ) || !ch->desc )
i3.c:   if( ch->pcdata->email )
i3.c:      if( !IS_SET( ch->pcdata->flags, PCFLAG_PRIVACY ) )
i3.c:         I3_write_buffer( ch->pcdata->email );
i3.c:   if( ch->pcdata->homepage )
i3.c:      I3_write_buffer( I3_escape( ch->pcdata->homepage ) );
i3.c:   if( !ch->desc )
ibuild.c:	ch->pagelen = lines;
ibuild.c:	switch (ch->inter_page) {
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_room_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_control_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = CONTROL_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = CONTROL_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:	ch->inter_editing = NO_PAGE;
ibuild.c:	ch->inter_page = NO_PAGE;
ibuild.c:	sprintf(buf, "\E[%d;%dr", 1, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_E;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_F;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_E;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	switch (ch->inter_page) {
ibuild.c:	if(ch->inter_type== MOB_TYPE)
ibuild.c:	   idx = get_mob_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_mob_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:	if(ch->inter_type== ROOM_TYPE)
ibuild.c:	   ridx = get_room_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_room_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:	if(ch->inter_type== OBJ_TYPE)
ibuild.c:	   oidx = get_obj_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_obj_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:        if(ch->inter_type== CONTROL_TYPE)
ibuild.c:        bug("do_redraw_page: Bad ch->inter_type: vnum %d.", ch->inter_editing_vnum);
ibuild.c:	switch (ch->inter_type) {
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (MOB_INDEX_DATA *) get_mob_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_mob_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (ROOM_INDEX_DATA *) get_room_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_room_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (OBJ_INDEX_DATA *) get_obj_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_obj_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:	if ((ch->inter_substate < 0) || (ch->inter_substate > 5)) {
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	if ((ch->inter_substate < 0) || (ch->inter_substate > 5)) {
ibuild.c:		room_page_c_data[0].data = (ch->inter_substate == SUB_NORTH) ? check : space;
ibuild.c:		room_page_c_data[1].data = (ch->inter_substate == SUB_UP) ? check : space;
ibuild.c:		room_page_c_data[2].data = (ch->inter_substate == SUB_EAST) ? check : space;
ibuild.c:		room_page_c_data[3].data = (ch->inter_substate == SUB_WEST) ? check : space;
ibuild.c:		room_page_c_data[4].data = (ch->inter_substate == SUB_SOUTH) ? check : space;
ibuild.c:		room_page_c_data[5].data = (ch->inter_substate == SUB_DOWN) ? check : space;
ibuild.c:		xit = get_exit(idx, ch->inter_substate);
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ident.c:          (ch ? ch->name : "(unknown)"), a->d->host);
ident.c:  bug(bs, (ch ? ch->name : "(unknown)"), a->d->host); \
ident.c:          user, a->d->host, (ch ? ch->name : "(unknown)"));
ident.c:          (ch ? ch->name : "(unknown)"), a->d->host);
ident.c:  bug(bs, (ch ? ch->name : "(unknown)"), d->host); \
imm_host.c:   for( i = 0; i < strlen( ch->name ); i++ )
imm_host.c:      my_name[i] = LOWER( ch->name[i] );
immscore.c:   pager_printf_color( ch, "\r\n&cImmortal Data: &W%s&c.\r\n", ch->name );
immscore.c:   if( get_trust( ch ) != ch->level )
immscore.c:                          ch->level, capitalize( get_class( ch ) ), ( get_age( ch ) - 17 ) * 2 );
immscore.c:      if( ch->level2 != -1 )
immscore.c:                             ch->level2, capitalize( get_class2( ch ) ) );
immscore.c:      if( ch->level3 != -1 )
immscore.c:                             ch->level3, capitalize( get_class3( ch ) ) );
immscore.c:                          get_age( ch ), capitalize( get_race( ch ) ), ctime( &( ch->logon ) ) );
immscore.c:      pager_printf_color( ch, "&RBamfin : &p%s\r\n", ( ch->pcdata->bamfin[0] != '\0' )
immscore.c:                          ? ch->pcdata->bamfin : "Not changed/Switched." );
immscore.c:      pager_printf( ch, "&RBamfout: &p%s\r\n", ( ch->pcdata->bamfout[0] != '\0' )
immscore.c:                    ? ch->pcdata->bamfout : "Not changed/Switched." );
immscore.c:      if( ch->pcdata->area )
immscore.c:                       ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum, ch->pcdata->area->low_o_vnum,
immscore.c:                       ch->pcdata->area->hi_o_vnum, ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
immscore.c:                       ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "&GYES" : "&RNO" );
immscore.c:                    xIS_SET( ch->act, PLR_HOLYLIGHT ) ? "&GON&c " : "&ROFF&c", xIS_SET( ch->act,
immscore.c:                    "&ROFF&c", ch->pcdata->wizinvis, ch->incog_level > 0 ? "&GON&c " : "&ROFF&c", ch->incog_level,
immscore.c:                    ch->ghost_level > 0 ? "&GON&c " : "&ROFF&c", ch->ghost_level );
immscore.c:      if( ch->incog_level )
immscore.c:         ch->incog_level = 0;
immscore.c:         ch->incog_level = get_trust( ch );
immscore.c:         ch->ghost_level = 0;
immscore.c:         ch->reply = NULL;
immscore.c:         ch->incog_level = level;
immscore.c:         ch->ghost_level = 0;
immscore.c:      if( ch->ghost_level )
immscore.c:         ch->ghost_level = 0;
immscore.c:         ch->ghost_level = get_trust( ch );
immscore.c:         ch->incog_level = 0;
immscore.c:         ch->reply = NULL;
immscore.c:         ch->ghost_level = level;
immscore.c:         ch->incog_level = 0;
inferno.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
inferno.c:	hpch = UMAX( 10, ch->hit );
inferno.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
inferno.c:		vch_next = vch->next_in_room;
inferno.c:		if ( !vch->in_room )
inferno.c:		if ( !IS_NPC( vch ) &&  xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
interp.c:   if( IS_NPC( ch ) && ch->position > 3 ) /*Band-aid alert?  -- Blod */
interp.c:   if( ch->position < position )
interp.c:      switch ( ch->position )
interp.c:            if( !found && ch->desc && get_trust( ch ) < pw->imm_level
interp.c:                     || ( pw->player_site && !str_prefix( pw->player_site, ch->desc->host ) ) ) )
interp.c:                        t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:         if( ( ( pw->target_name && !str_cmp( pw->target_name, ch->name ) )
interp.c:                    && !str_prefix( pw->player_site, ch->desc->host ) ) ) && get_trust( ch ) < pw->imm_level && ch->desc )
interp.c:                     t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:   if( !ch->in_room )
interp.c:   if( ch->substate == SUB_REPEATCMD )
interp.c:      if( ( fun = ch->last_cmd ) == NULL )
interp.c:         ch->substate = SUB_NONE;
interp.c:       * xREMOVE_BIT( ch->affected_by, AFF_HIDE ); 
interp.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_FREEZE ) )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->council
interp.c:                       && is_name( cmd->name, ch->pcdata->council->powers )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->council2
interp.c:                       && is_name( cmd->name, ch->pcdata->council2->powers )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:                       && is_name( cmd->name, ch->pcdata->bestowments ) && cmd->level <= ( trust + sysdata.bestow_dif ) ) ) )
interp.c:      if( xIS_SET( ch->act, PLR_AFK ) && !IS_NPC( ch ) )
interp.c:         xREMOVE_BIT( ch->act, PLR_AFK );
interp.c:         if( ch->pcdata->afkmsg )
interp.c:            STRFREE( ch->pcdata->afkmsg );
interp.c:            ch->pcdata->afkmsg = NULL;
interp.c:    sprintf( lastplayercmd, "** %s: %s", ch->name, logline );
interp.c:               ch->pIndexData->vnum, ch->name, ch->in_room ? ch->in_room->vnum : 0, logline );
interp.c:      sprintf( lastplayercmd, "%s, in room %d, used %s", ch->name, ch->in_room ? ch->in_room->vnum : 0, logline );
interp.c:   if( !IS_NPC( ch ) && ch->desc && valid_watch( logline ) )
interp.c:      else if( IS_SET( ch->pcdata->flags, PCFLAG_WATCH ) )
interp.c:   if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LOG ) )
interp.c:      if( ch->desc && ch->desc->original )
interp.c:         sprintf( log_buf, "Log %s (%s): %s", ch->name, ch->desc->original->name, logline );
interp.c:         sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:      if( fLogAll && loglvl == LOG_NORMAL && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_LOG ) ) )
interp.c:   if( ch->desc && ch->desc->snoop_by )
interp.c:      sprintf( logname, "%s", ch->name );
interp.c:      write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "% ", 2 );
interp.c:      write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "\r\n", 2 );
interp.c:      tempsub = ch->substate;
interp.c:      ch->substate = SUB_TIMER_DO_ABORT;
interp.c:      if( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:         ch->substate = tempsub;
interp.c:         ch->substate = tempsub;
interp.c:               if( !IS_NPC( ch ) && ch->pcdata->outputprefix )
interp.c:                  send_to_char( ch->pcdata->outputprefix, ch );
interp.c:               if( !IS_NPC( ch ) && ch->pcdata->outputsuffix )
interp.c:                  send_to_char( ch->pcdata->outputsuffix, ch );
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->outputprefix )
interp.c:      send_to_char( ch->pcdata->outputprefix, ch );
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 9
interp.c:       && number_percent(  ) < ( ( ch->pcdata->nuisance->flags - 9 ) * 10 * ch->pcdata->nuisance->power ) )
interp.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
interp.c:   ch->last_cmd = cmd->do_fun;
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->outputsuffix )
interp.c:      send_to_char( ch->pcdata->outputsuffix, ch );
interp.c:      sprintf( log_buf, "[*****] LAG: %s: %s %s (R:%d S:%ld.%06ld)", ch->name,
interp.c:               ch->in_room ? ch->in_room->vnum : 0, time_used.tv_sec, time_used.tv_usec );
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->outputprefix )
interp.c:      send_to_char( ch->pcdata->outputprefix, ch );
interp.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:   switch ( ch->position )
interp.c:   for( victim = ch->in_room->first_person; victim; victim = victim->next_in_room )
interp.c:            ch_printf( victim, "You attempt to ignore %s," " but are unable to do so.\r\n", ch->name );
interp.c:      char_to_room( victim, ch->in_room );
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->outputsuffix )
interp.c:      send_to_char( ch->pcdata->outputsuffix, ch );
interp.c:   for( alias = ch->pcdata->first_alias; alias; alias = alias->next )
interp.c:   queue = ch->pcdata->alias_queue;
interp.c:   first = ch->pcdata->alias_queue;
interp.c:         sprintf( buf, "Alias limit reached on character %s!", ch->name );
interp.c:         ch->pcdata->alias_queue = NULL;
interp.c:            WAIT_STATE( ch, sysdata.alias_wait + ch->wait );
interp.c:            WAIT_STATE( ch, 4 + ch->wait );
interp.c:   ch->pcdata->alias_queue = first;
interp.c:   else if( ch->morph != NULL && IS_SET( cmd->flags, CMD_FLAG_POLYMORPHED ) )
interp.c:      if( !ch->pcdata->first_alias )
interp.c:         for( alias = ch->pcdata->first_alias; alias; alias = alias->next, count++ )
interp.c:   for( alias = ch->pcdata->first_alias; alias; alias = alias->next )
interp.c:      LINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
interp.c:      UNLINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
locker.c:   sprintf( strsave, "%s%s", LOCKER_DIR, capitalize( ch->name ) );
locker.c:            bug( ch->name, 0 );
locker.c:            room = generate_virtual_room( ch->in_room );
locker.c:            ch->pcdata->locker_vnum = ch->in_room->vnum;
locker.c:            ch->pcdata->locker_room = room;
locker.c:            bug( ch->name, 0 );
locker.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
locker.c:   if( !ch->pcdata->locker )
locker.c:      bug( ch->name, 0 );
locker.c:   sprintf( strsave, "%s%s", LOCKER_DIR, capitalize( ch->name ) );
locker.c:      fprintf( fp, "Capacity     %d\n", ch->pcdata->locker->capacity );
locker.c:      fprintf( fp, "Flags        %d\n", ch->pcdata->locker->flags );
locker.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
locker.c:      if( ch->pcdata->locker )
locker.c:      if( !IS_SET( ch->in_room->room_flags, ROOM_LOCKER ) )
locker.c:      ch->pcdata->locker = locker;
locker.c:      if( !ch->pcdata->locker )
locker.c:      locker = ch->pcdata->locker;
locker.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
locker.c:      char_to_room( ch, get_room_index( ch->pcdata->locker_vnum ) );
locker.c:   while( ch->pcdata->locker_room->first_content )
locker.c:      extract_obj( ch->pcdata->locker_room->first_content );
locker.c:   DISPOSE( ch->pcdata->locker );
locker.c:   ch->pcdata->locker = NULL;
locker.c:   ch->pcdata->locker_vnum = 0;
locker.c:   ch->pcdata->locker_room = NULL;
locker.c:   if( !IS_SET( ch->in_room->room_flags, ROOM_LOCKER ) )
locker.c:   if( ch->gold >= LOCKER_PRICE )
locker.c:      sprintf( buf, "%s%s", LOCKER_DIR, ch->name );
locker.c:         ch->gold -= LOCKER_PRICE;
locker.c:         do_makelocker( ch, ch->name );
magic.c:         if( IS_SET( ch->immune, RIS_FIRE ) )
magic.c:         if( IS_SET( ch->immune, RIS_COLD ) )
magic.c:         if( IS_SET( ch->immune, RIS_ELECTRICITY ) )
magic.c:         if( IS_SET( ch->immune, RIS_ENERGY ) )
magic.c:         if( IS_SET( ch->immune, RIS_ACID ) )
magic.c:         if( IS_SET( ch->immune, RIS_POISON ) )
magic.c:         if( IS_SET( ch->immune, RIS_DRAIN ) )
magic.c:      if( ch->level2 == -1 )
magic.c:         if( ch->pcdata->learned[sn] > 0
magic.c:             && ch->level >= skill_table[sn]->skill_level[ch->class]
magic.c:      else if( ch->level3 == -1 )
magic.c:         if( ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= ( skill_table[sn]->skill_level[ch->class2]
magic.c:                                 || ch->level >= skill_table[sn]->skill_level[ch->class] )
magic.c:         if( ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= ( skill_table[sn]->skill_level[ch->class3]
magic.c:                                 || ch->level >= ( skill_table[sn]->skill_level[ch->class2]
magic.c:                                                   || ch->level >= skill_table[sn]->skill_level[ch->class] ) )
magic.c:   if( !ch->pcdata )
magic.c:      if( !ch->pcdata->special_skills[sn] || !ch->pcdata->special_skills[sn]->name )
magic.c:      if( LOWER( name[0] ) == LOWER( ch->pcdata->special_skills[sn]->name[0] )
magic.c:          && !str_prefix( name, ch->pcdata->special_skills[sn]->name ) )
magic.c:      if( ch->level2 == -1 )
magic.c:             && ch->pcdata->learned[sn] > 0 && ch->level >= skill_table[sn]->skill_level[ch->class] )
magic.c:      else if( ch->level3 == -1 )
magic.c:             && ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= skill_table[sn]->skill_level[ch->class2]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class] ) )
magic.c:             && ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= skill_table[sn]->skill_level[ch->class3]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class2]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class] ) )
magic.c:      if( ch->level2 == -1 )
magic.c:             && ch->pcdata->learned[sn] > 0 && ch->level >= skill_table[sn]->skill_level[ch->class] )
magic.c:      else if( ch->level3 == -1 )
magic.c:             && ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= skill_table[sn]->skill_level[ch->class2]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class] ) )
magic.c:             && ch->pcdata->learned[sn] > 0
magic.c:             && ( ch->level >= skill_table[sn]->skill_level[ch->class3]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class2]
magic.c:                  || ch->level >= skill_table[sn]->skill_level[ch->class] ) )
magic.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c:         act( AT_MAGIC, is_class( ch, rch->class ) ? buf : buf2, ch, NULL, rch, TO_VICT );
magic.c:   if( IS_SET( ch->immune, ris ) )
magic.c:   if( IS_SET( ch->resistant, ris ) )
magic.c:   if( IS_SET( ch->susceptible, ris ) )
magic.c:            return ch->hit;
magic.c:            return ch->mana;
magic.c:            return ch->move;
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            if( ch->gold >= value )
magic.c:                     ch->gold -= value;
magic.c:            if( ch->hit >= value )
magic.c:                     ch->hit -= value;
magic.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + ch->pcdata->nuisance->power * 6 ) )
magic.c:               if( xIS_SET( ch->act, PLR_NICE ) && ch != *victim )
magic.c:            if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == *victim )
magic.c:         if( !IS_NPC( ch ) && ch->fighting && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + 6 * ch->pcdata->nuisance->power ) )
magic.c:         if( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c:   switch ( ch->substate )
magic.c:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:                     && ( ch->level < skill_table[sn]->skill_level[ch->class]
magic.c:                          && ch->level < skill_table[sn]->skill_level[ch->class2]
magic.c:                          && ch->level < skill_table[sn]->skill_level[ch->class3] ) ) )
magic.c:/*            || ( !IS_NPC(ch) && ch->level < SKILL_CLASS(ch, sn) ) ) */
magic.c:         if( ch->position < skill->minimum_position && !IS_NPC( ch ) )
magic.c:            switch ( ch->position )
magic.c:             && skill->guild != CLASS_NONE && ( !ch->pcdata->clan || skill->guild != ch->pcdata->clan->class ) )
magic.c:          * 100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion 
magic.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
magic.c:         else if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:         ch->alloc_ptr = str_dup( staticbuf );
magic.c:         ch->tempnum = sn;
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         if( IS_VALID_SN( ( sn = ch->tempnum ) ) )
magic.c:             * 100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion 
magic.c:            else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:               ch->mana -= mana / 3;
magic.c:         sn = ch->tempnum;
magic.c:         if( !ch->alloc_ptr || !IS_VALID_SN( sn ) || skill->type != SKILL_SPELL )
magic.c:            bug( "do_cast: ch->alloc_ptr NULL or bad sn (%d)", sn );
magic.c:	   100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion */
magic.c:         strcpy( staticbuf, ch->alloc_ptr );
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         ch->substate = SUB_NONE;
magic.c:            for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:                  ch->mana -= mana / 2;
magic.c:      else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:         ch->mana -= mana / 2;
magic.c:   if( !IS_NPC( ch ) && ( number_percent(  ) + skill->difficulty * 5 ) > ch->pcdata->learned[sn] )
magic.c:            if( ch->fighting )
magic.c:            if( ch->fighting )
magic.c:         ch->mana -= mana / 2;
magic.c:         ch->mana -= mana;
magic.c:         schance = ( IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_cast ) + ( ch->level / 10 ) ) / 1.5 ) );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_cast ) + ( ch->level / 10 * 1.5 ) ) / 2 );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_cast ) + ( ch->level / 10 * 2 ) ) / 2.5 );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_cast ) + ( ch->level / 10 * 2.5 ) ) / 3 );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_sixth_cast ) + ( ch->level / 10 * 3 ) ) / 3.5 );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_seventh_cast ) + ( ch->level / 10 * 3.5 ) ) / 4 );
magic.c:         schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_eighth_cast ) + ( ch->level / 10 * 4 ) ) / 4.5 );
magic.c:            ch->mana -= mana;
magic.c:            retcode = ( *skill->spell_fun ) ( sn, ch->level, ch, vo );
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:   int levdiff = ch->level - level;
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && skill->target == TAR_CHAR_OFFENSIVE )
magic.c:         if( skill->type != SKILL_HERB && IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:   if( ch->in_room->area->weather->precip <= 0 )
magic.c:      vch_next = vch->next;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == ch->in_room )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      if( !ch_died && vch->in_room->area == ch->in_room->area && IS_OUTSIDE( vch ) && IS_AWAKE( vch ) )
magic.c:   sprintf( buf, "%s has charmed %s.", ch->name, victim->name );
magic.c:   log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   weath = ch->in_room->area->weather;
magic.c:   change = number_range( -rand_factor, rand_factor ) + ( ch->level * 3 ) / ( 2 * max_vector );
magic.c:   mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:   weath = ch->in_room->area->weather;
magic.c:   if( ch->alignment < 350 )
magic.c:   if( IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:      if( ch->first_affect )
magic.c:         while( ch->first_affect )
magic.c:            affect_remove( ch, ch->first_affect );
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:      vch_next = vch->next;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == ch->in_room )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      if( !ch_died && vch->in_room->area == ch->in_room->area )
magic.c:      if( obj->level > ch->level )
magic.c:         aenchant += ( obj->level - ch->level );
magic.c:      if( obj->level > ch->level )
magic.c:         aenchant -= ( obj->level - ch->level );
magic.c:      if( obj->level < ch->level )
magic.c:         levdif = ch->level - obj->level;
magic.c:      if( obj->level < ch->level )
magic.c:         levdif = ch->level - obj->level;
magic.c:   ch->alignment = UMAX( -1000, ch->alignment - 200 );
magic.c:      dam = ch->hit + 1;
magic.c:      ch->hit += dam;
magic.c:   if( ch->hit > ch->max_hit )
magic.c:      ch->hit = ch->max_hit;
magic.c:   for( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:      if( !IS_NPC( ich ) && xIS_SET( ich->act, PLR_WIZINVIS ) )
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_HIDE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_INVISIBLE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_SNEAK );
magic.c:   char_to_room( victim = create_mobile( temp ), ch->in_room );
magic.c:	((ch->level > victim->level + 10) 
magic.c:                    name, ( ch->level > victim->level + 10 ) ? victim->name : "someone else" );
magic.c:      if( ( chance( ch, 50 ) && ch->level >= victim->level + 10 ) || IS_IMMORTAL( ch ) )
magic.c:   if( !ch->in_room->first_content )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:      sprintf( log_buf, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
magic.c:      to_channel( log_buf, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:       || !in_hard_range( victim, ch->in_room->area )
magic.c:       || ( IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL ) && IS_PKILL( victim ) )
magic.c:   if( ch->in_room->area != victim->in_room->area )
magic.c:   sprintf( buf, "%s summoned %s to room %d.", ch->name, victim->name, ch->in_room->vnum );
magic.c:   log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:   to_channel( buf, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   char_to_room( victim, ch->in_room );
magic.c:*   sprintf( buf, "%s teleported %s to room %d.", ch->name, victim->name, victim->in_room->vnum );
magic.c:*   log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:*   to_channel( buf, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   pRoomIndex = get_room_index( ch->pcdata->memorize[i] );
magic.c:   sprintf( buf, "%s teleported %s to room %d.", ch->name, ch->name, ch->in_room->vnum );
magic.c:   log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:   to_channel( buf, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:      if( !is_name( speaker, vch->name ) )
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:   if( victim->in_room == ch->in_room )
magic.c:   fromRoom = ch->in_room;
magic.c:   sprintf( buf, "a portal created by %s", ch->name );
magic.c:   portalObj = obj_to_room( portalObj, ch->in_room );
magic.c:             ch->name, fromRoom->vnum, targetRoomVnum );
magic.c:    log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level)  );
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   original = ch->in_room;
magic.c:      else if( chance( ch, 50 - ( ch->level / 2 ) ) )
magic.c:       || ( ch->in_room->sector_type != SECT_FOREST
magic.c:            && ch->in_room->sector_type != SECT_FIELD )
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   WEATHER_DATA *weath = ch->in_room->area->weather;
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:            if( chance( ch, 50 ) && ch->level + 10 < victim->level )
magic.c:            if( chance( ch, 50 ) && ch->level + 15 < victim->level )
magic.c:   for( corpse = ch->in_room->first_content; corpse; corpse = corpse_next )
magic.c:         if( !IS_IMMORTAL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] - ( pMobIndex->level / 3 ) < 0 )
magic.c:      else if( ch->mana - ( pMobIndex->level * 4 ) < 0 )
magic.c:         ch->mana -= ( pMobIndex->level * 4 );
magic.c:   if( IS_IMMORTAL( ch ) || ( chance( ch, 75 ) && pMobIndex->level - ch->level < 10 ) )
magic.c:      char_to_room( mob, ch->in_room );
magic.c:      mob->level = UMIN( ch->level / 2, pMobIndex->level );
magic.c:                                   ( mob->max_hit * corpse->value[3] ) / 100, ch->level * dice( 20, 10 ) ), 1 );
magic.c:      mob->damroll = ch->level / 8;
magic.c:      mob->hitroll = ch->level / 6;
magic.c:      mob->alignment = ch->alignment;
magic.c:   if( ch->desc->original )
magic.c:   af.duration = 20 + ( ch->level - victim->level ) / 2;
magic.c:   ch->desc->character = victim;
magic.c:   ch->desc->original = ch;
magic.c:   victim->desc = ch->desc;
magic.c:   ch->desc = NULL;
magic.c:   ch->switched = victim;
magic.c:   if( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:   if( !( victim = get_char_world( ch, arg ) ) || victim->in_room->area != ch->in_room->area )
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:            if( ( dam > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:               int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:                  vch->hit = URANGE( 0, vch->hit + dam, vch->max_hit );
magic.c:                  if( ( dam > 0 && ch->fighting && ch->fighting->who == vch )
magic.c:                      || ( dam > 0 && vch->fighting && vch->fighting->who == ch ) )
magic.c:                     int xp = ch->fighting ? ch->fighting->xp : vch->fighting->xp;
magic.c:                     int xp_gain = ( int )( xp * dam * 2 ) / vch->max_hit;
magic.c:               if( ( af.modifier > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:                  int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:         victim = ch->in_room->first_person;
magic.c:            WEATHER_DATA *weath = ch->in_room->area->weather;
magic.c:               if( ch->level - obj->level < 10
magic.c:                   ch->level * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 20
magic.c:                   || get_value( obj->gold_cost, obj->silver_cost, obj->copper_cost ) > ch->level * get_curr_int( ch ) / 5 )
magic.c:               if( ch->level - obj->level < 5
magic.c:                   ch->level * 10 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 5
magic.c:                   ch->level * 50 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:      obj_to_room( obj, ch->in_room );
magic.c:   char_to_room( mob, ch->in_room );
magic.c:             ( ch->position == POS_FIGHTING
magic.c:               || ch->position == POS_EVASIVE
magic.c:               || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK ) )
magic.c:   ch->gold += val;
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !vch->in_room )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:   if( ( victim->hit + ( ch->hit / 2 ) ) > victim->max_hit )
magic.c:      ch->hit -= amt;
magic.c:      victim->hit += ch->hit;
magic.c:      ch->hit /= 2;
magic.c:      if( obj->level > ch->level )
magic.c:         aenchant += ( obj->level - ch->level );
magic.c:      if( obj->level > ch->level )
magic.c:         aenchant -= ( obj->level - ch->level );
magic.c:      if( obj->level < ch->level )
magic.c:         levdif = ch->level - obj->level;
magic.c:      if( obj->level < ch->level )
magic.c:         levdif = ch->level - obj->level;
makeobjs.c:      if( ch && ch->in_room )
makeobjs.c:      name = ch->short_descr;
makeobjs.c:      if( ch->gold > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:            sysdata.global_gold_looted += ch->gold / 100;
makeobjs.c:         obj_to_obj( create_money( ch->gold, 0 ), corpse );
makeobjs.c:         ch->gold = 0;
makeobjs.c:      if( ch->silver > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->silver_looted += ch->silver;
makeobjs.c:            sysdata.global_silver_looted += ch->silver / 100;
makeobjs.c:         obj_to_obj( create_money( ch->silver, 1 ), corpse );
makeobjs.c:         ch->silver = 0;
makeobjs.c:      if( ch->copper > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->copper_looted += ch->copper;
makeobjs.c:            sysdata.global_copper_looted += ch->copper / 100;
makeobjs.c:         obj_to_obj( create_money( ch->copper, 2 ), corpse );
makeobjs.c:         ch->copper = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:      corpse->gold_cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      corpse->silver_cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      corpse->copper_cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      name = ch->name;
makeobjs.c:      corpse->value[4] = ch->level;
makeobjs.c:   for( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:   if( IS_NPC( ch ) || ch->level > 10 )
makeobjs.c:      obj_to_room( corpse, ch->in_room );
makeobjs.c:   obj->value[1] = number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj_to_room( obj, ch->in_room );
makeobjs.c:   obj_to_room( obj, ch->in_room );
map.c:   prep_map( ch->in_room, min, max );
mapout.c:	       if(map_index->map_of_vnums[y][x]==ch->in_room->vnum)
mapout.c:		  if ( xIS_SET(ch->act, PLR_ANSI) ){
mapout.c:	bug ("map_stats: ch->pnote==NULL!", 0);
mapout.c:		bug ("do_mapout: sub_writing_map: ch->dest_buf != ch->pnote", 0);
mapout.c:       if ( ch->prev_cmd == do_north )
mapout.c:	   tmp_x = get_exit(ch->in_room, DIR_SOUTH );
mapout.c:       if ( ch->prev_cmd == do_east )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_WEST );
mapout.c:       if ( ch->prev_cmd == do_south )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_NORTH );
mapout.c:       if ( ch->prev_cmd == do_west )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_EAST );
mapout.c:        this_rm = ch->in_room;
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->map->vnum);
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:	ch->in_room->map = map;
mapout.c:        map_index->map_of_vnums[y][x] = ch->in_room->vnum;
mapout.c:        this_rm = ch->in_room;
mapout.c:						  ch->in_room->vnum);
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c: * This function takes the character string in ch->pnote and
mapout.c:	bug ("map_to_rooms: ch->pnote==NULL!", 0);
mapout.c:	for (i=ch->pcdata->r_range_lo;i<=ch->pcdata->r_range_hi;i++) {
mccp.c:   if( !ch->desc )
mccp.c:   if( !ch->desc->out_compress )
mccp.c:      if( !compressStart( ch->desc ) )
mccp.c:      if( !compressEnd( ch->desc ) )
medit.c:    * if ( !IS_NPC( victim ) && str_cmp( ch->name, "Tagith" ) )
medit.c:   d = ch->desc;
medit.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
medit.c:   CHAR_DATA *victim = ch->dest_buf;
medit.c:   switch ( ch->substate )
medit.c:         if( !ch->dest_buf )
medit.c:            bug( "do_medit_reset: sub_mob_desc: NULL ch->dest_buf", 0 );
medit.c:            cleanup_olc( ch->desc );
medit.c:            ch->substate = SUB_NONE;
medit.c:         ch->dest_buf = victim;
medit.c:         ch->substate = SUB_NONE;
medit.c:         ch->desc->connected = CON_MEDIT;
medit.c:         medit_disp_menu( ch->desc );
misc.c:      for( source = ch->in_room->first_content; source; source = src_next )
misc.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
misc.c:               ch->gold += source->value[0];
misc.c:               ch->silver += source->value[0];
misc.c:               ch->copper += source->value[0];
misc.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
misc.c:/*		||   !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )*/  )
misc.c:               if( str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
misc.c:                  for( gch = first_char; gch; gch = gch->next )
misc.c:                     if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
misc.c:                   || ch->carry_number + otmp->count > can_carry_n( ch )
misc.c:                   || ch->carry_weight + get_obj_weight( otmp ) > can_carry_w( ch )
misc.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
misc.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 40 )
misc.c:            amount = ( 10 + ch->level ) - ch->pcdata->condition[COND_BLOODTHIRST];
misc.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
misc.c:               if( ch->pcdata->condition[COND_FULL] >= 48 || ch->pcdata->condition[COND_THIRST] >= 48 )
misc.c:                     if( ch->pcdata->condition[COND_BLOODTHIRST] < ( ch->level + 10 ) )
misc.c:            ch->pcdata->condition[COND_THIRST] = 40;
misc.c:            if( ch->pcdata->condition[COND_DRUNK] > 24 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 18 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 12 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 8 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 5 )
misc.c:            if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:            if( ch->pcdata->condition[COND_THIRST] > 40 )
misc.c:            else if( ch->pcdata->condition[COND_THIRST] > 36 )
misc.c:            else if( ch->pcdata->condition[COND_THIRST] > 30 )
misc.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 47 ) )
misc.c:               ( ch->in_room->sector_type == SECT_UNDERWATER ||
misc.c:                 ch->in_room->sector_type == SECT_WATER_SWIM ||
misc.c:                 ch->in_room->sector_type == SECT_WATER_NOSWIM ) ? "dissolves in the water" :
misc.c:               ( ch->in_room->sector_type == SECT_AIR ||
misc.c:                 IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR ) ) ? "falls far below" : "is trampled underfoot" );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:                  ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:                  ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_FULL] >= 48 || ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
misc.c:       ch->pcdata->nuisance->flags > 3
misc.c:       && ( ch->pcdata->condition[COND_FULL] >= ( 48 - ( 3 * ch->pcdata->nuisance->flags ) +
misc.c:                                                  ch->pcdata->nuisance->power )
misc.c:            || ch->pcdata->condition[COND_THIRST] >= ( 48 - ( ch->pcdata->nuisance->flags ) +
misc.c:                                                       ch->pcdata->nuisance->power ) ) )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 48 ) )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] > 43 )
misc.c:   if( ( scroll->pIndexData->vnum == OBJ_VNUM_SCROLL_SCRIBING ) && ( ch->level + 10 < scroll->value[0] ) )
misc.c:      for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:   if( ch->fighting )
misc.c:      if( ( to_room = pexit->to_room ) != NULL && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:            obj_cast_spell( sn, UMIN( skill->min_level, ch->level ), ch, ch, NULL );
misc.c:            if( IS_SET( ch->in_room->room_flags, ROOM_NODROP ) || ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LITTERBUG ) ) )
misc.c:            if( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) || IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
misc.c:            if( empty_obj( obj, NULL, ch->in_room ) )
misc.c:               save_house_by_vnum( ch->in_room->vnum );  /* House Object Saving */
misc.c:   if( ch->fighting )
misc.c:         iroom = IS_NPC( ch ) ? ch->short_descr : ch->name;
misc.c:   ch->gold = tmpvalue / 10000;
misc.c:   ch->silver = tmpvalue / 100;
misc.c:   ch->copper = tmpvalue;
mobchat.c:   if( !HAS_PROG( ch->pIndexData, SPEECH_PROG ) )
motd.c:   if( ch->level >= 103 )
motd.c:   else if( ch->level >= 101 )
motd.c:   else if( ch->level >= 50 )
motd.c:   else if( ch->level >= 2 )
motd.c:   else if( ch->level == 1 )
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mpxset.c:      if( ch->pcdata->wedto )
mpxset.c:         STRFREE( ch->pcdata->wedto );
mpxset.c:      ch->pcdata->wedto = str_dup( arg3 );
mpxset.c:      sprintf( log_buf, "%s raising glory of %s by %d ...", ch->name, victim->name, value );
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud_comm.c:   if( xIS_EMPTY( ch->in_room->progtypes ) )
mud_comm.c:   pager_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:   if( ch->position == POS_FIGHTING
mud_comm.c:       || ch->position == POS_EVASIVE
mud_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
mud_comm.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   was_in_room = ch->in_room;
mud_comm.c:         ch->in_room = pexit->to_room;
mud_comm.c:   ch->act = actflags;
mud_comm.c:   ch->in_room = was_in_room;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   char_to_room( victim, ch->in_room );
mud_comm.c:      obj_to_room( obj, ch->in_room );
mud_comm.c:      sprintf( arg1, "Mpqpadd:  %d glory added to %s from mob #%d", amount, victim->name, ch->pIndexData->vnum );
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:      while( ch->in_room->first_content )
mud_comm.c:         extract_obj( ch->in_room->first_content );
mud_comm.c:      ch->mobinvis = level;
mud_comm.c:   if( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->level;
mud_comm.c:   if( xIS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c:      xREMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:      xSET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:   in_room = ch->in_room;
mud_comm.c:   if( ch->fighting )
mud_comm.c:      fch_next = fch->next_in_room;
mud_comm.c:      if( fch->mount && fch->mount == ch )
mud_comm.c:      sprintf( arg, "Mpat - Bad Argument - Mobile %d", ch->pIndexData->vnum );
mud_comm.c:      sprintf( arg, "Mpat - No such location: \'%s\' Mobile %d", argument, ch->pIndexData->vnum );
mud_comm.c:   original = ch->in_room;
mud_comm.c:   if( victim->level > ch->level )
mud_comm.c:      location = ch->in_room;
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:             || ch->in_room->area != d->character->in_room->area )
mud_comm.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
mud_comm.c:         vch_next = vch->next_in_room;
mud_comm.c:         sprintf( arg, "Mpforce - Mob #%d in room %d attempting to force link dead immortal", ch->pIndexData->vnum,
mud_comm.c:                  ch->in_room->vnum );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !ch->pcdata->nuisance )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:      vch_next = vch->next;
mud_comm.c:      if( vch->in_room->area == ch->in_room->area && !IS_NPC( vch ) && IS_AWAKE( vch ) )
mud_comm.c:   ch->act = actflags;
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:    * adept = class_table[ch->class]->skill_adept; 
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:            t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->short_descr, argument );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   money = get_value( ch->gold, ch->silver, ch->copper );
mud_comm.c:   if( gold <= money && ch->in_room )
mud_comm.c:      boost_economy( ch->in_room->area, gold );
mud_comm.c:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c:      money = get_value( ch->gold, ch->silver, ch->copper );
mud_comm.c:      lower_economy( ch->in_room->area, gold );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:         if( rch->fighting )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:            sprintf( log_buf, "%s has been killed by %s!", victim->name, ( IS_NPC( ch ) ? ch->short_descr : ch->name ) );
mud_comm.c:                  victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_prog.c:          * Due to remort, we return the persons trust, or ch->level, rather than
mud_prog.c:          * * ch->level OR ch->level2 
mud_prog.c:         for( ch = first_char; ch; ch = ch->next )
mud_prog.c:            if( !IS_NPC( chkchar ) && !IS_NPC( ch ) && ch->desc && chkchar->desc && ch->desc->host == chkchar->desc->host )
mud_prog.c:      for( ch = mob->in_room->first_person; ch; ch = ch->next_in_room )
mud_prog.c:         if( ( !IS_NPC( ch ) ) && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( ch = first_char; ch; ch = ch->next )
mud_prog.c:             && ch->in_room->area == mob->in_room->area
mud_prog.c:             && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:   for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:   sprintf( buf, "mprog_greet_trigger -> %s", ch->name );
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   if( HAS_PROG( ch->in_room, LEAVE_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, ENTER_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SLEEP_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, REST_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RFIGHT_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RDEATH_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SPEECH_PROG ) )
mud_prog.c:      rprog_wordlist_check( txt, supermob, ch, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RAND_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, TIME_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:   if( HAS_PROG( ch->in_room, HOUR_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:         if( mpact->ch->in_room == room )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mudmsg.c:      sprintf( qbuf[i].mtext, "\"%s\" \"%s\" %s", sysdata.mud_name, capitalize( ch->name ), argument );
mudmsg.c:          // || IS_SET(och->deaf, CHANNEL_INTERMUD)
news.c:   switch ( ch->substate )
news.c:         news = ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:         news = ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:      if( !NULLSTR( type->owner ) && ( str_cmp( type->owner, ch->name ) && get_trust( ch ) < LEVEL_IMPLEMENTOR ) )
news.c:      if( !NULLSTR( type->owner ) && ( str_cmp( type->owner, ch->name ) && get_trust( ch ) < LEVEL_IMPLEMENTOR ) )
news.c:      news->name = STRALLOC( ch->name );
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_POST;
news.c:      ch->dest_buf = news;
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_EDIT;
news.c:      ch->dest_buf = news;
news.c:            if( str_cmp( type->org_name, ch->pcdata->clan_name ) )
news.c:            if( str_cmp( type->org_name, class_table[ch->class]->who_name ) )
news.c:            if( str_cmp( type->org_name, ch->pcdata->clan_name ) )
news.c:            if( str_cmp( type->org_name, ch->pcdata->council_name ) )
news.c:   if( type->locked && ( !NULLSTR( type->owner ) && str_cmp( ch->name, type->owner ) ) )
news.c:         if( !str_cmp( type->posters[i], ch->name ) )
oedit.c:   d = ch->desc;
oedit.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
oedit.c:   OBJ_DATA *obj = ch->dest_buf;
oedit.c:   EXTRA_DESCR_DATA *ed = ch->spare_ptr;
oedit.c:   MPROG_DATA *mprg = ch->spare_ptr;
oedit.c:   int mode = OLC_MODE( ch->desc );
oedit.c:   switch ( ch->substate )
oedit.c:         if( !ch->dest_buf )
oedit.c:            bug( "do_oedit_reset: sub_obj_extra: NULL ch->dest_buf", 0 );
oedit.c:            ch->substate = SUB_NONE;
oedit.c:          * OLC_DESC(ch->desc) = ch->spare_ptr; 
oedit.c:         ch->dest_buf = obj;
oedit.c:         ch->spare_ptr = ed;
oedit.c:         ch->substate = SUB_NONE;
oedit.c:         ch->desc->connected = CON_OEDIT;
oedit.c:         OLC_MODE( ch->desc ) = OEDIT_EXTRADESC_CHOICE;
oedit.c:         oedit_disp_extra_choice( ch->desc );
oedit.c:         if( !ch->dest_buf )
oedit.c:            bug( "do_oedit_reset: sub_obj_long: NULL ch->dest_buf", 0 );
oedit.c:            ch->substate = SUB_NONE;
oedit.c:         ch->dest_buf = obj;
oedit.c:         ch->desc->connected = CON_OEDIT;
oedit.c:         ch->substate = SUB_NONE;
oedit.c:         OLC_MODE( ch->desc ) = OEDIT_MAIN_MENU;
oedit.c:         oedit_disp_menu( ch->desc );
oedit.c:         ch->dest_buf = obj;
oedit.c:         ch->desc->connected = ch->tempnum;
oedit.c:         ch->substate = SUB_NONE;
oedit.c:         OLC_MODE( ch->desc ) = mode;
oedit.c:         oedit_disp_prog_choice( ch->desc );
pfiles.c:      snprintf( buf, 512, "Manual pfile cleanup started by %s.", ch->name );
pfiles.c:      snprintf( buf, 512, "Pfile count started by %s.", ch->name );
player.c:      if( ch->pcdata->outputprefix )
player.c:         DISPOSE( ch->pcdata->outputprefix );
player.c:      ch->pcdata->outputprefix = str_dup( argument );
player.c:      if( ch->pcdata->outputsuffix )
player.c:         DISPOSE( ch->pcdata->outputsuffix );
player.c:      ch->pcdata->outputsuffix = str_dup( argument );
player.c:   if( ch->level > 1 /*|| !NOT_AUTHED(ch) */  )
player.c:   if( ch->level2 != -1 )
player.c:   if( ch->level3 != -1 )
player.c:   ch->perm_str = 13;
player.c:   ch->perm_dex = 13;
player.c:   ch->perm_int = 13;
player.c:   ch->perm_wis = 13;
player.c:   ch->perm_cha = 13;
player.c:   ch->perm_con = 13;
player.c:   ch->perm_lck = 13;
player.c:   switch ( class_table[ch->class]->attr_prime )
player.c:         ch->perm_str = 16;
player.c:         ch->perm_int = 16;
player.c:         ch->perm_wis = 16;
player.c:         ch->perm_dex = 16;
player.c:         ch->perm_con = 16;
player.c:         ch->perm_cha = 16;
player.c:         ch->perm_lck = 16;
player.c:   ch->perm_str += race_table[ch->race]->str_plus;
player.c:   ch->perm_int += race_table[ch->race]->int_plus;
player.c:   ch->perm_wis += race_table[ch->race]->wis_plus;
player.c:   ch->perm_dex += race_table[ch->race]->dex_plus;
player.c:   ch->perm_con += race_table[ch->race]->con_plus;
player.c:   ch->perm_cha += race_table[ch->race]->cha_plus;
player.c:   ch->perm_lck += race_table[ch->race]->lck_plus;
player.c:            ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:      ch_printf( ch, "You have %s gold, ", num_punct( ch->pcdata->gbalance ) );
player.c:      ch_printf( ch, "%s silver", num_punct( ch->pcdata->sbalance ) );
player.c:      ch_printf( ch, ", and %s copper coins.\r\n", num_punct( ch->pcdata->balance ) );
player.c:                 ch->gold, ch->silver, ch->copper, ch->pcdata->gbalance, ch->pcdata->sbalance, ch->pcdata->balance );
player.c:   pager_printf( ch, "\r\nWorth for %s%s.\r\n", ch->name, ch->pcdata->title );
player.c:   if( !ch->pcdata->deity )
player.c:   else if( ch->pcdata->favor > 2250 )
player.c:   else if( ch->pcdata->favor > 2000 )
player.c:   else if( ch->pcdata->favor > 1750 )
player.c:   else if( ch->pcdata->favor > 1500 )
player.c:   else if( ch->pcdata->favor > 1250 )
player.c:   else if( ch->pcdata->favor > 1000 )
player.c:   else if( ch->pcdata->favor > 750 )
player.c:   else if( ch->pcdata->favor > 250 )
player.c:   else if( ch->pcdata->favor > -250 )
player.c:   else if( ch->pcdata->favor > -750 )
player.c:   else if( ch->pcdata->favor > -1000 )
player.c:   else if( ch->pcdata->favor > -1250 )
player.c:   else if( ch->pcdata->favor > -1500 )
player.c:   else if( ch->pcdata->favor > -1750 )
player.c:   else if( ch->pcdata->favor > -2000 )
player.c:   else if( ch->pcdata->favor > -2250 )
player.c:   if( ch->level < 10 )
player.c:      if( ch->alignment > 900 )
player.c:      else if( ch->alignment > 700 )
player.c:      else if( ch->alignment > 350 )
player.c:      else if( ch->alignment > 100 )
player.c:      else if( ch->alignment > -100 )
player.c:      else if( ch->alignment > -350 )
player.c:      else if( ch->alignment > -700 )
player.c:      else if( ch->alignment > -900 )
player.c:      sprintf( buf2, "%d", ch->alignment );
player.c:   pager_printf( ch, "|Level: %-4d |Favor: %-10s |Alignment: %-9s |Experience: %-9d|\r\n", ch->level, buf, buf2, ch->exp );
player.c:   switch ( ch->style )
player.c:                 ch->pcdata->quest_curr, ch->gold, ch->silver, ch->copper );
player.c:   pager_printf( ch, "|Bank        |Gold: %-11s", num_punct( ch->pcdata->gbalance ) );
player.c:                 num_punct( ch->pcdata->sbalance ), num_punct( ch->pcdata->balance ) );
player.c:   if( ch->level < 15 && !IS_PKILL( ch ) )
player.c:                    ch->carry_weight, buf );
player.c:                    ch->carry_weight, get_hitroll( ch, FALSE ), get_damroll( ch, FALSE ), buf );
player.c:                 ch->pcdata->extraname ? ch->pcdata->extraname : "",
player.c:                 ch->name, ch->pcdata->lastname ? ch->pcdata->lastname : "", ch->pcdata->title );
player.c:   if( get_trust( ch ) != ch->level && get_trust( ch ) != ch->level2 && get_trust( ch ) != ch->level3 )
player.c:                 ch->level, capitalize( get_race( ch ) ), ( get_age( ch ) - ( race_table[ch->race]->base_age + 17 ) ) * 2 );
player.c:                 get_age( ch ), capitalize( get_class( ch ) ), ctime( &( ch->logon ) ) );
player.c:   if( ch->level >= 15 || IS_PKILL( ch ) )
player.c:                    get_curr_str( ch ), ch->perm_str, get_hitroll( ch, FALSE ),
player.c:                    ch->save_time ? ctime( &( ch->save_time ) ) : "no save this session\n" );
player.c:                    get_curr_int( ch ), ch->perm_int, get_damroll( ch, FALSE ), ctime( &current_time ) );
player.c:                    get_curr_str( ch ), ch->perm_str, ch->save_time ? ctime( &( ch->save_time ) ) : "no\n" );
player.c:                    get_curr_int( ch ), ch->perm_int, ctime( &current_time ) );
player.c:   if( ch->level > 24 )
player.c:                    get_curr_wis( ch ), ch->perm_wis, buf, GET_AC( ch ) );
player.c:      pager_printf( ch, "&CWIS  : &W%2.2d&C(&w%2.2d&C)      Armor: &W%s \r\n", get_curr_wis( ch ), ch->perm_wis, buf );
player.c:   if( ch->alignment > 900 )
player.c:   else if( ch->alignment > 700 )
player.c:   else if( ch->alignment > 350 )
player.c:   else if( ch->alignment > 100 )
player.c:   else if( ch->alignment > -100 )
player.c:   else if( ch->alignment > -350 )
player.c:   else if( ch->alignment > -700 )
player.c:   else if( ch->alignment > -900 )
player.c:   if( ch->level < 10 )
player.c:                    get_curr_dex( ch ), ch->perm_dex, buf, ch->carry_number, can_carry_n( ch ) );
player.c:                    get_curr_dex( ch ), ch->perm_dex, buf, ch->alignment, ch->carry_number, can_carry_n( ch ) );
player.c:   switch ( ch->position )
player.c:                 get_curr_con( ch ), ch->perm_con, buf, ch->carry_weight, can_carry_w( ch ) );
player.c:   pager_printf( ch, "&CCHA  : &W%2.2d&C(&w%2.2d&C)      Wimpy: &R%-5d \r\n", get_curr_cha( ch ), ch->perm_cha, ch->wimpy );
player.c:    * switch (ch->style) {
player.c:   pager_printf( ch, "&CLCK  : &W%2.2d&C(&w%2.2d&C) \r\n", get_curr_lck( ch ), ch->perm_lck );
player.c:                 ch->pcdata->quest_curr, ch->pcdata->quest_accum,
player.c:                 ( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? '*' : ' ' ), ch->pcdata->pagerlen );
player.c:                 ch->practice, ch->hit, ch->max_hit, xIS_SET( ch->act, PLR_AUTOEXIT ) ? '*' : ' ' );
player.c:                    ch->exp, ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level,
player.c:                    xIS_SET( ch->act, PLR_AUTOLOOT ) ? '*' : ' ' );
player.c:                    ch->exp, ch->mana, ch->max_mana, xIS_SET( ch->act, PLR_AUTOLOOT ) ? '*' : ' ' );
player.c:                 ch->move, ch->max_move, ch->pcdata->mdeaths, xIS_SET( ch->act, PLR_AUTOSAC ) ? 'X' : ' ' );
player.c:   pager_printf( ch, "&COn Hand: &YGold: %-12d  ", ch->gold );
player.c:   pager_printf( ch, "&WSilver: %-12d ", ch->silver );
player.c:   pager_printf( ch, "&RCopper: %-12d\r\n", ch->copper );
player.c:   pager_printf( ch, "&CBalance: &YGold: %-12d &WSilver: %-12d &RCopper: %-12d\r\n", ch->pcdata->gbalance,
player.c:                 ch->pcdata->sbalance, ch->pcdata->balance );
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c:   if( ch->position != POS_SLEEPING )
player.c:      switch ( ch->mental_state / 10 )
player.c:   else if( ch->mental_state > 45 )
player.c:   else if( ch->mental_state > 25 )
player.c:   else if( ch->mental_state < -35 )
player.c:   else if( ch->mental_state < -25 )
player.c:      if( knows_language( ch, lang_array[iLang] ) || ( IS_NPC( ch ) && ch->speaks == 0 ) )
player.c:         if( lang_array[iLang] & ch->speaking || ( IS_NPC( ch ) && !ch->speaking ) )
player.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:      pager_printf( ch, "&CYou are bestowed with the command(s): &Y%s&C.\r\n", ch->pcdata->bestowments );
player.c:   if( ch->morph && ch->morph->morph )
player.c:                       ch->morph->morph->vnum, ch->morph->morph->short_desc, ch->morph->timer );
player.c:         pager_printf( ch, "&CYou are morphed into a &W%s&C.\r\n", ch->morph->morph->short_desc );
player.c:   pager_printf( ch, "NonPC DATA:  Mkills (&W%5.5d&C)     Mdeaths (&W%5.5d&C)\r\n", ch->pcdata->mkills,
player.c:                 ch->pcdata->mdeaths );
player.c:                    ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
player.c:   if( ch->pcdata->arena_wins != 0 || ch->pcdata->arena_deaths != 0 || ch->pcdata->arena_kills != 0 )
player.c:                    ch->pcdata->arena_wins, ch->pcdata->arena_kills, ch->pcdata->arena_deaths );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
player.c:                    ch->pcdata->clan->name, ch->pcdata->clan->pkills[5],
player.c:                    ( ch->pcdata->clan->pkills[0] + ch->pcdata->clan->pkills[1] +
player.c:                      ch->pcdata->clan->pkills[2] + ch->pcdata->clan->pkills[3] + ch->pcdata->clan->pkills[4] ) );
player.c:                    ch->pcdata->clan->pdeaths[5],
player.c:                    ( ch->pcdata->clan->pdeaths[0] + ch->pcdata->clan->pdeaths[1] +
player.c:                      ch->pcdata->clan->pdeaths[2] + ch->pcdata->clan->pdeaths[3] + ch->pcdata->clan->pdeaths[4] ) );
player.c:   if( ch->pcdata->deity )
player.c:      if( ch->pcdata->favor > 2250 )
player.c:      else if( ch->pcdata->favor > 2000 )
player.c:      else if( ch->pcdata->favor > 1750 )
player.c:      else if( ch->pcdata->favor > 1500 )
player.c:      else if( ch->pcdata->favor > 1250 )
player.c:      else if( ch->pcdata->favor > 1000 )
player.c:      else if( ch->pcdata->favor > 750 )
player.c:      else if( ch->pcdata->favor > 250 )
player.c:      else if( ch->pcdata->favor > -250 )
player.c:      else if( ch->pcdata->favor > -750 )
player.c:      else if( ch->pcdata->favor > -1000 )
player.c:      else if( ch->pcdata->favor > -1250 )
player.c:      else if( ch->pcdata->favor > -1500 )
player.c:      else if( ch->pcdata->favor > -1750 )
player.c:      else if( ch->pcdata->favor > -2000 )
player.c:      else if( ch->pcdata->favor > -2250 )
player.c:      pager_printf( ch, "&CDeity:  &Y%-20s  &CFavor: &G%s&C\r\n", ch->pcdata->deity->name, buf );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_ORDER )
player.c:                    ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_GUILD )
player.c:                    ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths );
player.c:                    xIS_SET( ch->act, PLR_WIZINVIS ) ? "*" : " ", ch->pcdata->wizinvis );
player.c:        if( ch->pcdata->bamfin[0] == '\0' )
player.c:            pager_printf( ch, "&CBamfin : &YNot changed/Switched.\r\n", ch->name );
player.c:            pager_printf( ch, "&CBamfin : &Y%s\r\n", ch->pcdata->bamfin );
player.c:        if( ch->pcdata->bamfout[0] == '\0' )
player.c:            pager_printf( ch, "&CBamfout: &YNot changed/Switched.\r\n", ch->name );
player.c:            pager_printf( ch, "&CBamfout: &Y%s\r\n", ch->pcdata->bamfout );
player.c:                    ch->pcdata->bamfin[0] != '\0' ? ch->pcdata->bamfin : "Not changed/Switched." );
player.c:                    ch->pcdata->bamfout[0] != '\0' ? ch->pcdata->bamfout : "Not changed/Switched." );
player.c:      if( ch->pcdata->area )
player.c:                       ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum, ch->pcdata->area->low_o_vnum,
player.c:                       ch->pcdata->area->hi_o_vnum, ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
player.c:                       ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "yes" : "no" );
player.c:   if( ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:         if( ch->level < 20 )
player.c:         if( ch->level >= 20 )
player.c:   pager_printf_color( ch, "\r\n&C%s%s.\r\n", ch->name, ch->pcdata->title );
player.c:   if( get_trust( ch ) != ch->level )
player.c:                       ch->level, capitalize( get_race( ch ) ), ( get_age( ch ) - 17 ) * 2 );
player.c:                       get_age( ch ), capitalize( get_class( ch ) ), ctime( &( ch->logon ) ) );
player.c:   if( ch->level >= 15 || IS_PKILL( ch ) )
player.c:                          get_curr_str( ch ), ch->perm_str, get_hitroll( ch, FALSE ),
player.c:                          ch->save_time ? ctime( &( ch->save_time ) ) : "no save this session\n" );
player.c:                          get_curr_int( ch ), ch->perm_int, get_damroll( ch, FALSE ), ctime( &current_time ) );
player.c:                          get_curr_str( ch ), ch->perm_str, ch->save_time ? ctime( &( ch->save_time ) ) : "no\n" );
player.c:                          get_curr_int( ch ), ch->perm_int, ctime( &current_time ) );
player.c:   if( ch->level > 24 )
player.c:                          get_curr_wis( ch ), ch->perm_wis, GET_AC( ch ), buf );
player.c:      pager_printf_color( ch, "&CWIS  : &W%2.2d&C(&w%2.2d&C)      Armor: &W%s \r\n", get_curr_wis( ch ), ch->perm_wis, buf );
player.c:   if( ch->alignment > 900 )
player.c:   else if( ch->alignment > 700 )
player.c:   else if( ch->alignment > 350 )
player.c:   else if( ch->alignment > 100 )
player.c:   else if( ch->alignment > -100 )
player.c:   else if( ch->alignment > -350 )
player.c:   else if( ch->alignment > -700 )
player.c:   else if( ch->alignment > -900 )
player.c:   if( ch->level < 10 )
player.c:                          get_curr_dex( ch ), ch->perm_dex, buf, ch->carry_number, can_carry_n( ch ) );
player.c:                          get_curr_dex( ch ), ch->perm_dex, ch->alignment, buf, ch->carry_number, can_carry_n( ch ) );
player.c:   switch ( ch->position )
player.c:                       get_curr_con( ch ), ch->perm_con, buf, ch->carry_weight, can_carry_w( ch ) );
player.c:                       get_curr_cha( ch ), ch->perm_cha, ch->wimpy );
player.c:   switch ( ch->style )
player.c:                       get_curr_lck( ch ), ch->perm_lck, buf );
player.c:   pager_printf_color( ch, "&CGlory: &W%d&C/&w%d\r\n", ch->pcdata->quest_curr, ch->pcdata->quest_accum );
player.c:                       ch->practice, ch->hit, ch->max_hit, IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? 'X' : ' ',
player.c:                       ch->pcdata->pagerlen, xIS_SET( ch->act, PLR_AUTOEXIT ) ? 'X' : ' ' );
player.c:                          ch->exp, ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->pcdata->mkills,
player.c:                          xIS_SET( ch->act, PLR_AUTOLOOT ) ? 'X' : ' ' );
player.c:   else if( ch->class == CLASS_WARRIOR && ch->level2 == -1 && ch->level3 == -1 )
player.c:                          ch->exp, ch->pcdata->mkills, xIS_SET( ch->act, PLR_AUTOLOOT ) ? 'X' : ' ' );
player.c:                          ch->exp, ch->mana, ch->max_mana, ch->pcdata->mkills, xIS_SET( ch->act,
player.c:                       ch->move, ch->max_move, ch->pcdata->mdeaths, xIS_SET( ch->act, PLR_AUTOSAC ) ? 'X' : ' ' );
player.c:   pager_printf_color( ch, "&CGold: &Y%s ", num_punct( ch->gold ) );
player.c:   pager_printf_color( ch, "&CSilver: &Y%s	", num_punct( ch->silver ) );
player.c:   pager_printf_color( ch, "&CCopper: &Y%s\r\n", num_punct( ch->copper ) );
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c:   if( ch->position != POS_SLEEPING )
player.c:      switch ( ch->mental_state / 10 )
player.c:   else if( ch->mental_state > 45 )
player.c:   else if( ch->mental_state > 25 )
player.c:   else if( ch->mental_state < -35 )
player.c:   else if( ch->mental_state < -25 )
player.c:	||  (IS_NPC(ch) && ch->speaks == 0) )
player.c:	    if ( lang_array[iLang] & ch->speaking
player.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
player.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:      pager_printf_color( ch, "&CYou are bestowed with the command(s): &Y%s\r\n", ch->pcdata->bestowments );
player.c:   if( ch->morph && ch->morph->morph )
player.c:                       ch->morph->morph->vnum, ch->morph->morph->short_desc, ch->morph->timer );
player.c:         pager_printf( ch, "You are morphed into a %s.\r\n", ch->morph->morph->short_desc );
player.c:                          ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
player.c:                          ch->pcdata->clan->name, ch->pcdata->clan->pkills[5],
player.c:                          ( ch->pcdata->clan->pkills[0] + ch->pcdata->clan->pkills[1] +
player.c:                            ch->pcdata->clan->pkills[2] + ch->pcdata->clan->pkills[3] + ch->pcdata->clan->pkills[4] ) );
player.c:                          ch->pcdata->clan->pdeaths[5],
player.c:                          ( ch->pcdata->clan->pdeaths[0] + ch->pcdata->clan->pdeaths[1] +
player.c:                            ch->pcdata->clan->pdeaths[2] + ch->pcdata->clan->pdeaths[3] + ch->pcdata->clan->pdeaths[4] ) );
player.c:   if( ch->pcdata->deity )
player.c:      if( ch->pcdata->favor > 2250 )
player.c:      else if( ch->pcdata->favor > 2000 )
player.c:      else if( ch->pcdata->favor > 1750 )
player.c:      else if( ch->pcdata->favor > 1500 )
player.c:      else if( ch->pcdata->favor > 1250 )
player.c:      else if( ch->pcdata->favor > 1000 )
player.c:      else if( ch->pcdata->favor > 750 )
player.c:      else if( ch->pcdata->favor > 250 )
player.c:      else if( ch->pcdata->favor > -250 )
player.c:      else if( ch->pcdata->favor > -750 )
player.c:      else if( ch->pcdata->favor > -1000 )
player.c:      else if( ch->pcdata->favor > -1250 )
player.c:      else if( ch->pcdata->favor > -1500 )
player.c:      else if( ch->pcdata->favor > -1750 )
player.c:      else if( ch->pcdata->favor > -2000 )
player.c:      else if( ch->pcdata->favor > -2250 )
player.c:      pager_printf_color( ch, "&CDeity:  &W%-20s &CFavor:  &W%s&C\r\n", ch->pcdata->deity->name, buf );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_ORDER )
player.c:                          ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths );
player.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_GUILD )
player.c:                          ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths );
player.c:   if( ch->first_affect && !str_cmp( arg, "affects" ) )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:         if( ch->level < 20 )
player.c:         if( ch->level >= 20 )
player.c:   day = ch->day;
player.c:   sprintf( extrabuf, "%s ", ch->pcdata->extraname );
player.c:   sprintf( buf + strlen( buf ), "%s%s%s\r\n", ( ch->pcdata->extraname[0] != '\0' )
player.c:            ? extrabuf : "", ch->name, ch->pcdata->title );
player.c:            ch->level, get_race( ch ), capitalize( get_class( ch ) ) );
player.c:   if( ch->level2 != -1 )
player.c:               ch->level2, capitalize( get_class2( ch ) ) );
player.c:   if( ch->level3 != -1 )
player.c:               ch->level3, capitalize( get_class3( ch ) ) );
player.c:            get_curr_str( ch ), ch->perm_str, get_curr_int( ch ), ch->perm_int, get_curr_wis( ch ), ch->perm_wis );
player.c:            get_curr_dex( ch ), ch->perm_dex, get_curr_con( ch ), ch->perm_con, get_curr_cha( ch ), ch->perm_cha );
player.c:            get_curr_lck( ch ), ch->perm_lck, ch->practice, ( ( ch->played + ( current_time - ch->logon ) ) / 3600 ) );
player.c:   sprintf( buf + strlen( buf ), "&gExperience&W:&w &B%-11s ", in_comma( ch->exp ) );
player.c:   sprintf( buf + strlen( buf ), "&W(&b%s TNL&W)&w\r\n", in_comma( exp_level( ch, ch->level + 1 ) - ch->exp ) );
player.c:   if( ch->alignment > 900 )
player.c:   else if( ch->alignment > 700 )
player.c:   else if( ch->alignment > 350 )
player.c:   else if( ch->alignment > 100 )
player.c:   else if( ch->alignment > -100 )
player.c:   else if( ch->alignment > -350 )
player.c:   else if( ch->alignment > -700 )
player.c:   else if( ch->alignment > -900 )
player.c:            ch->alignment, extrabuf, GET_AC( ch ) );
player.c:   switch ( ch->position )
player.c:   sprintf( buf + strlen( buf ), "&CGold: &Y%s ", num_punct( ch->gold ) );
player.c:   sprintf( buf + strlen( buf ), "&CSilver: &Y%s	", num_punct( ch->silver ) );
player.c:   sprintf( buf + strlen( buf ), "&CCopper: &Y%s\r\n", num_punct( ch->copper ) );
player.c:            ch->pcdata->gbalance, ch->pcdata->sbalance, ch->pcdata->balance );
player.c:    * sprintf( buf+strlen(buf), "&Y%s&w silver in the bank.\r\n\r\n", in_comma(ch->pcdata->sbalance) );
player.c:    * sprintf( buf+strlen(buf), "&Y%s&w copper in the bank.\r\n\r\n", in_comma(ch->pcdata->balance) );
player.c:   sprintf( buf + strlen( buf ), "&rHitpoints&w: %-8d &rof&w %-8d\r\n", ch->hit, ch->max_hit );
player.c:   sprintf( buf + strlen( buf ), "&b     Mana&w: %-8d &bof&w %-8d\r\n", ch->mana, ch->max_mana );
player.c:   sprintf( buf + strlen( buf ), "&O     Move&w: %-8d &Oof&w %-8d\r\n\r\n", ch->move, ch->max_move );
player.c:      if( ch->pcdata->area )
player.c:                  IS_SET( ch->pcdata->area->status, AREA_LOADED ) ? "is" : "is not" );
player.c:         sprintf( buf + strlen( buf ), "You &c%s&w WizInvis.\r\n", xIS_SET( ch->act, PLR_WIZINVIS ) ? "are" : "are not" );
player.c:         sprintf( buf + strlen( buf ), "Your current WizInvis level is &c%d&w.\r\n", ch->pcdata->wizinvis );
player.c:         if( ch->pcdata->bamfin[0] == '\0' )
player.c:            sprintf( buf + strlen( buf ), "&CBamfin &W:&w %s appears in a swirling mist.\r\n", ch->name );
player.c:            sprintf( buf + strlen( buf ), "&CBamfin &W:&w %s\r\n", ch->pcdata->bamfin );
player.c:         if( ch->pcdata->bamfout[0] == '\0' )
player.c:            sprintf( buf + strlen( buf ), "&CBamfout&W:&w %s appears in a swirling mist.\r\n", ch->name );
player.c:            sprintf( buf + strlen( buf ), "&CBamfout&W:&w %s\r\n", ch->pcdata->bamfout );
player.c:                  ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum, ch->pcdata->area->low_o_vnum,
player.c:                  ch->pcdata->area->hi_o_vnum, ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
player.c:         sprintf( buf + strlen( buf ), "You &c%s&w WizInvis.\r\n", xIS_SET( ch->act, PLR_WIZINVIS ) ? "are" : "are not" );
player.c:         sprintf( buf + strlen( buf ), "Your current WizInvis level is &c%d&w.\r\n", ch->pcdata->wizinvis );
player.c:         if( ch->pcdata->bamfin[0] == '\0' )
player.c:            sprintf( buf + strlen( buf ), "&CBamfin &W:&w %s appears in a swirling mist.\r\n", ch->name );
player.c:            sprintf( buf + strlen( buf ), "&CBamfin &W:&w %s\r\n", ch->pcdata->bamfin );
player.c:         if( ch->pcdata->bamfout[0] == '\0' )
player.c:            sprintf( buf + strlen( buf ), "&CBamfout&W:&w %s appears in a swirling mist.\r\n", ch->name );
player.c:            sprintf( buf + strlen( buf ), "&CBamfout&W:&w %s\r\n", ch->pcdata->bamfout );
player.c:   if( time_info.day == ch->day && time_info.month == ch->month )
player.c:                 day_name[ch->day % 7], day, suf, month_name[ch->month], ch->year );
player.c:   if( ch->class < MAX_NPC_CLASS && ch->class >= 0 )
player.c:      return ( npc_class[ch->class] );
player.c:   if( ch->class2 < MAX_NPC_CLASS && ch->class2 >= 0 )
player.c:      return ( npc_class[ch->class2] );
player.c:   if( ch->class3 < MAX_NPC_CLASS && ch->class3 >= 0 )
player.c:      return ( npc_class[ch->class3] );
player.c:   if( ch->race < MAX_RACE && ch->race >= 0 )
player.c:      return ( race_table[ch->race]->race_name );
player.c:   if( ch->race < MAX_NPC_RACE && ch->race >= 0 )
player.c:      return ( npc_race[ch->race] );
player.c:                 ch->name, IS_NPC( ch ) ? "" : ch->pcdata->title, ch->level, get_age( ch ), ( get_age( ch ) - 17 ) * 2 );
player.c:   if( get_trust( ch ) != ch->level )
player.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) )
player.c:      pager_printf( ch, "You are mobinvis at level %d.\r\n", ch->mobinvis );
player.c:                    ch->hit, ch->max_hit,
player.c:                    ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->practice );
player.c:                    ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->practice );
player.c:                 ch->carry_number, can_carry_n( ch ), ch->carry_weight, can_carry_w( ch ) );
player.c:   pager_printf( ch, "You have scored %s exp, and have ", num_punct( ch->exp ) );
player.c:   pager_printf( ch, "%s gold, ", num_punct( ch->gold ) );
player.c:   pager_printf( ch, "%s silver, and ", num_punct( ch->silver ) );
player.c:   pager_printf( ch, "%s copper coins.\r\n", num_punct( ch->copper ) );
player.c:                    ch->pcdata->quest_accum, ch->pcdata->quest_curr );
player.c:                 ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AUTOEXIT ) ) ? "yes" : "no",
player.c:                 ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AUTOLOOT ) ) ? "yes" : "no",
player.c:                 ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AUTOSAC ) ) ? "yes" : "no",
player.c:                 ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AUTOGOLD ) ) ? "yes" : "no" );
player.c:   pager_printf( ch, "Wimpy set to %d hit points.\r\n", ch->wimpy );
player.c:      if( ch->pcdata->condition[COND_DRUNK] > 10 )
player.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
player.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
player.c:   switch ( ch->mental_state / 10 )
player.c:   switch ( ch->position )
player.c:   if( ch->level >= 25 )
player.c:   if( ch->level >= 15 || IS_PKILL( ch ) )
player.c:   if( ch->level >= 10 )
player.c:      pager_printf( ch, "Alignment: %d.  ", ch->alignment );
player.c:   if( ch->alignment > 900 )
player.c:   else if( ch->alignment > 700 )
player.c:   else if( ch->alignment > 350 )
player.c:   else if( ch->alignment > 100 )
player.c:   else if( ch->alignment > -100 )
player.c:   else if( ch->alignment > -350 )
player.c:   else if( ch->alignment > -700 )
player.c:   else if( ch->alignment > -900 )
player.c:   if( ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:            if( ch->level >= 20 )
player.c:                    ch->pcdata->wizinvis, xIS_SET( ch->act, PLR_WIZINVIS ) ? "ON" : "OFF" );
player.c:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
player.c:         pager_printf( ch, "Room Range: %d - %d\r\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
player.c:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
player.c:         pager_printf( ch, "Obj Range : %d - %d\r\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
player.c:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
player.c:         pager_printf( ch, "Mob Range : %d - %d\r\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
player.c:   if( ch->level == 1 )
player.c:      lowlvl = UMAX( 2, ch->level - 5 );
player.c:   hilvl = URANGE( ch->level, ch->level + 5, MAX_LEVEL );
player.c:   sprintf( buf, " exp  (You have: %14s)", in_comma( ch->exp ) );
player.c:   sprintf( buf2, " exp  (To level: %14s)", in_comma( exp_level( ch, ch->level + 1 ) - ch->exp ) );
player.c:                 ( x == ch->level ) ? buf : ( x == ch->level + 1 ) ? buf2 : " exp" );
player.c:   if( !ch->pcdata->deity )
player.c:   if( ch->pcdata->favor < ch->level * 2 )
player.c:   pager_printf( ch, "%s appears in a vision, revealing that your remains... ", ch->pcdata->deity->name );
player.c:   sprintf( buf, "the corpse of %s", ch->name );
player.c:      ch->pcdata->favor -= ch->level * 2;
player.c:   ch_printf_color( ch, "&C%s\r\n", !xIS_EMPTY( ch->affected_by ) ? affect_bit_name( &ch->affected_by ) : "&cnothing" );
player.c:   if( ch->immune > 0 )
player.c:      ch_printf_color( ch, "&C%s\r\n", flag_string( ch->immune, ris_flags ) );
player.c:   if( ch->resistant > 0 )
player.c:      ch_printf_color( ch, "&C%s\r\n", flag_string( ch->resistant, ris_flags ) );
player.c:   if( ch->susceptible > 0 )
player.c:      ch_printf_color( ch, "&C%s\r\n", flag_string( ch->susceptible, ris_flags ) );
player.c:    * if ( ch->absorb > 0 )
player.c:    * ch_printf_color( ch, "&C%s\r\n", flag_string(ch->absorb, ris_flags) );
player.c:   for( paf = ch->first_affect; paf; paf = paf->next )
player.c:   sprintf( buf, "&R* &zSaves vs Spells: Spell Effects &W- &G%d\r\n", ch->saving_spell_staff );
player.c:   sprintf( buf, "&R* &zSaves vs Spells: Paralysis     &W- &G%d\r\n", ch->saving_para_petri );
player.c:   sprintf( buf, "&R* &zSaves vs Spells: Staves, Wands &W- &G%d\r\n", ch->saving_wand );
player.c:   sprintf( buf, "&R* &zSaves vs Spells: Petrification &W- &G%d\r\n", ch->saving_poison_death );
player.c:   sprintf( buf, "&R* &zSaves vs Spells: Breath Wpns   &W- &G%d\r\n&D", ch->saving_breath );
player.c:   show_list_to_char( ch->first_carrying, ch, TRUE, TRUE );
player.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
player.c:            if( ( !IS_NPC( ch ) ) && ( ch->race > 0 ) && ( ch->race < MAX_RACE ) )
player.c:               send_to_char( race_table[ch->race]->where_name[iWear], ch );
player.c:   STRFREE( ch->pcdata->title );
player.c:   ch->pcdata->title = STRALLOC( buf );
player.c:   STRFREE( ch->pcdata->extraname );
player.c:   ch->pcdata->extraname = STRALLOC( buf );
player.c:   STRFREE( ch->pcdata->lastname );
player.c:   ch->pcdata->lastname = STRALLOC( buf );
player.c:   if( ch->level < 5 )
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( ch->level < 5 )
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( ch->level < 5 )
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( ch->level < 5 )
player.c:      if( !ch->pcdata->homepage )
player.c:         ch->pcdata->homepage = str_dup( "" );
player.c:      ch_printf( ch, "Your homepage is: %s\r\n", show_tilde( ch->pcdata->homepage ) );
player.c:      if( ch->pcdata->homepage )
player.c:         DISPOSE( ch->pcdata->homepage );
player.c:      ch->pcdata->homepage = str_dup( "" );
player.c:   if( ch->pcdata->homepage )
player.c:      DISPOSE( ch->pcdata->homepage );
player.c:   ch->pcdata->homepage = str_dup( buf );
player.c:   if( ch->level < 5 )
player.c:      if( !ch->pcdata->email )
player.c:         ch->pcdata->email = str_dup( "" );
player.c:      ch_printf( ch, "Your email is: %s\r\n", show_tilde( ch->pcdata->email ) );
player.c:      if( ch->pcdata->email )
player.c:         DISPOSE( ch->pcdata->email );
player.c:      ch->pcdata->email = str_dup( "" );
player.c:   if( ch->pcdata->email )
player.c:      DISPOSE( ch->pcdata->email );
player.c:   ch->pcdata->email = str_dup( buf );
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_DESC;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->description );
player.c:         STRFREE( ch->description );
player.c:         ch->description = copy_buffer( ch );
player.c:   if( ch->level < 5 )
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_BIO;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->pcdata->bio );
player.c:         STRFREE( ch->pcdata->bio );
player.c:         ch->pcdata->bio = copy_buffer( ch );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:               ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:               10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:               ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:            ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:   if( IS_NPC( ch ) && ch->fighting )
player.c:                 ch->hit, ch->max_hit,
player.c:                 ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:               ch->hit, ch->max_hit,
player.c:               ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:               ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   if( ch->pcdata->fprompt )
player.c:      STRFREE( ch->pcdata->fprompt );
player.c:      ch->pcdata->fprompt = STRALLOC( "" );
player.c:      ch->pcdata->fprompt = STRALLOC( argument );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   if( ch->pcdata->prompt )
player.c:      STRFREE( ch->pcdata->prompt );
player.c:      ch->pcdata->prompt = STRALLOC( "" );
player.c:      ch->pcdata->prompt = STRALLOC( argument );
player.c:   for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_STR ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_str + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_str++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_INT ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_int + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_int++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_WIS ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_wis + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_wis++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_DEX ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_dex + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_dex++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_CON ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_con + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_con++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_CHA ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_cha + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_cha++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      int max = ( class_table[ch->class]->attr_prime == APPLY_LCK ) ? 25 : 20;
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      if( ch->perm_lck + 1 > max )
player.c:         sprintf( buf, "%s You can't train that anymore!", ch->name );
player.c:      ch->perm_lck++;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      ch->max_hit += 5;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      ch->max_mana += 5;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:      if( ch->practice - 10 < 0 )
player.c:         sprintf( buf, "%s You don't have enough practices.", ch->name );
player.c:      ch->max_move += 5;
player.c:      ch->practice -= 10;
player.c:      sprintf( buf, "%s Enjoy!", ch->name );
player.c:   int gold = ch->gold;
player.c:   //  int mgold = (ch->level * 2000000);
player.c:   //  int mgold = (ch->level * 100000);
player.c:   int tax = ( ch->gold * .05 );
player.c:      ch_printf( ch, "You are level %d and carry more than %d coins.\r\n", ch->level, mgold );
player.c:      ch_printf( ch, "You are being taxed 5%% percent (%d coins) of your %d coins,\r\n", tax, ch->gold );
player.c:      ch_printf( ch, "and that leaves you with %d coins.\r\n\r\n", ( ch->gold - tax ) );
player.c:      ch->gold -= tax;
player.c:      int banktax = ch->pcdata->balance * .05;
player.c:      int balanceamount = ch->pcdata->balance;
player.c:         ch->pcdata->balance = balanceamount;
player.c:   for( undertaker = ch->in_room->first_person; undertaker; undertaker = undertaker->next_in_room )
player.c:      cost = 1 * ch->level;
player.c:   if( cost > ch->gold )
player.c:   strcpy( buf, ch->name );
player.c:      obj_to_room( outer_obj, ch->in_room );
player.c:      ch->gold -= cost;
polymorph.c:   if( ch->level < morph->level )
polymorph.c:   if( morph->sex != -1 && morph->sex != ch->sex )
polymorph.c:   if( morph->class != 0 && !IS_SET( morph->class, ( 1 << ch->class ) ) )
polymorph.c:   if( morph->race != 0 && IS_SET( morph->race, ( 1 << ch->race ) ) )
polymorph.c:   if( morph->deity && ( !ch->pcdata->deity || !get_deity( morph->deity ) ) )
polymorph.c:   if( !ch->desc )
polymorph.c:   switch ( ch->substate )
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_desc: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_help: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:   if( ch->substate == SUB_REPEATCMD )
polymorph.c:      morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = SUB_NONE;
polymorph.c:         ch->dest_buf = NULL;
polymorph.c:         STRFREE( ch->pcdata->subprompt );
polymorph.c:   if( ch->substate != SUB_REPEATCMD && arg1[0] != '\0' && !str_cmp( arg1, "save" ) )
polymorph.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      STRFREE( ch->pcdata->subprompt );
polymorph.c:      ch->pcdata->subprompt = STRALLOC( buf );
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_DESC;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_HELP;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:   else if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_RESTRICTED;
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->last_cmd = do_morphset;
polymorph.c:   if( ch->morph )
polymorph.c:   ch->armor += morph->ac;
polymorph.c:   ch->mod_str += morph->str;
polymorph.c:   ch->mod_int += morph->inte;
polymorph.c:   ch->mod_wis += morph->wis;
polymorph.c:   ch->mod_dex += morph->dex;
polymorph.c:   ch->mod_cha += morph->cha;
polymorph.c:   ch->mod_lck += morph->lck;
polymorph.c:   ch->saving_breath += morph->saving_breath;
polymorph.c:   ch->saving_para_petri += morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death += morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff += morph->saving_spell_staff;
polymorph.c:   ch->saving_wand += morph->saving_wand;
polymorph.c:   ch->hitroll += ch_morph->hitroll;
polymorph.c:   ch->damroll += ch_morph->damroll;
polymorph.c:   if( ( ch->hit + ch_morph->hit ) > 32700 )
polymorph.c:      ch_morph->hit = ( 32700 - ch->hit );
polymorph.c:   ch->hit += ch_morph->hit;
polymorph.c:   if( ( ch->move + ch_morph->move ) > 32700 )
polymorph.c:      ch_morph->move = ( 32700 - ch->move );
polymorph.c:   ch->move += ch_morph->move;
polymorph.c:   if( ( ch->mana + ch_morph->mana ) > 32700 )
polymorph.c:      ch_morph->mana = ( 32700 - ch->mana );
polymorph.c:   ch->mana += ch_morph->mana;
polymorph.c:   xSET_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   SET_BIT( ch->immune, morph->immune );
polymorph.c:   SET_BIT( ch->resistant, morph->resistant );
polymorph.c:   SET_BIT( ch->susceptible, morph->suscept );
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->no_affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->no_immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->no_resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->no_suscept );
polymorph.c:   ch->morph = ch_morph;
polymorph.c:   if( ch->morph )
polymorph.c:      if( ch->hit < morph->hpused )
polymorph.c:         ch->hit -= morph->hpused;
polymorph.c:      if( ch->move < morph->moveused )
polymorph.c:         ch->move -= morph->moveused;
polymorph.c:      if( ch->mana < morph->manaused )
polymorph.c:         ch->mana -= morph->manaused;
polymorph.c:      if( IS_NPC( ch ) || !ch->pcdata->deity || ch->pcdata->favor < morph->favourused )
polymorph.c:         ch->pcdata->favor -= morph->favourused;
polymorph.c:   if( ( morph = ch->morph ) == NULL )
polymorph.c:   ch->armor -= morph->ac;
polymorph.c:   ch->mod_str -= morph->str;
polymorph.c:   ch->mod_int -= morph->inte;
polymorph.c:   ch->mod_wis -= morph->wis;
polymorph.c:   ch->mod_dex -= morph->dex;
polymorph.c:   ch->mod_cha -= morph->cha;
polymorph.c:   ch->mod_lck -= morph->lck;
polymorph.c:   ch->saving_breath -= morph->saving_breath;
polymorph.c:   ch->saving_para_petri -= morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death -= morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff -= morph->saving_spell_staff;
polymorph.c:   ch->saving_wand -= morph->saving_wand;
polymorph.c:   ch->hitroll -= morph->hitroll;
polymorph.c:   ch->damroll -= morph->damroll;
polymorph.c:   ch->hit -= morph->hit;
polymorph.c:   ch->move -= morph->move;
polymorph.c:   ch->mana -= morph->mana;
polymorph.c:   if( ch->mana > ch->max_mana )
polymorph.c:      ch->mana = ch->max_mana;
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->suscept );
polymorph.c:   DISPOSE( ch->morph );
polymorph.c:   if( !ch->morph )
polymorph.c:   temp = ch->morph->morph;
polymorph.c:   if( !ch->morph )
polymorph.c:   for( vch = first_char; vch; vch = vch->next )
polymorph.c:      if( vch->morph == NULL || vch->morph->morph == NULL || vch->morph->morph != morph )
polymorph.c:   if( ch->morph == NULL )
polymorph.c:   morph = ch->morph;
polymorph.c:   ch->morph = morph;
quest.c:      if( xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:         if( ch->questmob == -1 && ch->questgiver->short_descr != NULL )
quest.c:                     ch->questgiver->short_descr );
quest.c:         else if( ch->questobj > 0 )
quest.c:            questinfoobj = get_obj_index( ch->questobj );
quest.c:         else if( ch->questmob > 0 )
quest.c:            questinfo = get_mob_index( ch->questmob );
quest.c:      sprintf( buf, "You have %d quest points.\r\n", ch->pcdata->quest_curr );
quest.c:      if( !xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:         if( ch->nextquest > 175 )
quest.c:            ch->nextquest = 0;
quest.c:         if( ch->nextquest > 1 )
quest.c:            sprintf( buf, "There are %d minutes remaining until you can go on another quest.\r\n", ch->nextquest );
quest.c:         else if( ch->nextquest == 1 )
quest.c:      else if( ch->countdown > 0 )
quest.c:         sprintf( buf, "Time left for current quest: %d\r\n", ch->countdown );
quest.c:   for( questman = ch->in_room->first_person; questman != NULL; questman = questman->next_in_room )
quest.c:   ch->questgiver = questman;
quest.c:      bug( "Error loading quest objects. Char: ", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= QUEST_VALUE1 )
quest.c:            ch->pcdata->quest_curr -= QUEST_VALUE1;
quest.c:            obj = create_object( get_obj_index( QUEST_ITEM1 ), ch->level );
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= QUEST_VALUE2 )
quest.c:            ch->pcdata->quest_curr -= QUEST_VALUE2;
quest.c:            obj = create_object( get_obj_index( QUEST_ITEM2 ), ch->level );
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= QUEST_VALUE3 )
quest.c:            ch->pcdata->quest_curr -= QUEST_VALUE3;
quest.c:            obj = create_object( get_obj_index( QUEST_ITEM3 ), ch->level );
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= QUEST_VALUE4 )
quest.c:            ch->pcdata->quest_curr -= QUEST_VALUE4;
quest.c:            obj = create_object( get_obj_index( QUEST_ITEM4 ), ch->level );
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= QUEST_VALUE5 )
quest.c:            ch->pcdata->quest_curr -= QUEST_VALUE5;
quest.c:            obj = create_object( get_obj_index( QUEST_ITEM5 ), ch->level );
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= 500 )
quest.c:            ch->pcdata->quest_curr -= 500;
quest.c:            ch->practice += 30;
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         if( ch->pcdata->quest_curr >= 500 )
quest.c:            ch->pcdata->quest_curr -= 500;
quest.c:            ch->gold += 100;
quest.c:            sprintf( buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name );
quest.c:         sprintf( buf, "I don't have that item, %s.", ch->name );
quest.c:         if( ch->nextquest > 0 && !( ch->level >= LEVEL_IMMORTAL ) )
quest.c:            sprintf( buf, "You're not on a quest %s.", ch->name );
quest.c:         if( xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:            xREMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:         ch->questgiver = NULL;
quest.c:         ch->countdown = 0;
quest.c:         ch->questmob = 0;
quest.c:         ch->questobj = 0;
quest.c:         if( ch->level >= LEVEL_IMMORTAL )
quest.c:            ch->nextquest = 0;
quest.c:         ch->nextquest = 30;
quest.c:         sprintf( buf, "Very well %s, we can't all be heroes.", ch->name );
quest.c:      if( xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:      if( ch->nextquest > 175 )
quest.c:         ch->nextquest = 0;
quest.c:      if( ch->nextquest > 0 )
quest.c:         sprintf( buf, "You're very brave, %s, but let someone else have a chance.", ch->name );
quest.c:         sprintf( buf, "Please come back in about %d minutes.", ch->nextquest );
quest.c:      sprintf( buf, "Thank you, brave %s!", ch->name );
quest.c:      if( ch->questmob > 0 || ch->questobj > 0 )
quest.c:         ch->countdown = number_range( 10, 30 );
quest.c:         xSET_BIT( ch->act, PLR_QUESTOR );
quest.c:         sprintf( buf, "You have %d minutes to complete this quest.", ch->countdown );
quest.c:      if( ch->questgiver != questman )
quest.c:      if( xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:         if( ch->questmob == -1 && ch->countdown > 0 )
quest.c:               ch->practice += pracreward;
quest.c:            xREMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:            ch->questgiver = NULL;
quest.c:            ch->countdown = 0;
quest.c:            ch->questmob = 0;
quest.c:            ch->questobj = 0;
quest.c:            ch->nextquest = 15;
quest.c:            ch->gold += reward;
quest.c:            ch->pcdata->quest_curr += pointreward;
quest.c:            ch->pcdata->quest_accum += pointreward;
quest.c:         else if( ch->questobj > 0 && ch->countdown > 0 )
quest.c:            for( obj = ch->first_carrying; obj != NULL; obj = obj_next )
quest.c:               if( obj != NULL && obj->pIndexData->vnum == ch->questobj )
quest.c:                  ch->practice += pracreward;
quest.c:               xREMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:               ch->questgiver = NULL;
quest.c:               ch->countdown = 0;
quest.c:               ch->questmob = 0;
quest.c:               ch->questobj = 0;
quest.c:               ch->nextquest = 20;
quest.c:               ch->gold += reward;
quest.c:               ch->pcdata->quest_curr += pointreward;
quest.c:               ch->pcdata->quest_accum += pointreward;
quest.c:         else if( ( ch->questmob > 0 || ch->questobj > 0 ) && ch->countdown > 0 )
quest.c:      if( ch->nextquest > 0 )
quest.c:         sprintf( buf, "You have to REQUEST a quest first, %s.", ch->name );
quest.c:   while( ch->nextquest > 175 && ch->nextquest < 356 )
quest.c:      if( ch->nextquest == 355 )
quest.c:         ch->nextquest = 200;
quest.c:      ch->nextquest++;
quest.c:         level_diff = vsearch->level - ch->level;
quest.c:               || ( ch->level > 30 && ch->level < 40 && vsearch->level > 30 && vsearch->level < 50 )
quest.c:               || ( ch->level > 40 && ch->level < 50 && vsearch->level > 40 && vsearch->level < 60 )
quest.c:               || ( ch->level > 50 && ch->level < 60 && vsearch->level > 50 && vsearch->level < 70 )
quest.c:               || ( ch->level > 60 && ch->level < 70 && vsearch->level > 60 && vsearch->level < 80 )
quest.c:               || ( ch->level > 70 && ch->level < 80 && vsearch->level > 70 && vsearch->level < 90 )
quest.c:               || ( ch->level > 80 && ch->level < 90 && vsearch->level > 80 && vsearch->level < 100 )
quest.c:               || ( ch->level > 90 && vsearch->level > 90 ) )
quest.c:             && vsearch->pShop == NULL
quest.c:             && vsearch->rShop == NULL
quest.c:             && !xIS_SET( vsearch->act, ACT_TRAIN )
quest.c:             && !xIS_SET( vsearch->act, ACT_PRACTICE )
quest.c:             && !xIS_SET( vsearch->act, ACT_IMMORTAL )
quest.c:             && !xIS_SET( vsearch->act, ACT_NOQUEST ) && !xIS_SET( vsearch->act, ACT_PACIFIST ) )
quest.c:   if( vsearch == NULL || ( victim = get_char_world( ch, vsearch->player_name ) ) == NULL || !IS_NPC( victim ) )
quest.c:      if( ( ch->nextquest > 175 && ch->nextquest < 356 ) || ch->nextquest == 0 );
quest.c:         if( ch->nextquest == 0 )
quest.c:            ch->nextquest = 351;
quest.c:      if( ch->nextquest == 400 )
quest.c:         ch->nextquest = 5;
quest.c:      ch->nextquest = 5;
quest.c:      questitem = create_object( get_obj_index( objvnum ), ch->level );
quest.c:      ch->questobj = questitem->pIndexData->vnum;
quest.c:      ch->nextquest = 0;
quest.c:         ch->nextquest = 0;
quest.c:      ch->questmob = victim->pIndexData->vnum;
quest.c:      ch_next = ch->next;
quest.c:      if( ch->nextquest > 0 )
quest.c:         ch->nextquest--;
quest.c:         if( ch->nextquest == 0 )
quest.c:      else if( xIS_SET( ch->act, PLR_QUESTOR ) )
quest.c:         if( --ch->countdown <= 0 )
quest.c:            ch->nextquest = 15;
quest.c:                     ch->nextquest );
quest.c:            xREMOVE_BIT( ch->act, PLR_QUESTOR );
quest.c:            ch->questgiver = NULL;
quest.c:            ch->countdown = 0;
quest.c:            ch->questmob = 0;
quest.c:         if( ch->countdown > 0 && ch->countdown < 6 )
redit.c:   if( IS_NPC( ch ) || !ch->desc )
redit.c:      room = ch->in_room;
redit.c:   d = ch->desc;
redit.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
redit.c:   copy->area = ( ch->pcdata->area ) ? ch->pcdata->area : orig->area;
redit.c:   ROOM_INDEX_DATA *room = ch->dest_buf;
redit.c:   EXTRA_DESCR_DATA *ed = ch->spare_ptr;
redit.c:   switch ( ch->substate )
redit.c:         if( !ch->dest_buf )
redit.c:            bug( "do_redit_reset: sub_obj_extra: NULL ch->dest_buf", 0 );
redit.c:            ch->substate = SUB_NONE;
redit.c:            ch->desc->connected = CON_PLAYING;
redit.c:         ch->dest_buf = room;
redit.c:         ch->desc->connected = CON_REDIT;
redit.c:         ch->substate = SUB_NONE;
redit.c:         olc_log( ch->desc, "Edited room description" );
redit.c:         redit_disp_menu( ch->desc );
redit.c:         ch->dest_buf = room;
redit.c:         ch->spare_ptr = ed;
redit.c:         ch->substate = SUB_NONE;
redit.c:         ch->desc->connected = CON_REDIT;
redit.c:         oedit_disp_extra_choice( ch->desc );
redit.c:         OLC_MODE( ch->desc ) = REDIT_EXTRADESC_CHOICE;
redit.c:         olc_log( ch->desc, "Edit description for exdesc %s", ed->keyword );
remort.c:         if( IS_SET( race_table[ch->race]->class_restriction, 1 << x ) )
remort.c:         if( x != ch->class && x != ch->class2 && str_cmp( class_table[x]->who_name, "Dragon" ) )
remort.c:   if( ch->level < LEVEL_PCAVATAR )
remort.c:   if( ch->level3 != -1 )
remort.c:      if( IS_SET( race_table[ch->race]->class_restriction, 1 << x ) )
remort.c:   if( ch->class == x || ( ch->class2 == x && ch->level2 >= 0 ) )
remort.c:   if( ch->level2 == -1 )
remort.c:      ch->level2 = ch->level;
remort.c:      ch->level = 1;
remort.c:      ch->class2 = ch->class;
remort.c:      ch->class = x;
remort.c:      if( ch->level != 100 && ch->level2 != 100 )
remort.c:      ch->level3 = ch->level2;
remort.c:      ch->level2 = ch->level;
remort.c:      ch->level = 1;
remort.c:      ch->class3 = ch->class2;
remort.c:      ch->class2 = ch->class;
remort.c:      ch->class = x;
remort.c:   ch->max_hit = 20;
remort.c:   ch->hit = ch->max_hit + race_table[ch->race]->hit;
remort.c:   ch->max_mana = 100;
remort.c:   ch->mana = ch->max_mana + race_table[ch->race]->mana;
remort.c:   ch->max_move = 100;
remort.c:   ch->move = ch->max_move;
remort.c:   ch->exp = 0;
remort.c:   DISPOSE( ch->pcdata->rank );
remort.c:   ch->pcdata->rank = str_dup( "" );
remort.c:   ch_printf( ch, "You are now a %s %s.\r\n", race_table[ch->race]->race_name, class_table[x]->who_name );
remort.c:   sprintf( buf, "%s has just remorted!", ch->name );
reset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:      add_reset( pRoom, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   if( !can_rmodify( ch, ch->in_room ) )
reset.c:   if( ch->in_room->area != ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER )
reset.c:   if( ch->in_room->first_reset )
reset.c:      wipe_resets( ch->in_room );
reset.c:   instaroom( ch->in_room, dodoors );
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   pArea = ch->pcdata->area;
reset.c:      reset_area( ch->in_room->area );
reset.c:      for( room = ch->in_room->area->first_room; room; room = room->next_aroom )
reset.c:      for( pReset = ch->in_room->first_reset; pReset; pReset = pReset_next )
reset.c:            UNLINK( pReset, ch->in_room->first_reset, ch->in_room->last_reset, next, prev );
reset.c:      pReset = make_reset( 'R', 0, ch->in_room->vnum, vnum, 0 );
reset.c:      pReset->next = ch->in_room->first_reset;
reset.c:      if( ch->in_room->first_reset->prev )
reset.c:         ch->in_room->first_reset->prev = pReset;
reset.c:      ch->in_room->first_reset = pReset;
reset.c:      if( !ch->in_room->last_reset )
reset.c:         ch->in_room->last_reset = pReset;
reset.c:         vnum = ch->in_room->vnum;
reset.c:         if( !( pReset = find_oreset( ch->in_room, oname ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset->prev )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:      if( !( pReset = find_oreset( ch->in_room, argument ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset->prev )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
save.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:                        ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:	       sprintf( buf, "%s had on %s:  ch->level = %d  obj->level = %d",
save.c:		ch->name, obj->name,
save.c:	       	ch->level, obj->level );
save.c:   if( IS_NPC( ch ) || ( ch->level < 2 && ch->level2 == -1 && ch->level3 == -1 ) )
save.c:   if( ch->desc && ch->desc->original )
save.c:      ch = ch->desc->original;
save.c:   ch->save_time = current_time;
save.c:   sprintf( strsave, "%s%c/%s", PLAYER_DIR, tolower( ch->pcdata->filename[0] ), capitalize( ch->pcdata->filename ) );
save.c:      sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower( ch->pcdata->filename[0] ), capitalize( ch->pcdata->filename ) );
save.c:   if( ch->level >= LEVEL_IMMORTAL )
save.c:      sprintf( strback, "%s%s", GOD_DIR, capitalize( ch->pcdata->filename ) );
save.c:         fprintf( fp, "Level        %d\n", ch->level );
save.c:         fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:   if( ch->level > 103 && ch->level != 110 )
save.c:      sprintf( strback, "%s%s.immlist", GOD_DIR, capitalize( ch->pcdata->filename ) );
save.c:         fprintf( fp, "Name         %s~\n", ch->name );
save.c:         fprintf( fp, "Level        %d\n", ch->level );
save.c:         if( ch->pcdata->lastname && ch->pcdata->lastname[0] != '\0' )
save.c:            fprintf( fp, "Lastname     %s~\n", ch->pcdata->lastname );
save.c:         if( ch->pcdata->email && ch->pcdata->email[0] != '\0' )
save.c:            fprintf( fp, "Email        %s~\n", ch->pcdata->email );
save.c:      if( ch->morph )
save.c:      if( ch->first_carrying )
save.c:         fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY );
save.c:      if( !IS_NPC( ch ) && ch->pcdata->first_alias )
save.c:         fwrite_alias( ch->pcdata->first_alias, fp );
save.c:      if( sysdata.save_pets && ch->pcdata->pet )
save.c:         fwrite_mobile( fp, ch->pcdata->pet );
save.c:      if( ch->comments )   /* comments */
save.c:   fprintf( fp, "Name         %s~\n", ch->name );
save.c:   if( ch->description )
save.c:      fprintf( fp, "Description  %s~\n", ch->description );
save.c:   fprintf( fp, "Sex          %d\n", ch->sex );
save.c:   fprintf( fp, "HairColor    %s~\n", ch->pcdata->hair_color );
save.c:   fprintf( fp, "HairLength   %s~\n", ch->pcdata->hair_length );
save.c:   fprintf( fp, "EyeColor     %s~\n", ch->pcdata->eye_color );
save.c:   fprintf( fp, "SkinTone     %s~\n", ch->pcdata->skin_tone );
save.c:   fprintf( fp, "CHBuild      %s~\n", ch->pcdata->ch_build );
save.c:   fprintf( fp, "CHHeight     %s~\n", ch->pcdata->ch_height );
save.c:   fprintf( fp, "Class        %d\n", ch->class );
save.c:   fprintf( fp, "Class2       %d\n", ch->class2 );
save.c:   fprintf( fp, "Class3       %d\n", ch->class3 );
save.c:   fprintf( fp, "Race         %d\n", ch->race );
save.c:   fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:   fprintf( fp, "Level        %d\n", ch->level );
save.c:   fprintf( fp, "Level2       %d\n", ch->level2 );
save.c:   fprintf( fp, "Level3       %d\n", ch->level3 );
save.c:   fprintf( fp, "Played       %d\n", ch->played + ( int )( current_time - ch->logon ) );
save.c:   fprintf( fp, "Bday            %d\n", ch->day );
save.c:   fprintf( fp, "Bmonth          %d\n", ch->month );
save.c:   fprintf( fp, "Byear           %d\n", ch->year );
save.c:   fprintf( fp, "Agemod          %d\n", ch->age_bonus );
save.c:            ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:              && ch->was_in_room ) ? ch->was_in_room->vnum : ch->in_room->vnum );
save.c:   if( ch->nextquest != 0 )
save.c:      fprintf( fp, "QuestNext %d\n", ch->nextquest );
save.c:   else if( ch->countdown != 0 )
save.c:            ch->pcdata->memorize[0],
save.c:            ch->pcdata->memorize[1],
save.c:            ch->pcdata->memorize[2],
save.c:            ch->pcdata->memorize[3],
save.c:            ch->pcdata->memorize[4], ch->pcdata->memorize[5], ch->pcdata->memorize[6], ch->pcdata->memorize[7] );
save.c:   fprintf( fp, "HpManaMove   %d %d %d %d %d %d\n", ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:   fprintf( fp, "Gold         %d\n", ch->gold );
save.c:   fprintf( fp, "Silver	   %d\n", ch->silver );
save.c:   fprintf( fp, "Copper	   %d\n", ch->copper );
save.c:   fprintf( fp, "Exp          %d\n", ch->exp );
save.c:   fprintf( fp, "Exp2         %d\n", ch->exp2 );
save.c:   fprintf( fp, "Smites       %d\n", ch->pcdata->smites );
save.c:   fprintf( fp, "Smited       %d\n", ch->pcdata->smited );
save.c:   fprintf( fp, "Height          %d\n", ch->height );
save.c:   fprintf( fp, "Weight          %d\n", ch->weight );
save.c:   if( !xIS_EMPTY( ch->act ) )
save.c:      fprintf( fp, "Act          %s\n", print_bitvector( &ch->act ) );
save.c:   if( !xIS_EMPTY( ch->affected_by ) )
save.c:      fprintf( fp, "AffectedBy   %s\n", print_bitvector( &ch->affected_by ) );
save.c:   if( !xIS_EMPTY( ch->no_affected_by ) )
save.c:      fprintf( fp, "NoAffectedBy %s\n", print_bitvector( &ch->no_affected_by ) );
save.c:   pos = ch->position;
save.c:   fprintf( fp, "Style     %d\n", ch->style );
save.c:   fprintf( fp, "Practice     %d\n", ch->practice );
save.c:            ch->saving_poison_death, ch->saving_wand, ch->saving_para_petri, ch->saving_breath, ch->saving_spell_staff );
save.c:   fprintf( fp, "Alignment    %d\n", ch->alignment );
save.c:   fprintf( fp, "Favor	       %d\n", ch->pcdata->favor );
save.c:   fprintf( fp, "Balance      %d\n", ch->pcdata->balance );
save.c:   fprintf( fp, "GBalance     %d\n", ch->pcdata->gbalance );
save.c:   fprintf( fp, "SBalance     %d\n", ch->pcdata->sbalance );
save.c:   fprintf( fp, "Glory        %d\n", ch->pcdata->quest_curr );
save.c:   fprintf( fp, "MGlory       %d\n", ch->pcdata->quest_accum );
save.c:   fprintf( fp, "Hitroll      %d\n", ch->hitroll );
save.c:   fprintf( fp, "Damroll      %d\n", ch->damroll );
save.c:   fprintf( fp, "Armor        %d\n", ch->armor );
save.c:   fprintf( fp, "Bounty       %d\n", ch->bounty );
save.c:   fprintf( fp, "Bowed        %d\n", ch->bowed );
save.c:   fprintf( fp, "Belig        %d\n", ch->belig );
save.c:   fprintf( fp, "Bkills       %d\n", ch->bkills );
save.c:   if( ch->pcdata->wedto )
save.c:      fprintf( fp, "WedTo        %s~\n", ch->pcdata->wedto );
save.c:   if( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n", ch->wimpy );
save.c:   if( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n", ch->deaf );
save.c:   if( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n", ch->resistant );
save.c:   if( ch->no_resistant )
save.c:      fprintf( fp, "NoResistant  %d\n", ch->no_resistant );
save.c:   if( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n", ch->immune );
save.c:   if( ch->no_immune )
save.c:      fprintf( fp, "NoImmune     %d\n", ch->no_immune );
save.c:   if( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n", ch->susceptible );
save.c:   if( ch->no_susceptible )
save.c:      fprintf( fp, "NoSusceptible  %d\n", ch->no_susceptible );
save.c:   if( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n", ch->pcdata->outcast_time );
save.c:   if( ch->pcdata && ch->pcdata->nuisance )
save.c:      fprintf( fp, "NuisanceNew %ld %ld %d %d\n", ch->pcdata->nuisance->time,
save.c:               ch->pcdata->nuisance->max_time, ch->pcdata->nuisance->flags, ch->pcdata->nuisance->power );
save.c:   if( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n", ch->mental_state );
save.c:   fprintf( fp, "Password     %s~\n", ch->pcdata->pwd );
save.c:   if( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c:      fprintf( fp, "Rank         %s~\n", ch->pcdata->rank );
save.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:      fprintf( fp, "Bestowments  %s~\n", ch->pcdata->bestowments );
save.c:   fprintf( fp, "Title        %s~\n", ch->pcdata->title );
save.c:   if( ch->pcdata->extraname && ch->pcdata->extraname[0] != '\0' )
save.c:      fprintf( fp, "Extraname %s~\n", ch->pcdata->extraname );
save.c:   if( ch->pcdata->lastname && ch->pcdata->lastname[0] != '\0' )
save.c:      fprintf( fp, "Lastname %s~\n", ch->pcdata->lastname );
save.c:   if( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:      fprintf( fp, "Homepage     %s~\n", ch->pcdata->homepage );
save.c:   if( ch->pcdata->email && ch->pcdata->email[0] != '\0' )
save.c:      fprintf( fp, "Email     %s~\n", ch->pcdata->email );
save.c:   if( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:      fprintf( fp, "Bio          %s~\n", ch->pcdata->bio );
save.c:   if( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:      fprintf( fp, "AuthedBy     %s~\n", ch->pcdata->authed_by );
save.c:   if( ch->pcdata->min_snoop )
save.c:      fprintf( fp, "Minsnoop     %d\n", ch->pcdata->min_snoop );
save.c:   if( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:      fprintf( fp, "Prompt       %s~\n", ch->pcdata->prompt );
save.c:   if( ch->pcdata->fprompt && *ch->pcdata->fprompt )
save.c:      fprintf( fp, "FPrompt	     %s~\n", ch->pcdata->fprompt );
save.c:   if( ch->pcdata->pagerlen != 24 )
save.c:      fprintf( fp, "Pagerlen     %d\n", ch->pcdata->pagerlen );
save.c:      fprintf( fp, "%s %ld ", boards[i].short_name, ch->pcdata->last_note[i] );
save.c:      if( !ch->pcdata->alias[pos] || !ch->pcdata->alias_sub[pos] )
save.c:      fprintf( fp, "Alias %s %s~\n", ch->pcdata->alias[pos], ch->pcdata->alias_sub[pos] );
save.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
save.c:      if( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:         fprintf( fp, "Bamfin       %s~\n", ch->pcdata->bamfin );
save.c:      if( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:         fprintf( fp, "Bamfout      %s~\n", ch->pcdata->bamfout );
save.c:      if( ch->trust )
save.c:         fprintf( fp, "Trust        %d\n", ch->trust );
save.c:      if( ch->pcdata && ch->pcdata->restore_time )
save.c:         fprintf( fp, "Restore_time %ld\n", ch->pcdata->restore_time );
save.c:      fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:      fprintf( fp, "GhostLevel   %d\n", ch->ghost_level );
save.c:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:         fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:         fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:         fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:   if( ch->pcdata->council )
save.c:      fprintf( fp, "Council      %s~\n", ch->pcdata->council_name );
save.c:   if( ch->pcdata->council2 )
save.c:      fprintf( fp, "Council2     %s~\n", ch->pcdata->council2_name );
save.c:   if( ch->pcdata->deity_name && ch->pcdata->deity_name[0] != '\0' )
save.c:      if( ch->pcdata->hometown && ( ch->pcdata->htown_vnum > -1 ) )
save.c:         fprintf( fp, "Hometown        %d\n", ch->pcdata->htown_vnum );
save.c:   if( ch->pcdata->nation && ( ch->pcdata->nation_vnum > -1 ) )
save.c:      fprintf( fp, "Nation          %d\n", ch->pcdata->nation_vnum );
save.c:   fprintf( fp, "Deity	     %s~\n", ch->pcdata->deity_name );
save.c:   if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:      fprintf( fp, "Clan         %s~\n", ch->pcdata->clan_name );
save.c:   fprintf( fp, "Flags        %d\n", ch->pcdata->flags );
save.c:   if( ch->pcdata->release_date > current_time )
save.c:      fprintf( fp, "Helled       %d %s~\n", ( int )ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:   fprintf( fp, "PKills       %d\n", ch->pcdata->pkills );
save.c:   fprintf( fp, "PDeaths      %d\n", ch->pcdata->pdeaths );
save.c:   fprintf( fp, "MKills       %d\n", ch->pcdata->mkills );
save.c:   fprintf( fp, "MDeaths      %d\n", ch->pcdata->mdeaths );
save.c:   fprintf( fp, "ArenaWins    %d\n", ch->pcdata->arena_wins );
save.c:   fprintf( fp, "ArenaKills   %d\n", ch->pcdata->arena_kills );
save.c:   fprintf( fp, "ArenaDeaths  %d\n", ch->pcdata->arena_deaths );
save.c:   fprintf( fp, "IllegalPK    %d\n", ch->pcdata->illegal_pk );
save.c:            ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
save.c:            ch->mod_str, ch->mod_int, ch->mod_wis, ch->mod_dex, ch->mod_con, ch->mod_cha, ch->mod_lck );
save.c:            ch->pcdata->condition[0],
save.c:            ch->pcdata->condition[1], ch->pcdata->condition[2], ch->pcdata->condition[3], ch->pcdata->condition[4] );
save.c:   if( ch->desc && ch->desc->host )
save.c:      fprintf( fp, "Site         %s\n", ch->desc->host );
save.c:      if( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:               fprintf( fp, "Skill        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Spell        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Weapon       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Tongue       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
save.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:      if( ch->pcdata->killed[sn].vnum == 0 )
save.c:      fprintf( fp, "Killed       %d %d\n", ch->pcdata->killed[sn].vnum, ch->pcdata->killed[sn].count );
save.c:   if( ch->pcdata->first_qbit )
save.c:      for( bit = ch->pcdata->first_qbit; bit; bit = bit->next )
save.c:   if( ch->pcdata->chan_listen )
save.c:      fprintf( fp, "Channels    %s~\n", ch->pcdata->chan_listen );
save.c:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c:   ch->desc = d;
save.c:   ch->pcdata->filename = STRALLOC( name );
save.c:   ch->name = NULL;
save.c:   ch->act = multimeb( PLR_BLANK, PLR_COMBINE, PLR_PROMPT, -1 );
save.c:   ch->perm_str = 13;
save.c:   ch->perm_int = 13;
save.c:   ch->perm_wis = 13;
save.c:   ch->perm_dex = 13;
save.c:   ch->perm_con = 13;
save.c:   ch->perm_cha = 13;
save.c:   ch->perm_lck = 13;
save.c:   ch->no_resistant = 0;
save.c:   ch->no_susceptible = 0;
save.c:   ch->no_immune = 0;
save.c:   ch->was_in_room = NULL;
save.c:   xCLEAR_BITS( ch->no_affected_by );
save.c:      ch->pcdata->condition[COND_THIRST] = 40;
save.c:      ch->pcdata->condition[COND_FULL] = 40;
save.c:      ch->pcdata->condition[COND_THIRST] = 48;
save.c:      ch->pcdata->condition[COND_FULL] = 48;
save.c:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:   ch->pcdata->condition[COND_BLEEDING] = 0;
save.c:   ch->pcdata->nuisance = NULL;
save.c:   ch->pcdata->wizinvis = 0;
save.c:   ch->pcdata->balance = 0;
save.c:   ch->pcdata->gbalance = 0;
save.c:   ch->pcdata->sbalance = 0;
save.c:   ch->mental_state = -10;
save.c:   ch->mobinvis = 0;
save.c:      ch->pcdata->learned[i] = 0;
save.c:   ch->pcdata->release_date = 0;
save.c:   ch->pcdata->helled_by = NULL;
save.c:   ch->saving_poison_death = 0;
save.c:   ch->saving_wand = 0;
save.c:   ch->saving_para_petri = 0;
save.c:   ch->saving_breath = 0;
save.c:   ch->saving_spell_staff = 0;
save.c:   ch->style = STYLE_FIGHTING;
save.c:   ch->comments = NULL; /* comments */
save.c:   ch->pcdata->pagerlen = 24;
save.c:   ch->pcdata->first_ignored = NULL;   /* Ignore list */
save.c:   ch->pcdata->last_ignored = NULL;
save.c:   ch->pcdata->tell_history = NULL; /* imm only lasttell cmnd */
save.c:   ch->pcdata->lt_index = 0;  /* last tell index */
save.c:   ch->morph = NULL;
save.c:   ch->pcdata->hometown = NULL;
save.c:   ch->pcdata->nation = NULL;
save.c:   ch->pcdata->htown_vnum = -1;
save.c:   ch->pcdata->nation_vnum = -1;
save.c:   ch->pcdata->smites = 0;
save.c:   ch->pcdata->smited = 0;
save.c:   ch->pcdata->wedto = NULL;
save.c:   ch->pcdata->afkmsg = NULL;
save.c:   ch->pcdata->arena = NULL;
save.c:      ch->pcdata->say_history[0] = NULL;
save.c:      ch->pcdata->tell_histories[0] = NULL;
save.c:                  preload ? "Preloading" : "Loading", ch->pcdata->filename, ( int )fst.st_size / 1024 );
save.c:               ch->pcdata->pet = mob;
save.c:               bug( "%s: Deleted mob saved on %s - skipping", __FUNCTION__, ch->name );
save.c:      ch->name = STRALLOC( name );
save.c:      ch->short_descr = STRALLOC( "" );
save.c:      ch->long_descr = STRALLOC( "" );
save.c:      ch->description = STRALLOC( "" );
save.c:      ch->editor = NULL;
save.c:      ch->pcdata->clan_name = STRALLOC( "" );
save.c:      ch->pcdata->clan = NULL;
save.c:      ch->pcdata->council_name = STRALLOC( "" );
save.c:      ch->pcdata->council = NULL;
save.c:      ch->pcdata->council2_name = STRALLOC( "" );
save.c:      ch->pcdata->council2 = NULL;
save.c:      ch->pcdata->deity_name = STRALLOC( "" );
save.c:      ch->pcdata->deity = NULL;
save.c:      ch->pcdata->pet = NULL;
save.c:      ch->pcdata->pwd = str_dup( "" );
save.c:      ch->pcdata->board = &boards[DEFAULT_BOARD];
save.c:      ch->pcdata->bamfin = str_dup( "" );
save.c:      ch->pcdata->bamfout = str_dup( "" );
save.c:      ch->pcdata->rank = str_dup( "" );
save.c:      ch->pcdata->bestowments = str_dup( "" );
save.c:      ch->pcdata->title = STRALLOC( "" );
save.c:      ch->pcdata->extraname = STRALLOC( "" );
save.c:      ch->pcdata->lastname = STRALLOC( "" );
save.c:      ch->pcdata->homepage = str_dup( "" );
save.c:      ch->pcdata->email = str_dup( "" );
save.c:      ch->pcdata->bio = STRALLOC( "" );
save.c:      ch->pcdata->authed_by = STRALLOC( "" );
save.c:      ch->pcdata->prompt = STRALLOC( "" );
save.c:      ch->pcdata->fprompt = STRALLOC( "" );
save.c:      ch->pcdata->r_range_lo = 0;
save.c:      ch->pcdata->r_range_hi = 0;
save.c:      ch->pcdata->m_range_lo = 0;
save.c:      ch->pcdata->m_range_hi = 0;
save.c:      ch->pcdata->o_range_lo = 0;
save.c:      ch->pcdata->o_range_hi = 0;
save.c:      ch->pcdata->wizinvis = 0;
save.c:      ch->pcdata->hometown = NULL;
save.c:      ch->pcdata->nation = NULL;
save.c:      ch->pcdata->nation_vnum = -1;
save.c:      ch->pcdata->htown_vnum = -1;
save.c:      ch->pcdata->hair_color = STRALLOC( "" );
save.c:      ch->pcdata->eye_color = STRALLOC( "" );
save.c:      ch->pcdata->skin_tone = STRALLOC( "" );
save.c:      ch->pcdata->ch_build = STRALLOC( "" );
save.c:      ch->pcdata->hair_length = STRALLOC( "" );
save.c:      ch->pcdata->ch_height = STRALLOC( "" );
save.c:      if( !ch->name )
save.c:         ch->name = STRALLOC( name );
save.c:      if( !ch->pcdata->clan_name )
save.c:         ch->pcdata->clan_name = STRALLOC( "" );
save.c:         ch->pcdata->clan = NULL;
save.c:      if( !ch->pcdata->council_name )
save.c:         ch->pcdata->council_name = STRALLOC( "" );
save.c:         ch->pcdata->council = NULL;
save.c:      if( !ch->pcdata->council2_name )
save.c:         ch->pcdata->council2_name = STRALLOC( "" );
save.c:         ch->pcdata->council2 = NULL;
save.c:      if( !ch->pcdata->deity_name )
save.c:         ch->pcdata->deity_name = STRALLOC( "" );
save.c:         ch->pcdata->deity = NULL;
save.c:      if( !ch->pcdata->bio )
save.c:         ch->pcdata->bio = STRALLOC( "" );
save.c:      if( !ch->pcdata->authed_by )
save.c:         ch->pcdata->authed_by = STRALLOC( "" );
save.c:      if( xIS_SET( ch->act, PLR_FLEE ) )
save.c:         xREMOVE_BIT( ch->act, PLR_FLEE );
save.c:         if( ch->pcdata->wizinvis < 2 )
save.c:            ch->pcdata->wizinvis = ch->level;
save.c:       * REMOVE_BIT(ch->speaks, LANG_COMMON | race_table[ch->race]->language);
save.c:       * if ( countlangs(ch->speaks) < (ch->level / 10) && !IS_IMMORTAL(ch) )
save.c:       * int need = (ch->level / 10) - countlangs(ch->speaks);
save.c:       * if ( ch->practice >= prac )
save.c:       * if ( ch->pcdata->learned[iLang] > 0 )
save.c:       * SET_BIT(ch->speaks, lang_array[lang]);
save.c:       * ch->pcdata->learned[iLang] = 70;
save.c:       * ch->speaks &= VALID_LANGS;
save.c:       * REMOVE_BIT(ch->speaks,
save.c:       * LANG_COMMON | race_table[ch->race]->language);
save.c:   ch->silver = 0;
save.c:   ch->copper = 0;
save.c:            KEY( "Act", ch->act, fread_bitvector( fp ) );
save.c:            KEY( "AffectedBy", ch->affected_by, fread_bitvector( fp ) );
save.c:            KEY( "Alignment", ch->alignment, fread_number( fp ) );
save.c:            KEY( "Armor", ch->armor, fread_number( fp ) );
save.c:            KEY( "ArenaWins", ch->pcdata->arena_wins, fread_number( fp ) );
save.c:            KEY( "ArenaKills", ch->pcdata->arena_kills, fread_number( fp ) );
save.c:            KEY( "ArenaDeaths", ch->pcdata->arena_deaths, fread_number( fp ) );
save.c:               LINK( paf, ch->first_affect, ch->last_affect, next, prev );
save.c:               ch->mod_str = x1;
save.c:               ch->mod_int = x2;
save.c:               ch->mod_wis = x3;
save.c:               ch->mod_dex = x4;
save.c:               ch->mod_con = x5;
save.c:               ch->mod_cha = x6;
save.c:               ch->mod_lck = x7;
save.c:                  ch->mod_lck = 0;
save.c:               ch->pcdata->alias[count] = str_dup( fread_word( fp ) );
save.c:               ch->pcdata->alias_sub[count] = fread_string_nohash( fp );
save.c:               ch->perm_str = x1;
save.c:               ch->perm_int = x2;
save.c:               ch->perm_wis = x3;
save.c:               ch->perm_dex = x4;
save.c:               ch->perm_con = x5;
save.c:               ch->perm_cha = x6;
save.c:               ch->perm_lck = x7;
save.c:                  ch->perm_lck = 13;
save.c:            KEY( "AuthedBy", ch->pcdata->authed_by, fread_string( fp ) );
save.c:            KEY( "Agemod", ch->age_bonus, fread_number( fp ) );
save.c:               KEY( "BL", ch->pcdata->ch_height, fread_string( fp ) );
save.c:               KEY( "BU", ch->pcdata->ch_build, fread_string( fp ) );
save.c:            KEY( "Balance", ch->pcdata->balance, fread_number( fp ) );
save.c:            KEY( "Bday", ch->day, fread_number( fp ) );
save.c:            KEY( "Bmonth", ch->month, fread_number( fp ) );
save.c:            KEY( "Byear", ch->year, fread_number( fp ) );
save.c:            KEY( "Bamfin", ch->pcdata->bamfin, fread_string_nohash( fp ) );
save.c:            KEY( "Bamfout", ch->pcdata->bamfout, fread_string_nohash( fp ) );
save.c:            KEY( "Belig", ch->belig, fread_number( fp ) );
save.c:            KEY( "Bkills", ch->bkills, fread_number( fp ) );
save.c:            KEY( "Bounty", ch->bounty, fread_number( fp ) );
save.c:            KEY( "Bowed", ch->bowed, fread_number( fp ) );
save.c:                     sprintf( buf, "fread_char: %s had unknown board name: %s. Skipped.", ch->name, boardname );
save.c:                     ch->pcdata->last_note[i] = fread_number( fp );
save.c:            KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:            KEY( "Bio", ch->pcdata->bio, fread_string( fp ) );
save.c:            KEY( "Channels", ch->pcdata->chan_listen, fread_string( fp ) );
save.c:               KEY( "CHBuild", ch->pcdata->ch_build, fread_string( fp ) );
save.c:               KEY( "CHHeight", ch->pcdata->ch_height, fread_string( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                           ch->pcdata->clan_name );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Class", ch->class, fread_number( fp ) );
save.c:               ch->class2 = fread_number( fp );
save.c:               if( ch->class2 < 0 )
save.c:                  ch->class2 = 0;
save.c:               ch->class3 = fread_number( fp );
save.c:               if( ch->class3 < 0 )
save.c:                  ch->class3 = 0;
save.c:               ch->pcdata->condition[0] = x1;
save.c:               ch->pcdata->condition[1] = x2;
save.c:               ch->pcdata->condition[2] = x3;
save.c:               ch->pcdata->condition[3] = x4;
save.c:               ch->pcdata->condition[4] = x5;
save.c:            KEY( "Copper", ch->copper, fread_number( fp ) );
save.c:               ch->pcdata->council_name = fread_string( fp );
save.c:                   && ch->pcdata->council_name[0] != '\0'
save.c:                   && ( ch->pcdata->council = get_council( ch->pcdata->council_name ) ) == NULL )
save.c:                           ch->pcdata->council_name );
save.c:                  STRFREE( ch->pcdata->council_name );
save.c:                  ch->pcdata->council_name = STRALLOC( "" );
save.c:               ch->pcdata->council2_name = fread_string( fp );
save.c:                   && ch->pcdata->council2_name[0] != '\0'
save.c:                   && ( ch->pcdata->council2 = get_council( ch->pcdata->council2_name ) ) == NULL )
save.c:                           ch->pcdata->council2_name );
save.c:                  STRFREE( ch->pcdata->council2_name );
save.c:                  ch->pcdata->council2_name = STRALLOC( "" );
save.c:            KEY( "Damroll", ch->damroll, fread_number( fp ) );
save.c:            KEY( "Deaf", ch->deaf, fread_number( fp ) );
save.c:               ch->pcdata->deity_name = fread_string( fp );
save.c:                   && ch->pcdata->deity_name[0] != '\0'
save.c:                   && ( ch->pcdata->deity = get_deity( ch->pcdata->deity_name ) ) == NULL )
save.c:                  sprintf( buf, "Warning: the deity %s no longer exists.\r\n", ch->pcdata->deity_name );
save.c:                  STRFREE( ch->pcdata->deity_name );
save.c:                  ch->pcdata->deity_name = STRALLOC( "" );
save.c:                  ch->pcdata->favor = 0;
save.c:            KEY( "Description", ch->description, fread_string( fp ) );
save.c:            KEY( "Favor", ch->pcdata->favor, fread_number( fp ) );
save.c:            KEY( "Flags", ch->pcdata->flags, fread_number( fp ) );
save.c:            KEY( "FPrompt", ch->pcdata->fprompt, fread_string( fp ) );
save.c:            KEY( "GBalance", ch->pcdata->gbalance, fread_number( fp ) );
save.c:            KEY( "GhostLevel", ch->ghost_level, fread_number( fp ) );
save.c:            KEY( "Glory", ch->pcdata->quest_curr, fread_number( fp ) );
save.c:            KEY( "Gold", ch->gold, fread_number( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                           ch->pcdata->clan_name );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Height", ch->height, fread_number( fp ) );
save.c:               KEY( "HairColor", ch->pcdata->hair_color, fread_string( fp ) );
save.c:               KEY( "HairLength", ch->pcdata->hair_length, fread_string( fp ) );
save.c:               KEY( "HC", ch->pcdata->hair_color, fread_string( fp ) );
save.c:               KEY( "HL", ch->pcdata->hair_length, fread_string( fp ) );
save.c:               ch->pcdata->release_date = fread_number( fp );
save.c:               ch->pcdata->helled_by = fread_string( fp );
save.c:               if( ch->pcdata->release_date < current_time )
save.c:                  STRFREE( ch->pcdata->helled_by );
save.c:                  ch->pcdata->helled_by = NULL;
save.c:                  ch->pcdata->release_date = 0;
save.c:            KEY( "Hitroll", ch->hitroll, fread_number( fp ) );
save.c:            KEY( "Hometown", ch->pcdata->htown_vnum, fread_number( fp ) );
save.c:            KEY( "Homepage", ch->pcdata->homepage, fread_string_nohash( fp ) );
save.c:               ch->hit = fread_number( fp );
save.c:               ch->max_hit = fread_number( fp );
save.c:               ch->mana = fread_number( fp );
save.c:               ch->max_mana = fread_number( fp );
save.c:               ch->move = fread_number( fp );
save.c:               ch->max_move = fread_number( fp );
save.c:               for( ign = 0, inode = ch->pcdata->first_ignored; inode; inode = inode->next )
save.c:                  LINK( inode, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
save.c:            KEY( "IllegalPK", ch->pcdata->illegal_pk, fread_number( fp ) );
save.c:            KEY( "Immune", ch->immune, fread_number( fp ) );
save.c:                  ch->pcdata->killed[killcnt].vnum = fread_number( fp );
save.c:                  ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:               ch->pcdata->lastname = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->lastname[0] ) || isdigit( ch->pcdata->lastname[0] ) )
save.c:                  sprintf( buf, " %s", ch->pcdata->lastname );
save.c:                  if( ch->pcdata->lastname )
save.c:                     STRFREE( ch->pcdata->lastname );
save.c:                  ch->pcdata->lastname = STRALLOC( buf );
save.c:            KEY( "Level", ch->level, fread_number( fp ) );
save.c:                  ch->level2 = -1;
save.c:                  ch->level2 = x1;
save.c:                  ch->level3 = -1;
save.c:                  ch->level3 = x1;
save.c:            KEY( "LongDescr", ch->long_descr, fread_string( fp ) );
save.c:               ch->speaks = fread_number( fp );
save.c:               ch->speaking = fread_number( fp );
save.c:            KEY( "MDeaths", ch->pcdata->mdeaths, fread_number( fp ) );
save.c:               ch->pcdata->memorize[0] = fread_number( fp );
save.c:               ch->pcdata->memorize[1] = fread_number( fp );
save.c:               ch->pcdata->memorize[2] = fread_number( fp );
save.c:               ch->pcdata->memorize[3] = fread_number( fp );
save.c:               ch->pcdata->memorize[4] = fread_number( fp );
save.c:               ch->pcdata->memorize[5] = fread_number( fp );
save.c:               ch->pcdata->memorize[6] = fread_number( fp );
save.c:               ch->pcdata->memorize[7] = fread_number( fp );
save.c:            KEY( "Mentalstate", ch->mental_state, fread_number( fp ) );
save.c:            KEY( "MGlory", ch->pcdata->quest_accum, fread_number( fp ) );
save.c:            KEY( "Minsnoop", ch->pcdata->min_snoop, fread_number( fp ) );
save.c:            KEY( "MKills", ch->pcdata->mkills, fread_number( fp ) );
save.c:            KEY( "Mobinvis", ch->mobinvis, fread_number( fp ) );
save.c:               ch->pcdata->m_range_lo = fread_number( fp );
save.c:               ch->pcdata->m_range_hi = fread_number( fp );
save.c:            KEY( "Name", ch->name, fread_string( fp ) );
save.c:            KEY( "Nation", ch->pcdata->nation_vnum, fread_number( fp ) );
save.c:            KEY( "NoAffectedBy", ch->no_affected_by, fread_bitvector( fp ) );
save.c:            KEY( "NoImmune", ch->no_immune, fread_number( fp ) );
save.c:            KEY( "NoResistant", ch->no_resistant, fread_number( fp ) );
save.c:            KEY( "NoSusceptible", ch->no_susceptible, fread_number( fp ) );
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = 1;
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = fread_number( fp );
save.c:            KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:               ch->pcdata->o_range_lo = fread_number( fp );
save.c:               ch->pcdata->o_range_hi = fread_number( fp );
save.c:            KEY( "Pagerlen", ch->pcdata->pagerlen, fread_number( fp ) );
save.c:            KEY( "Password", ch->pcdata->pwd, fread_string_nohash( fp ) );
save.c:            KEY( "PDeaths", ch->pcdata->pdeaths, fread_number( fp ) );
save.c:            KEY( "PKills", ch->pcdata->pkills, fread_number( fp ) );
save.c:            KEY( "Played", ch->played, fread_number( fp ) );
save.c:             * KEY( "Position", ch->position,     fread_number( fp ) );
save.c:               ch->position = fread_number( fp );
save.c:               if( ch->position < 100 )
save.c:                  switch ( ch->position )
save.c:                        ch->position = 6;
save.c:                        ch->position = 8;
save.c:                        ch->position = 9;
save.c:                        ch->position = 12;
save.c:                        ch->position = 13;
save.c:                        ch->position = 14;
save.c:                        ch->position = 15;
save.c:                  ch->position -= 100;
save.c:            KEY( "Practice", ch->practice, fread_number( fp ) );
save.c:            KEY( "Prompt", ch->pcdata->prompt, fread_string( fp ) );
save.c:            KEY( "QuestNext", ch->nextquest, fread_number( fp ) );
save.c:               LINK( bit, ch->pcdata->first_qbit, ch->pcdata->last_qbit, next, prev );
save.c:            KEY( "Race", ch->race, fread_number( fp ) );
save.c:            KEY( "Rank", ch->pcdata->rank, fread_string_nohash( fp ) );
save.c:            KEY( "Resistant", ch->resistant, fread_number( fp ) );
save.c:            KEY( "Restore_time", ch->pcdata->restore_time, fread_number( fp ) );
save.c:               ch->in_room = get_room_index( fread_number( fp ) );
save.c:               if( !ch->in_room )
save.c:                  ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:               ch->pcdata->r_range_lo = fread_number( fp );
save.c:               ch->pcdata->r_range_hi = fread_number( fp );
save.c:            KEY( "SBalance", ch->pcdata->sbalance, fread_number( fp ) );
save.c:               KEY( "SkinTone", ch->pcdata->skin_tone, fread_string( fp ) );
save.c:               KEY( "ST", ch->pcdata->skin_tone, fread_string( fp ) );
save.c:            KEY( "Sex", ch->sex, fread_number( fp ) );
save.c:            KEY( "ShortDescr", ch->short_descr, fread_string( fp ) );
save.c:            KEY( "Silver", ch->silver, fread_number( fp ) );
save.c:            KEY( "Smites", ch->pcdata->smites, fread_number( fp ) );
save.c:            KEY( "Smited", ch->pcdata->smited, fread_number( fp ) );
save.c:            KEY( "Style", ch->style, fread_number( fp ) );
save.c:            KEY( "Susceptible", ch->susceptible, fread_number( fp ) );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_poison_death = ch->saving_wand;
save.c:               ch->saving_para_petri = ch->saving_wand;
save.c:               ch->saving_breath = ch->saving_wand;
save.c:               ch->saving_spell_staff = ch->saving_wand;
save.c:               ch->saving_poison_death = fread_number( fp );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_para_petri = fread_number( fp );
save.c:               ch->saving_breath = fread_number( fp );
save.c:               ch->saving_spell_staff = fread_number( fp );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( ch->level3 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2]
save.c:                                 && skill_table[sn]->skill_level[ch->class3] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( ch->level2 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( ch->level3 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2]
save.c:                                 && skill_table[sn]->skill_level[ch->class3] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( ch->level2 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:               KEY( "Email", ch->pcdata->email, fread_string_nohash( fp ) );
save.c:               KEY( "EyeColor", ch->pcdata->eye_color, fread_string( fp ) );
save.c:               KEY( "EC", ch->pcdata->eye_color, fread_string( fp ) );
save.c:               ch->pcdata->extraname = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->extraname[0] ) || isdigit( ch->pcdata->extraname[0] ) )
save.c:                  sprintf( buf, " %s", ch->pcdata->extraname );
save.c:                  if( ch->pcdata->extraname )
save.c:                     STRFREE( ch->pcdata->extraname );
save.c:                  ch->pcdata->extraname = STRALLOC( buf );
save.c:               if( !ch->short_descr )
save.c:                  ch->short_descr = STRALLOC( "" );
save.c:               if( !ch->long_descr )
save.c:                  ch->long_descr = STRALLOC( "" );
save.c:               if( !ch->description )
save.c:                  ch->description = STRALLOC( "" );
save.c:               if( !ch->pcdata->pwd )
save.c:                  ch->pcdata->pwd = str_dup( "" );
save.c:               if( !ch->pcdata->bamfin )
save.c:                  ch->pcdata->bamfin = str_dup( "" );
save.c:               if( !ch->pcdata->bamfout )
save.c:                  ch->pcdata->bamfout = str_dup( "" );
save.c:               if( !ch->pcdata->bio )
save.c:                  ch->pcdata->bio = STRALLOC( "" );
save.c:               if( !ch->pcdata->rank )
save.c:                  ch->pcdata->rank = str_dup( "" );
save.c:               if( !ch->pcdata->bestowments )
save.c:                  ch->pcdata->bestowments = str_dup( "" );
save.c:               if( !ch->pcdata->title )
save.c:                  ch->pcdata->title = STRALLOC( "" );
save.c:               if( !ch->pcdata->extraname )
save.c:                  ch->pcdata->extraname = STRALLOC( "" );
save.c:               if( !ch->pcdata->lastname )
save.c:                  ch->pcdata->lastname = STRALLOC( "" );
save.c:               if( !ch->pcdata->homepage )
save.c:                  ch->pcdata->homepage = str_dup( "" );
save.c:               if( !ch->pcdata->email )
save.c:                  ch->pcdata->email = str_dup( "" );
save.c:               if( !ch->pcdata->authed_by )
save.c:                  ch->pcdata->authed_by = STRALLOC( "" );
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( !ch->pcdata->fprompt )
save.c:                  ch->pcdata->fprompt = STRALLOC( "" );
save.c:               if( !ch->pcdata->hair_color )
save.c:                  ch->pcdata->hair_color = STRALLOC( "" );
save.c:               if( !ch->pcdata->eye_color )
save.c:                  ch->pcdata->eye_color = STRALLOC( "" );
save.c:               if( !ch->pcdata->skin_tone )
save.c:                  ch->pcdata->skin_tone = STRALLOC( "" );
save.c:               if( !ch->pcdata->ch_build )
save.c:                  ch->pcdata->ch_build = STRALLOC( "" );
save.c:               if( !ch->pcdata->hair_length )
save.c:                  ch->pcdata->hair_length = STRALLOC( "" );
save.c:               if( !ch->pcdata->ch_height )
save.c:                  ch->pcdata->ch_height = STRALLOC( "" );
save.c:               ch->editor = NULL;
save.c:               killcnt = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:                  ch->pcdata->killed[killcnt].vnum = 0;
save.c:               if( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:                  ch->speaking = LANG_COMMON;
save.c:                * ch->speaking = race_table[ch->race]->language; 
save.c:                  ch->speaks = ~0;
save.c:                  if( ch->speaking == 0 )
save.c:                     ch->speaking = ~0;
save.c:                  CREATE( ch->pcdata->tell_history, char *, 26 );
save.c:                     ch->pcdata->tell_history[i] = NULL;
save.c:               if( ch->pcdata->chan_listen != NULL )
save.c:                  char *channels = ch->pcdata->chan_listen;
save.c:                        removename( &ch->pcdata->chan_listen, arg );
save.c:                  ch->pcdata->chan_listen =
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( ch->height == 72 )
save.c:                  ch->height = number_range( race_table[ch->race]->height * .9, race_table[ch->race]->height * 1.1 );
save.c:               if( ch->weight == 180 )
save.c:                  ch->weight = number_range( race_table[ch->race]->weight * .9, race_table[ch->race]->weight * 1.1 );
save.c:               if( ch->year == 0 )
save.c:                  ch->age = find_old_age( ch );
save.c:                  ch->age = calculate_age( ch );
save.c:               if( ch->month > 11 )
save.c:                  ch->month = 11;   /* Catches the bad month values */
save.c:               if( ch->day > 25 )
save.c:                  ch->day = 25;  /* Cathes the bad day values */
save.c:            KEY( "Exp", ch->exp, fread_number( fp ) );
save.c:            KEY( "Exp2", ch->exp2, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( ch->level3 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2]
save.c:                                 && skill_table[sn]->skill_level[ch->class3] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( ch->level2 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:            KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:            ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:               ch->pcdata->title = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->title[0] ) || isdigit( ch->pcdata->title[0] ) )
save.c:                  sprintf( buf, " %s", ch->pcdata->title );
save.c:                  if( ch->pcdata->title )
save.c:                     STRFREE( ch->pcdata->title );
save.c:                  ch->pcdata->title = STRALLOC( buf );
save.c:            KEY( "WedTo", ch->pcdata->wedto, fread_string( fp ) );
save.c:            KEY( "Weight", ch->weight, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( ch->level3 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2]
save.c:                                 && skill_table[sn]->skill_level[ch->class3] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( ch->level2 != -1 )
save.c:                           if( ( skill_table[sn]->skill_level[ch->class]
save.c:                                 && skill_table[sn]->skill_level[ch->class2] ) >= LEVEL_IMMORTAL )
save.c:                              ch->pcdata->learned[sn] = 0;
save.c:                              ch->practice++;
save.c:                        else if( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:            KEY( "Wimpy", ch->wimpy, fread_number( fp ) );
save.c:            KEY( "WizInvis", ch->pcdata->wizinvis, fread_number( fp ) );
save.c:      room = ch->in_room;
save.c:                     obj = obj_to_room( obj, ch->pcdata->locker_room );
save.c:                  LINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
save.c:      name = ch->name;
save.c:   if( IS_NPC( ch ) || !ch->pcdata->pet )
save.c:   mob = ch->pcdata->pet;
save.c:      if( ch->in_room )
save.c:         return ch->in_room->vnum;
save.c:         bug( "get_obj_room_vnum_recursive: Char \"%s\" not in room?!", ch->name );
save.c:      for( rch = first_char; rch; rch = rch->next )
save.c:         if( !IS_NPC( rch ) || rch == supermob || xIS_SET( rch->act, ACT_PROTOTYPE ) || xIS_SET( rch->act, ACT_PET ) )
saveall.c:    for ( vch = first_char; vch; vch = vch->next )
saveall.c:           pager_printf( ch, "Saving %-s...\r\n", vch->name);
sharpen.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
sharpen.c:   if( !IS_NPC( ch ) && percent > ch->pcdata->learned[gsn_sharpen] )
sharpen.c:   level = ch->level;
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      sprintf( buf, "shout %s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      sprintf( buf, "shout %s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking ), knows_language( ch, ch->speaking ) );
shops.c:         sprintf( buf, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         sprintf( buf, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         sprintf( buf, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         sprintf( buf, "%s I can't understand you.", ch->name );
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      sprintf( buf, "shout %s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      sprintf( buf, "shout %s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking ), knows_language( ch, ch->speaking ) );
shops.c:         sprintf( buf, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         sprintf( buf, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         sprintf( buf, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         sprintf( buf, "%s I can't understand you.", ch->name );
shops.c:   if( ch->gold > ( ch->level * ch->level * 100000 ) )
shops.c:         + ( ( URANGE( 5, ch->level, LEVEL_AVATAR ) - 20 ) / 2 );
shops.c:      cost = ( int )( cost * ( 80 + UMIN( ch->level, LEVEL_AVATAR ) ) ) / 100;
shops.c:      switch ( ch->race )  /* racism... should compare against shopkeeper's race */
shops.c:   if( IS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      in_room = ch->in_room;
shops.c:      ch->in_room = pRoomIndexNext;
shops.c:      ch->in_room = in_room;
shops.c:      if( xIS_SET( ch->act, PLR_BOUGHT_PET ) )
shops.c:      wealth = get_value( ch->gold, ch->silver, ch->copper );
shops.c:      if( ch->level < pet->level )
shops.c:      if( ch->gold < gcost || ch->silver < scost || ch->copper < ccost )
shops.c:         ch->gold -= gcost;
shops.c:         ch->silver -= scost;
shops.c:         ch->copper -= ccost;
shops.c:      boost_economy( ch->in_room->area, maxgold );
shops.c:      xSET_BIT( ch->act, PLR_BOUGHT_PET );
shops.c:      sprintf( buf, "%sA neck tag says 'I belong to %s'.\r\n", pet->description, ch->name );
shops.c:      char_to_room( pet, ch->in_room );
shops.c:            ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      plrmoney = get_value( ch->gold, ch->silver, ch->copper );
shops.c:         ch->reply = keeper;
shops.c:      if( obj->level > ch->level )
shops.c:         ch->reply = keeper;
shops.c:      if( xIS_SET( keeper->act, ACT_GLORYSHOP ) && ch->pcdata->quest_curr < tvalue )
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:      if( ch->carry_weight + ( get_obj_weight( obj ) * noi ) + ( noi > 1 ? 2 : 0 ) > can_carry_w( ch ) )
shops.c:         ch->pcdata->quest_curr -= tvalue;
shops.c:      else if( ch->gold < gcost || ch->silver < scost || ch->copper < ccost )
shops.c:         plrmoney = get_value( ch->gold, ch->silver, ch->copper );
shops.c:         ch->gold -= gcost;
shops.c:         ch->silver -= scost;
shops.c:         ch->copper -= ccost;
shops.c:   if( IS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      ch->reply = keeper;
shops.c:   ch->gold += gcost;
shops.c:   ch->silver += scost;
shops.c:   ch->copper += ccost;
shops.c:      ch->reply = keeper;
shops.c:   ch->reply = keeper;
shops.c:   plrmoney = get_value( ch->gold, ch->silver, ch->copper );
shops.c:      if( ch->gold < gcost || ch->silver < scost || ch->copper < ccost )
shops.c:         plrmoney = get_value( ch->gold, ch->silver, ch->copper );
shops.c:         ch->gold -= gcost;
shops.c:         ch->silver -= scost;
shops.c:         ch->copper -= ccost;
shops.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
shops.c:      ch->reply = keeper;
shops.c:   for( obj = ch->first_carrying; obj != NULL; obj = obj->next_content )
shops.c:      if( total > get_value( ch->gold, ch->silver, ch->copper ) )
shops.c:      ch->reply = keeper;
shops.c:   if( cost > get_value( ch->gold, ch->silver, ch->copper ) )
skills.c:   if( ch->pcdata->clan && ch->pcdata->clan == vch->pcdata->clan )
skills.c:                                      100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
skills.c:      else if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:               if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
skills.c:               ch->mana -= mana / 2;
skills.c:            ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, vo );
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:         ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   sklvl = skill_table[sn]->skill_level[ch->class];
skills.c:      sklvl = ch->level;
skills.c:   if( ch->pcdata->learned[sn] < adept )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == adept ) /* fully learned! */
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:   if( ch->pcdata->learned[sn] < ( adept - 1 ) )
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + 1 );
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 5, ch->level );
skills.c:               af.duration = ( ch->level + 10 ) / get_curr_con( victim );
skills.c:               af.duration = 3 + ( ch->level / 15 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         if( !ch->in_room->first_content )
skills.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:         ch->alloc_ptr = str_dup( obj->name );
skills.c:         if( !ch->alloc_ptr )
skills.c:            bug( "do_detrap: ch->alloc_ptr NULL!", 0 );
skills.c:         strcpy( arg, ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->alloc_ptr = NULL;
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   if( !ch->in_room->first_content )
skills.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:   percent = number_percent(  ) - ( ch->level / 15 ) - ( get_curr_lck( ch ) - 16 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:            switch ( ch->in_room->sector_type )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         strcpy( arg, ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:   startobj = ch->in_room->first_content;
skills.c:	    (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         strcpy( arg, ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:      startobj = ch->in_room->first_content;
skills.c:   percent = number_percent(  ) + number_percent(  ) - ( ch->level / 10 );
skills.c:      if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
skills.c:   if( ch->mount )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( ( ch->level > victim->level + 10 ) && !IS_NPC( victim ) )
skills.c:   if( ( ch->level < victim->level - 10 ) && !IS_NPC( victim ) )
skills.c:   if( ch->level + 10 < victim->level )
skills.c:      sprintf( buf, "yell %s is a bloody thief!", ch->name );
skills.c:               if( ( mst = ch->master ) == NULL )
skills.c:      ch->gold += amount;
skills.c:       || IS_OBJ_STAT( obj, ITEM_INVENTORY ) || IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) || obj->level > ch->level )
skills.c:   if( ch->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( ch ) )
skills.c:   if( ch->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( ch ) )
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( ch ) && !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( ch->fighting )
skills.c:        * &&   ch->level < skill_table[gsn_kick]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_kick ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_kick );
skills.c:        * &&   ch->level < skill_table[gsn_punch]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_punch ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_punch );
skills.c:        * &&   ch->level < skill_table[gsn_bite]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_bite ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bite );
skills.c:        * &&   ch->level < skill_table[gsn_claw]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_claw ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_claw );
skills.c:        * &&   ch->level < skill_table[gsn_sting]->skill_level[ch->class] )
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_sting ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_sting );
skills.c:        * &&   ch->level < skill_table[gsn_tail]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_tail ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_tail );
skills.c:        * &&   ch->level < skill_table[gsn_bash]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_bash ) )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bash );
skills.c:        * &&   ch->level < skill_table[gsn_stun]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_stun ) )
skills.c:   if( !IS_NPC( ch ) && ch->move < ch->max_move / 10 )
skills.c:   schance = ris_save( victim, ch->level, RIS_PARALYSIS );
skills.c:         ch->move -= ch->max_move / 10;
skills.c:         ch->move -= ch->max_move / 15;
skills.c:   if( ch->fighting )
skills.c:   if( ch->pcdata->condition[COND_BLOODTHIRST] < 10 )
skills.c:      obj_to_room( obj, ch->in_room );
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 1, ch->level );
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:                         UMIN( number_range( 1, ( ch->level + victim->level / 20 ) + 3 ),
skills.c:                               ( 10 + ch->level ) - ch->pcdata->condition[COND_BLOODTHIRST] ) );
skills.c:         if( ch->pcdata->condition[COND_FULL] <= 37 )
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:        * &&   ch->level < skill_table[gsn_disarm]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_disarm ) )
skills.c:   percent = number_percent(  ) + victim->level - ch->level - ( get_curr_lck( ch ) - 15 ) + ( get_curr_lck( victim ) - 15 );
skills.c:   if( ch->mental_state >= 20 )
skills.c:   if ( ch->pcdata->condition[COND_FULL] <=10 && ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->pcdata->condition[COND_FULL] <=10 )
skills.c:   if( ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->max_mana > ch->mana + get_curr_int(ch) )
skills.c:      ch->mana = ch->mana + get_curr_int( ch );
skills.c:      ch->mana = ch->max_mana;
skills.c:   if( ch->max_move > ch->move + (get_curr_dex(ch) * 15) )
skills.c:      ch->move = ch->move + (get_curr_dex(ch) * 15);
skills.c:      ch->move = ch->max_move;
skills.c:   if( ch->mental_state >= 20 )
skills.c:   if ( ch->pcdata->condition[COND_FULL] <=10 && ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->pcdata->condition[COND_FULL] <=10 )
skills.c:   if( ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->max_mana > ch->mana + get_curr_int(ch) )
skills.c:      ch->mana = ch->mana + get_curr_int( ch ) + get_curr_wis( ch ) + 5;
skills.c:      ch->mana = ch->max_mana;
skills.c:   if( ch->max_move > ch->move + (get_curr_dex(ch) * 15) )
skills.c:      ch->move = ch->move + (get_curr_dex(ch) * 15);
skills.c:      ch->move = ch->max_move;
skills.c:   if( ch->mental_state >= 20 )
skills.c:   if ( ch->pcdata->condition[COND_FULL] <=10 && ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->pcdata->condition[COND_FULL] <=10 )
skills.c:   if( ch->pcdata->condition[COND_THIRST] <=10 )
skills.c:   if( ch->max_mana > ch->mana + get_curr_int(ch) )
skills.c:      ch->mana = ch->mana + get_curr_int( ch ) + get_curr_wis( ch ) + ch->level;
skills.c:      ch->mana = ch->max_mana;
skills.c:   if( ch->max_move > ch->move + (get_curr_dex(ch) * 15) )
skills.c:      ch->move = ch->move + (get_curr_dex(ch) * 15);
skills.c:      ch->move = ch->max_move;
skills.c:   if( ch->mount )
skills.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
skills.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
skills.c:       || victim->level >= ch->level + 15
skills.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
skills.c:   if( ch->mount )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:      if( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->level + 5 < gch->level )
skills.c:/*        for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:          if ( IS_NPC(gch) && IS_AWAKE(gch) && xIS_SET(gch->act, ACT_GUARDIAN ) )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:      af.duration = ch->level * DUR_CONV;
skills.c:   if( ch->mount )
skills.c:      xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
skills.c:   for( paf = ch->first_affect; paf; paf = paf_next )
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->hometown )
skills.c:      location = get_room_index( ch->pcdata->hometown->recall );
skills.c:      if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master && !IS_NPC( ch->master ) )
skills.c:      location = get_room_index( ch->pcdata->memorize[0] );
skills.c:   if( !location && !IS_NPC( ch ) && ch->pcdata->clan )
skills.c:      location = get_room_index( ch->pcdata->clan->recall );
skills.c:   if( !IS_NPC( ch ) && !location && ch->level >= 5
skills.c:        * &&   IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) 
skills.c:      location = get_room_index( race_table[ch->race]->race_recall );
skills.c:   if( ch->in_room == location )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
skills.c:         lose = ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1;
skills.c:         if( ch->desc )
skills.c:   if( ch->mount )
skills.c:      char_from_room( ch->mount );
skills.c:      char_to_room( ch->mount, location );
skills.c:   if( ch->mount )
skills.c:        * &&   ch->level < skill_table[gsn_mount]->skill_level[ch->class] )
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_mount ) )
skills.c:   if( ch->mount )
skills.c:      ch->mount = victim;
skills.c:      ch->position = POS_MOUNTED;
skills.c:   if( ( victim = ch->mount ) == NULL )
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_STANDING;
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_SITTING;
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )   /* SB */
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:        * && ch->level < skill_table[gsn_poison_weapon]->skill_level[ch->class] )
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_poison_weapon ) )
skills.c:   if( ch->fighting )
skills.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:   for( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:   if( !IS_NPC( ch ) && ( ( get_curr_dex( ch ) < 17 ) || ch->pcdata->condition[COND_DRUNK] > 0 ) )
skills.c:      damage( ch, ch, ch->level, gsn_poison_weapon );
skills.c:   obj->timer = UMIN( obj->level, ch->level );
skills.c:/*    &&   ch->level < skill_table[gsn_scribe]->skill_level[ch->class] ) */
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_scribe ) )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   if( !IS_NPC( ch ) && number_percent(  ) > ch->pcdata->learned[gsn_scribe] )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      scroll->value[0] = ch->level;
skills.c:      ch->mana -= mana;
skills.c:         ch->mana -= ( mana / 2 );
skills.c:      if( scroll->value[0] > ch->level )
skills.c:         scroll->value[0] = ch->level;
skills.c:      ch->mana -= mana;
skills.c:         ch->mana -= ( mana / 2 );
skills.c:      if( scroll->value[0] > ch->level )
skills.c:         scroll->value[0] = ch->level;
skills.c:      ch->mana -= mana;
skills.c:        * &&   ch->level < skill_table[gsn_brew]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_brew ) )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   potion->value[0] = ch->level;
skills.c:   ch->mana -= mana;
skills.c:   if( number_percent(  ) >= schance + victim->level - ch->level )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( !ch->fighting )
skills.c:   af.duration = number_range( ch->level / 5, ch->level * 2 / 5 );
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( !ch->in_room->first_person )
skills.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:      vch_next = vch->next_in_room;
skills.c:      if( ++nvict > ch->level / 5 )
skills.c:   ch->move = UMAX( 0, ch->move - nvict * 3 + nhit );
skills.c:      if(  /* ( !IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) || */ ch->level - victim->level > 10
skills.c:           * || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) ) 
skills.c:                  ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->name, victim->in_room->vnum );
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      send_to_char( ch->in_room->name, ch );
skills.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:      show_char_to_char( ch->in_room->first_person, ch );
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:         global_retcode = spell_attack( dt, ch->level, ch, victim );
skills.c:      if( IS_SET( ch->in_room->room_flags, ROOM_PRIVATE ) || IS_SET( ch->in_room->room_flags, ROOM_SOLITARY ) )
skills.c:      if( ch->in_room->tunnel > 0 )
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:         if( count >= ch->in_room->tunnel )
skills.c:       * if ( IS_NPC(vch) && xIS_SET(vch->act, ACT_STAY_AREA)
skills.c:       * &&   ch->in_room->area != vch->in_room->area) )
skills.c:      if( IS_SET( vch->in_room->room_flags, ROOM_NOMISSILE ) )
skills.c:      if( vch->num_fighting > max_fight( ) )
skills.c:      if( !IS_NPC( vch ) && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   was_in_room = ch->in_room;
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:      if( victim && ch->in_room == victim->in_room )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:  for ( throw_obj = ch->last_carrying; throw_obj;
skills.c:  if ( ch->fighting )
skills.c:    victim = ch->fighting;
skills.c:        * &&   ch->level < skill_table[gsn_slice]->skill_level[ch->class] ) 
skills.c:       && ch->level < SKILL_CLASS( ch, gsn_slice ) )
skills.c:         damage( ch, ch, ch->level, gsn_slice );
skills.c:                       ch->style == STYLE_BERSERK ? "&Rberserk" :
skills.c:                       ch->style == STYLE_AGGRESSIVE ? "&Raggressive" :
skills.c:                       ch->style == STYLE_DEFENSIVE ? "&Ydefensive" :
skills.c:                       ch->style == STYLE_EVASIVE ? "&Yevasive" : "standard" );
skills.c:             * ch->level < skill_table[gsn_style_evasive]->skill_level[ch->class]) 
skills.c:            ch->level < SKILL_CLASS( ch, gsn_style_evasive ) )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_EVASIVE;
skills.c:         ch->style = STYLE_EVASIVE;
skills.c:             * ch->level < skill_table[gsn_style_defensive]->skill_level[ch->class]) 
skills.c:            ch->level < SKILL_CLASS( ch, gsn_style_defensive ) )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_DEFENSIVE;
skills.c:         ch->style = STYLE_DEFENSIVE;
skills.c:             * ch->level < skill_table[gsn_style_standard]->skill_level[ch->class])
skills.c:            ch->level < SKILL_CLASS( ch, gsn_style_standard ) )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_FIGHTING;
skills.c:         ch->style = STYLE_FIGHTING;
skills.c:             * ch->level < skill_table[gsn_style_aggressive]->skill_level[ch->class])
skills.c:            ch->level < SKILL_CLASS( ch, gsn_style_aggressive ) )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_AGGRESSIVE;
skills.c:         ch->style = STYLE_AGGRESSIVE;
skills.c:             * ch->level < skill_table[gsn_style_berserk]->skill_level[ch->class])
skills.c:            ch->level < SKILL_CLASS( ch, gsn_style_berserk ) )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_BERSERK;
skills.c:         ch->style = STYLE_BERSERK;
skills.c:   else if( ch->morph && ch->morph->morph && ch->morph->morph->skills &&
skills.c:            ch->morph->morph->skills[0] != '\0' &&
skills.c:            is_name( skill_table[gsn]->name, ch->morph->morph->skills ) && percent < 85 )
skills.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->no_skills &&
skills.c:       ch->morph->morph->no_skills[0] != '\0' && is_name( skill_table[gsn]->name, ch->morph->morph->no_skills ) )
skills.c:        * ch->level < skill_table[gsn_cook]->skill_level[ch->class] )
skills.c:       ch->level < SKILL_CLASS( ch, gsn_cook ) )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
skills.c:      if( number_percent(  ) >= 55 + ch->pcdata->learned[gsn_study] * 4 / 5 )
skills.c:      if( ch->pcdata->learned[sn] )
skills.c:      ch->pcdata->learned[sn] = 1;
skills.c:      if( number_percent(  ) >= 15 + ch->pcdata->learned[gsn_study] * 4 / 5 )
skills.c:      if( ch->pcdata->learned[sn] )
skills.c:      ch->pcdata->learned[sn] = 1;
skills.c:   if( ch->pcdata->condition[COND_BLEEDING] > 0 )
slay.c:   if( !IS_NPC( victim ) && victim->level > ch->level )
slay.c:             || ( !str_cmp( slay->owner, ch->name ) && !str_cmp( type, slay->type ) ) )
slay.c:   switch ( ch->substate )
slay.c:         slay = ( SLAY_DATA * ) ch->dest_buf;
slay.c:         ch->substate = ch->tempnum;
slay.c:         slay = ( SLAY_DATA * ) ch->dest_buf;
slay.c:         ch->substate = ch->tempnum;
slay.c:         slay = ( SLAY_DATA * ) ch->dest_buf;
slay.c:         ch->substate = ch->tempnum;
slay.c:      if( ch->substate == SUB_REPEATCMD )
slay.c:         ch->tempnum = SUB_REPEATCMD;
slay.c:         ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYCMSG;
slay.c:      ch->dest_buf = slay;
slay.c:      if( ch->substate == SUB_REPEATCMD )
slay.c:         ch->tempnum = SUB_REPEATCMD;
slay.c:         ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYVMSG;
slay.c:      ch->dest_buf = slay;
slay.c:      if( ch->substate == SUB_REPEATCMD )
slay.c:         ch->tempnum = SUB_REPEATCMD;
slay.c:         ch->tempnum = SUB_NONE;
slay.c:      ch->substate = SUB_SLAYRMSG;
slay.c:      ch->dest_buf = slay;
special.c:   if( ch->position <= POS_SLEEPING )
special.c:   if( ch->fighting || ch->fearing || !ch->hating || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   if( ch->hunting )
special.c:   one_argument( ch->hating->name, name );
special.c:      if( !str_cmp( ch->hating->name, victim->name ) )
special.c:   if( ch->in_room == victim->in_room )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      bug( "dragon spec: %s's %s not a spell", ch->name, sname );
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE 
special.c:       && ch->position != POS_AGGRESSIVE 
special.c:       && ch->position != POS_BERSERK )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:         spell_smaug( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "bless" ), ch->level, ch, victim );
special.c:         spell_cure_blindness( skill_lookup( "cure blindness" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure light" ), ch->level, ch, victim );
special.c:         spell_cure_poison( skill_lookup( "cure poison" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "refresh" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, victim );
special.c:         spell_remove_curse( skill_lookup( "remove curse" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "restore mana" ), ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   for( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:         obj_to_room( obj, ch->in_room );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( victim && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:   if( ch->fighting )
special.c:   if( !move || ch->position < POS_SLEEPING )
special.c:         move_char( ch, get_exit( ch->in_room, path[pos] - '0' ), 0 );
special.c:         ch->position = POS_STANDING;
special.c:         ch->position = POS_SLEEPING;
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   if( ( victim = who_fighting( ch ) ) == NULL || number_percent(  ) > 2 * ch->level )
special.c:   spell_poison( gsn_poison, ch->level, ch, victim );
special.c:   if( ch->position != POS_STANDING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( IS_AWAKE( victim ) && number_range( 0, ch->level ) == 0 )
special.c:         maxgold = ch->level * ch->level * 1000;
special.c:            gold = victim->gold * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:            ch->gold += 9 * gold / 10;
special.c:            silver = victim->silver * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:            ch->silver += 9 * silver / 10;
special.c:            copper = victim->copper * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:            ch->copper += 9 * copper / 10;
special.c:                  gold = victim->gold * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:                  ch->gold += 9 * gold / 10;
special.c:                  silver = victim->silver * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:                  ch->silver += 9 * silver / 10;
special.c:                  copper = victim->copper * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:                  ch->copper += 9 * copper / 10;
special.c:         money = get_value( ch->gold, ch->silver, ch->copper );
special.c:            boost_economy( ch->in_room->area, money - maxgold / 2 );
starmap.c:   precip = ( ch->in_room->area->weather->precip + 3 * weath_unit - 1 ) / weath_unit;
stat_obj.c:   if( !ch->desc )
suicide.c:   if( strcmp( crypt( arg, ch->pcdata->pwd ), ch->pcdata->pwd ) )
suicide.c:      sprintf( lockerpath, "%s%s", LOCKER_DIR, capitalize( ch->name ) );
suicide.c:      do_destroy( ch, ch->name );
suicide.c:      sprintf( buf, "%s has committed suicide.", ch->name );
track.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] <= 0 )
track.c:   maxdist = 100 + ch->level * 30;
track.c:   dir = find_first_step( ch->in_room, vict->in_room, maxdist );
track.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:   if( !ch || !ch->hunting )
track.c:      if( ch->hunting->who == tmp )
track.c:   if( ch->in_room == ch->hunting->who->in_room )
track.c:      if( ch->fighting )
track.c:      found_prey( ch, ch->hunting->who );
track.c:   ret = find_first_step( ch->in_room, ch->hunting->who->in_room, 500 + ch->level * 25 );
track.c:      if( ( pexit = get_exit( ch->in_room, ret ) ) == NULL )
track.c:      if( !ch->hunting )
track.c:         if( !ch->in_room )
track.c:            bug( "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.", ch->pIndexData->vnum, ch->name );
track.c:      if( ch->in_room == ch->hunting->who->in_room )
track.c:         found_prey( ch, ch->hunting->who );
track.c:         if( ( vch = scan_for_victim( ch, pexit, ch->hunting->name ) ) != NULL )
track.c:            if( !mob_fire( ch, ch->hunting->who->name ) )
track.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] <= 0 )
track.c:   maxdist = 100 + ch->level * 30;
track.c:          && ( find_first_step( ch->in_room, target->in_room, maxdist ) != BFS_NO_PATH ) )
track.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_hunt] <= 0 )
track.c:   maxdist = 100 + ch->level * 30;
track.c:   dir = find_first_step( ch->in_room, vict->in_room, maxdist );
track.c:         if( !ch->fighting )
track.c:               move_char( ch, get_exit( ch->in_room, DIR_NORTH ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_EAST ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_WEST ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_UP ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_DOWN ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), FALSE );
track.c:               move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), FALSE );
trivia.c:      sprintf( buf, "%s has stopped the trivia", ch->name );
trivia.c:   sprintf( buf, "%s has started trivia, with %d rounds and a topic of %s", ch->name, maxquestions,
update.c:   if( ch->level2 == -1 && ch->level3 == -1 )
update.c:      sprintf( buf, "the %s", title_table[ch->class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:      if( !IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS ) )
update.c:   add_hp = con_app[get_curr_con( ch )].hitp + number_range( class_table[ch->class]->hp_min,
update.c:                                                             class_table[ch->class]->hp_max );
update.c:   add_mana = class_table[ch->class]->fMana ? number_range( 2, ( 2 * ( get_curr_int( ch ) + get_curr_wis( ch ) ) ) / 8 ) : 0;
update.c:   if( ch->level2 != -1 )
update.c:   if( ch->level3 != -1 )
update.c:   add_hp += race_table[ch->race]->hit;
update.c:   add_mana += race_table[ch->race]->mana;
update.c:   ch->max_hit += add_hp;
update.c:   ch->max_mana += add_mana;
update.c:   ch->max_move += add_move;
update.c:   ch->practice += add_prac;
update.c:   ch->hit = ch->max_hit;
update.c:      xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:   if( ch->level == LEVEL_PCAVATAR )
update.c:      sprintf( buf, "%s has just become an Avatar!", ch->name );
update.c:   if( ch->level == LEVEL_AVATAR )
update.c:      sprintf( buf, "%s has just become a Demi-God!", ch->name );
update.c:   if( ch->level < LEVEL_IMMORTAL && level == TRUE )
update.c:                  add_hp, ch->max_hit, 1, ch->level + 10, add_move, ch->max_move, add_prac, ch->practice );
update.c:                  add_hp, ch->max_hit, add_mana, ch->max_mana, add_move, ch->max_move, add_prac, ch->practice );
update.c:   if( IS_NPC( ch ) || ch->level >= LEVEL_AVATAR )
update.c:   if( modgain > 0 /*&& IS_PKILL(ch) */  && ch->level < 33 )
update.c:      if( ch->level <= 9 )
update.c:      if( ch->level <= 18 && ch->level >= 10 )
update.c:      if( ch->level <= 27 && ch->level >= 19 )
update.c:      if( ch->level <= 28 && ch->level >= 36 )
update.c:   modgain *= ( race_table[ch->race]->exp_multiplier / 100.0 );
update.c:   modgain = UMIN( modgain, exp_level( ch, ch->level + 2 ) - exp_level( ch, ch->level + 1 ) );
update.c:   ch->exp = UMAX( 0, ch->exp + modgain );
update.c:   if( NOT_AUTHED( ch ) && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch->exp = ( exp_level( ch, ( ch->level + 1 ) ) - 1 );
update.c:   while( ch->level < LEVEL_AVATAR && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch_printf( ch, "You have now obtained experience level %d!\r\n", ++ch->level );
update.c:      if( !IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS ) )
update.c:         sprintf( buf, "%s has achieved level %d!", ch->name, ch->level );
update.c:      gain = ch->level * 3 / 2;
update.c:      gain = UMIN( 5, ( ( ch->level + get_curr_con( ch ) ) / 8 ) );
update.c:      switch ( ch->position )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_hit - ch->hit );
update.c:      gain = ch->level;
update.c:      gain = UMIN( 5, ( ( ch->level + get_curr_int( ch ) ) / 8 ) );
update.c:      if( ch->position < POS_SLEEPING )
update.c:      switch ( ch->position )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_mana - ch->mana );
update.c:      gain = ch->level;
update.c:      gain = UMAX( 15, ( ( 2 * ch->level + get_curr_dex( ch ) ) / 8 ) );
update.c:      switch ( ch->position )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:            if( ch->on )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_move - ch->move );
update.c:   if( value == 0 || IS_NPC( ch ) || ch->level >= LEVEL_IMMORTAL || NOT_AUTHED( ch ) )
update.c:   if( ( ch->desc )
update.c:       && ( ( ch->desc->connected == CON_PLAYING ) && ( ch->desc->idle > 1200 && !xIS_SET( ch->act, PLR_AFK ) ) ) )
update.c:   condition = ch->pcdata->condition[iCond];
update.c:         ch->pcdata->condition[iCond] = 40;
update.c:         ch->pcdata->condition[iCond] = ( 10 + ch->level );
update.c:         ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 100 );
update.c:   if( race_table[ch->race]->hunger_mod == -1 && iCond == COND_FULL )
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, ( 10 + ch->level ) );
update.c:	ch->pcdata->condition[iCond]	= 40;
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 48 );
update.c:   if( ch->pcdata->condition[iCond] == 0 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:                  bug( "gain_condition: bloodthirst update for non blood ch: %s", ch->name );
update.c:                  retcode = damage( ch, ch, ch->max_hit / 20, TYPE_UNDEFINED );
update.c:   if( ch->pcdata->condition[iCond] == 1 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 2 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 3 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:      if( ( !ch->pcdata ) && !( xIS_SET( ch->act, ACT_IS_NPC ) ) )
update.c:         bug( "Mob %d in room %d was not set with the NPC flag!  Fixing...", ch->pIndexData->vnum, ch->in_room->vnum );
update.c:         xSET_BIT( ch->act, ACT_IS_NPC );
update.c:      if( ch == first_char && ch->prev )
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:         sprintf( buf, "FATAL: Mobile_update: %s->prev->next doesn't point to ch.", ch->name );
update.c:         ch->prev = NULL;
update.c:      if( !ch->in_room || IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_PARALYSIS ) )
update.c:      if( ch->pIndexData->vnum == 5 && !IS_AFFECTED( ch, AFF_CHARM ) )
update.c:         if( ch->in_room->first_person )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && !xIS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:          * sprintf( buf, "%s hunting %s from %s.", ch->name,
update.c:          * ch->hunting->name,
update.c:          * ch->in_room->name );
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && ch->spec_fun )
update.c:         if( ( *ch->spec_fun ) ( ch ) )
update.c:      if( HAS_PROG( ch->pIndexData, SCRIPT_PROG ) )
update.c:      if( ch->position != POS_STANDING )
update.c:      if( xIS_SET( ch->act, ACT_MOUNTED ) )
update.c:         if( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:      if( IS_SET( ch->in_room->room_flags, ROOM_SAFE )
update.c:          && ( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) ) )
update.c:      if( !ch->in_room->area )
update.c:         bug( "Room %d for mob %s is not associated with an area?", ch->in_room->vnum, ch->name );
update.c:         if( ch->was_in_room )
update.c:            bug( "Was in room %d", ch->was_in_room->vnum );
update.c:      if( ch->in_room->area->nplayer > 0 )
update.c:         if( ch->position < POS_STANDING )
update.c:      if( ch->position < POS_STANDING )
update.c:					if ((obj->cost > big_obj->cost) && (ch->gold >= big_obj->cost)) 
update.c:					if (big_obj == ch->last_carrying)
update.c:				for (obj=ch->last_carrying; obj; obj=obj->next_content)
update.c:      if( ch->in_room->first_content && number_bits( 2 ) == 0 )
update.c:         if( !xIS_SET( ch->act, ACT_SCAVENGER ) && number_percent(  ) < 70 )
update.c:            for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:                   || ( ch->in_room->area->weather->precip > 10 ) )
update.c:               if( ch->in_room->area->weather->precip > 10 )
update.c:       * * if (ch->last_carrying && find_keeper(ch)!=ch)
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && !xIS_SET( ch->act, ACT_SENTINEL ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) && ( door = number_bits( 5 ) ) <= 11  /* Was 9, 11 is secret+closed */
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL && pexit->to_room
update.c:          && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:         if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:      if( ch->hit < ch->max_hit / 2
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:         for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
update.c:                     sprintf( buf, "yell Get away from me, %s!", rch->name );
update.c:                     sprintf( buf, "yell Leave me be, %s!", rch->name );
update.c:                     sprintf( buf, "yell %s is trying to kill me!  Help!", rch->name );
update.c:                     sprintf( buf, "yell Someone save me from %s!", rch->name );
update.c:      if( ch == first_char && ch->prev )
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:         bug( "char_gains: ch->prev->next != ch", 0 );
update.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_BLEEDING] == 0 )
update.c:         if( ch->position >= POS_STUNNED )
update.c:            if( ch->hit < ch->max_hit )
update.c:               ch->hit += hit_gain( ch );
update.c:            if( ch->mana < ch->max_mana )
update.c:               ch->mana += mana_gain( ch );
update.c:            if( ch->move < ch->max_move )
update.c:               ch->move += move_gain( ch );
update.c:         if( ch->position >= POS_STUNNED )
update.c:            if( ch->hit < ch->max_hit )
update.c:               ch->hit += hit_gain( ch );
update.c:            if( ch->mana < ch->max_mana )
update.c:               ch->mana += mana_gain( ch );
update.c:            if( ch->move < ch->max_move )
update.c:               ch->move += move_gain( ch );
update.c:      if( ch == first_char && ch->prev )
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:         bug( "char_gains: ch->prev->next != ch", 0 );
update.c:      gain_condition( ch, COND_FULL, -1 + race_table[ch->race]->hunger_mod );
update.c:      if( ch == first_char && ch->prev )
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:         bug( "char_update: ch->prev->next != ch", 0 );
update.c:          && ( !ch->desc || ch->desc->connected == CON_PLAYING )
update.c:          && ch->level >= 2 && current_time - ch->save_time > ( sysdata.save_frequency * 60 ) )
update.c:	if ( ch->position >= POS_STUNNED )
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:      if( ch->position == POS_STUNNED )
update.c:      if( ch->morph )
update.c:         if( ch->morph->timer > 0 )
update.c:            ch->morph->timer--;
update.c:            if( ch->morph->timer == 0 )
update.c:      if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:         if( ch->pcdata->nuisance->flags < MAX_NUISANCE_STAGE )
update.c:            temp = ch->pcdata->nuisance->max_time - ch->pcdata->nuisance->time;
update.c:            temp *= ch->pcdata->nuisance->flags;
update.c:            temp += ch->pcdata->nuisance->time;
update.c:               ch->pcdata->nuisance->flags++;
update.c:      if( !IS_NPC( ch ) && ch->level < LEVEL_IMMORTAL )
update.c:            if( --obj->value[2] == 0 && ch->in_room )
update.c:               ch->in_room->light -= obj->count;
update.c:               if( ch->in_room->light < 0 )
update.c:                  ch->in_room->light = 0;
update.c:         if( ++ch->timer >= 12 )
update.c:            if( ch->timer == 12 && ch->in_room )
update.c:                * ch->was_in_room = ch->in_room;
update.c:               if( ch->fighting )
update.c:         if( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:            worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK] / 8 );
update.c:         if( ch->pcdata->condition[COND_FULL] > 1 )
update.c:            switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:            switch ( ch->position )
update.c:          * gain_condition( ch, COND_FULL,  -1 + race_table[ch->race]->hunger_mod );
update.c:         if( IS_VAMPIRE( ch ) && ch->level >= 10 )
update.c:         if( CAN_PKILL( ch ) && ch->pcdata->condition[COND_THIRST] - 9 > 10 )
update.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:            value = ( ( 0 - ch->pcdata->nuisance->flags ) * ch->pcdata->nuisance->power );
update.c:         if( ch->in_room )
update.c:            switch ( ch->in_room->sector_type )
update.c:                  gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:                  gain_condition( ch, COND_THIRST, -3 + race_table[ch->race]->thirst_mod );
update.c:                     gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:      if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date <= current_time )
update.c:         if( ch->pcdata->clan )
update.c:            location = get_room_index( ch->pcdata->clan->recall );
update.c:            location = ch->in_room;
update.c:         STRFREE( ch->pcdata->helled_by );
update.c:         ch->pcdata->release_date = 0;
update.c:            ch->mental_state = URANGE( 20, ch->mental_state + ( IS_NPC( ch ) ? 2 : IS_PKILL( ch ) ? 3 : 4 ), 100 );
update.c:            if( ch->pcdata->condition[COND_BLEEDING] > 0 )
update.c:               switch ( ch->pcdata->condition[COND_BLEEDING] )
update.c:                  if( ch->pcdata->condition[COND_BLEEDING] != 1
update.c:                      && ( ch->position == POS_SITTING || ch->position == POS_SLEEPING || 
update.c:                           ch->position == POS_RESTING || ch->position == POS_RECOVER) )
update.c:                     if( ch->pcdata->condition[COND_BLEEDING] == 0 )
update.c:                     if( ch->pcdata->condition[COND_BLEEDING] == 0 )
update.c:               worsen_mental_state( ch, ch->pcdata->condition[COND_BLEEDING] );
update.c:               if( ch->pcdata->condition[COND_BLEEDING] == 0 )
update.c:                  damage( ch, ch, ( ch->max_hit * 1 / 150 ), TYPE_UNDEFINED );
update.c:                  damage( ch, ch, ( ch->pcdata->condition[COND_BLEEDING] * ( ch->max_hit * 1 / 150 ) ), TYPE_UNDEFINED );
update.c:         else if( ch->position == POS_INCAP )
update.c:         else if( ch->position == POS_MORTAL )
update.c:            for( paf = ch->first_affect; paf; paf = paf_next )
update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
update.c:               xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
update.c:            if( ch->alignment < race_table[ch->race]->minalign )
update.c:            if( ch->alignment > race_table[ch->race]->maxalign )
update.c:         if( ch->mental_state >= 30 )
update.c:            switch ( ( ch->mental_state + 5 ) / 10 )
update.c:         if( ch->mental_state <= -30 )
update.c:            switch ( ( abs( ch->mental_state ) + 5 ) / 10 )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && number_percent(  ) + 10 < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && ( number_percent(  ) + 20 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ch->position < POS_SITTING && ( number_percent(  ) + 30 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:         if( ch->timer > 24 )
update.c:      ch_next = ch->next;
update.c:         if( xIS_SET( ch->act, ACT_RUNNING ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:            if( ch->spec_fun )
update.c:               if( ( *ch->spec_fun ) ( ch ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL )
update.c:                && !xIS_SET( ch->act, ACT_PROTOTYPE )
update.c:                && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:                && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:               if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:         if( ch->mount && ch->in_room != ch->mount->in_room )
update.c:            xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:            ch->mount = NULL;
update.c:            ch->position = POS_STANDING;
update.c:         if( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:             || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:               if( ch->level < LEVEL_IMMORTAL )
update.c:                  dam = number_range( ch->max_hit / 100, ch->max_hit / 50 );
update.c:         if( ch->in_room
update.c:             && ( ( ch->in_room->sector_type == SECT_WATER_NOSWIM ) || ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:                && !IS_AFFECTED( ch, AFF_FLOATING ) && !IS_AFFECTED( ch, AFF_AQUA_BREATH ) && !ch->mount )
update.c:               for( obj = ch->first_carrying; obj; obj = obj->next_content )
update.c:                  if( ch->level < LEVEL_IMMORTAL )
update.c:                     if( ch->move > 0 )
update.c:                        mov = number_range( ch->max_move / 20, ch->max_move / 5 );
update.c:                        if( ch->move - mov < 0 )
update.c:                           ch->move = 0;
update.c:                           ch->move -= mov;
update.c:                        dam = number_range( ch->max_hit / 20, ch->max_hit / 5 );
update.c:         if( !ch->desc )
update.c:            for( wch = ch->in_room->first_person; wch; wch = wch_next )
update.c:               wch_next = wch->next_in_room;
update.c:                   || wch->fighting
update.c:                   || !IS_AWAKE( wch ) || ( xIS_SET( wch->act, ACT_WIMPY ) && IS_AWAKE( ch ) ) || !can_see( wch, ch ) )
update.c:               if( ( !xIS_SET( wch->act, ACT_AGGRESSIVE )
update.c:                     && !xIS_SET( wch->act, ACT_META_AGGR ) )
update.c:                   || xIS_SET( wch->act, ACT_MOUNTED ) || IS_SET( wch->in_room->room_flags, ROOM_SAFE ) )
update.c:   if( IS_NPC( wch ) && wch->mpactnum > 0 && wch->in_room->area->nplayer > 0 )
update.c:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp_act->next )
update.c:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp2_act )
update.c:      wch->mpactnum = 0;
update.c:      wch->mpact = NULL;
update.c:      if( !char_died( wch ) && wch->mpactnum > 0 )
update.c:         while( ( tmp_act = wch->mpact ) != NULL )
update.c:            wch->mpact = tmp_act->next;
update.c:         wch->mpactnum = 0;
update.c:         wch->mpact = NULL;
update.c:      if( char_died( wch ) || IS_NPC( wch ) || wch->level >= LEVEL_IMMORTAL || !wch->in_room )
update.c:      for( ch = wch->in_room->first_person; ch; ch = ch_next )
update.c:         ch_next = ch->next_in_room;
update.c:             || ch->fighting
update.c:             || !IS_AWAKE( ch ) || ( xIS_SET( ch->act, ACT_WIMPY ) && IS_AWAKE( wch ) ) || !can_see( ch, wch ) )
update.c:         if( ( !xIS_SET( ch->act, ACT_AGGRESSIVE )
update.c:               && !xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:             || xIS_SET( ch->act, ACT_MOUNTED ) || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
update.c:         for( vch = wch->in_room->first_person; vch; vch = vch_next )
update.c:            vch_next = vch->next_in_room;
update.c:            if( ( !IS_NPC( vch ) || xIS_SET( ch->act, ACT_META_AGGR )
update.c:                  || xIS_SET( vch->act, ACT_ANNOYING ) )
update.c:                && vch->level < LEVEL_IMMORTAL
update.c:                && ( !xIS_SET( ch->act, ACT_WIMPY ) || !IS_AWAKE( vch ) ) && can_see( ch, vch ) )
update.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_BACKSTAB ) )
update.c:            if( !ch->mount
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->level )
update.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:   drunk = ch->pcdata->condition[COND_DRUNK];
update.c:   position = ch->position;
update.c:   ch->position = POS_STANDING;
update.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:      check_social( ch, "puke", ( rvch ? rvch->name : "" ) );
update.c:   ch->position = position;
update.c:   if( ch->mental_state >= 30 && number_bits( 5 - ( ch->mental_state >= 50 ) - ( ch->mental_state >= 75 ) ) == 0 )
update.c:      switch ( number_range( 1, UMIN( 21, ( ch->mental_state + 5 ) / 5 ) ) )
update.c:      for( vch = first_char; vch; vch = vch->next )
websvr.c:   if( change_web_pass( ch->name, buf ) )
