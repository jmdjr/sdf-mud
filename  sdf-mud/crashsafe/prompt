act_comm.c:    ROOM_INDEX_DATA *room = ch->in_room;
act_comm.c:  if ( IS_NPC( ch ) || !ch->pcdata ) return (char *) argument;
act_comm.c:  drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:    if ( IS_SET( och->deaf, channel ) )
act_comm.c:      && !( och->pcdata->council &&
act_comm.c:      !str_cmp( och->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:    &&   vch->in_room->area != ch->in_room->area )
act_comm.c:       	if ( vch->pcdata->clan != ch->pcdata->clan )
act_comm.c:       	if (vch->pcdata->guild != ch->pcdata->guild )
act_comm.c:        if ( vch->pcdata->council != ch->pcdata->council )
act_comm.c:    if ( !IS_NPC(ch) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:	position = ch->position;
act_comm.c:	ch->position = POS_STANDING;
act_comm.c:	ch->position = position;
act_comm.c:	position = ch->position;
act_comm.c:	ch->position = POS_STANDING;
act_comm.c:	ch->position = position;
act_comm.c:	position = ch->position;
act_comm.c:	ch->position = POS_STANDING;
act_comm.c:	ch->position = position;
act_comm.c:        if ( ch->speaking & lang_array[lang] )
act_comm.c:		 ||   ((IS_AFFECTED(ch, AFF_CHARM)) && (!xIS_SET(ch->act, ACT_PET)))
act_comm.c:   	     ||   ((xIS_SET(ch->act, PLR_SILENCE)) && (!IS_NPC(ch))) 
act_comm.c:         ||   (IS_SET(ch->in_room->room_flags, ROOM_SILENCE)) 
act_comm.c:        if ( ch->master ) 
act_comm.c:            ch_printf( ch->master, "A mystical force prevents %s from speaking.\n\r", IS_NPC( ch ) ? 
act_comm.c:                ch->short_descr : capitalize( ch->name ) );
act_comm.c:    REMOVE_BIT( ch->deaf, channel );
act_comm.c:        sprintf( emotetxt, "%s %s", capitalize( ch->name ), argument+1 );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:        sprintf( buf2, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : capitalize( ch->name ),
act_comm.c:                        IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:        if ( d->connected == CON_PLAYING && vch != ch && !IS_SET( och->deaf, channel ) )
act_comm.c:            ||   ( channel == CHANNEL_YELL && vch->in_room->area != ch->in_room->area )
act_comm.c:            &&     !( och->pcdata->council && !str_cmp( och->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:            &&     ( IS_NPC( vch ) || vch->pcdata->clan != ch->pcdata->clan ) )
act_comm.c:            ||   ( ( channel == CHANNEL_RACETALK ) && ( vch->race != ch->race ) )
act_comm.c:            ||     vch->pcdata->council != ch->pcdata->council ) ) 
act_comm.c:            if ( xIS_SET(ch->act, PLR_WIZINVIS) &&
act_comm.c:                sprintf(lbuf, "(%d) ", (!IS_NPC(ch))?ch->pcdata->wizinvis
act_comm.c:                        :ch->mobinvis);
act_comm.c:            position            = vch->position;
act_comm.c:                vch->position   = POS_STANDING;
act_comm.c:            if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:                int speakswell = UMIN(knows_language(vch, ch->speaking, ch),
act_comm.c:                                      knows_language(ch, ch->speaking, vch));
act_comm.c:            if ( !knows_language(vch, ch->speaking, ch)
act_comm.c:            &&  (!IS_NPC(ch) || ch->speaking != 0) )
act_comm.c:                sbuf = scramble(argument, ch->speaking);
act_comm.c:            if ( !IS_NPC(ch) && ch->pcdata->nuisance
act_comm.c:            &&   ch->pcdata->nuisance->flags > 7
act_comm.c:            &&  (number_percent()<((ch->pcdata->nuisance->flags-7)*10*
act_comm.c:                ch->pcdata->nuisance->power)))
act_comm.c:            if ( !IS_NPC(vch) && vch->pcdata->nuisance &&
act_comm.c:                vch->pcdata->nuisance->flags > 7
act_comm.c:                 &&(number_percent()<((vch->pcdata->nuisance->flags-7)*10*
act_comm.c:                 vch->pcdata->nuisance->power)))
act_comm.c:            vch->position = position;
act_comm.c:	&&  !IS_SET(och->deaf, channel)
act_comm.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan 
act_comm.c:    ||   ch->pcdata->clan->clan_type == CLAN_ORDER
act_comm.c:    ||   ch->pcdata->clan->clan_type == CLAN_GUILD )
act_comm.c:       && !( ch->pcdata->council && 
act_comm.c:          !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan 
act_comm.c:         || ch->pcdata->clan->clan_type != CLAN_ORDER )
act_comm.c:    if ( IS_NPC( ch ) || !ch->pcdata->council )
act_comm.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan || ch->pcdata->clan->clan_type != CLAN_GUILD )
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    actflags = ch->act;
act_comm.c:	xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:    for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:				" are unable to do so.\n\r", ch->name);
act_comm.c:	if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:	    int speakswell = UMIN(knows_language(vch, ch->speaking, ch),
act_comm.c:				      knows_language(ch, ch->speaking, vch));
act_comm.c:	if ( !knows_language(vch, ch->speaking, ch)
act_comm.c:		&&  (!IS_NPC(ch) || ch->speaking != 0) )
act_comm.c:		sbuf = scramble(argument, ch->speaking);
act_comm.c:    ch->act = actflags;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:	sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( ch->in_room && IS_SET( ch->in_room->room_flags, ROOM_AMPLIFY ) )
act_comm.c:	actflags = ch->act;
act_comm.c:	xREMOVE_BIT(ch->act, ACT_SECRETIVE);
act_comm.c:	was_in_room = ch->in_room;
act_comm.c:			ch->in_room = pexit->to_room;
act_comm.c:	ch->act = actflags;
act_comm.c:	ch->in_room = was_in_room;
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:    REMOVE_BIT( ch->deaf, CHANNEL_WHISPER );
act_comm.c:			"are unable to do so.\n\r", ch->name);
act_comm.c:    if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:	int speakswell = UMIN(knows_language(victim, ch->speaking, ch),
act_comm.c:			      knows_language(ch, ch->speaking, victim));
act_comm.c:    if ( !knows_language(vch, ch->speaking, ch ) &&
act_comm.c:		( !IS_NPC(ch) || ch->speaking != 0) ) {
act_comm.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:	        ch_printf(victim, "&W^z%s beeps you from '%s'^x&w\a\n\r", PERS(ch, victim), ch->in_room->name);
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:		REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    && ( xIS_SET(ch->act, PLR_SILENCE)
act_comm.c:    ||   xIS_SET(ch->act, PLR_NO_TELL) ) )
act_comm.c:       || ( IS_NPC(victim) && victim->in_room != ch->in_room ) 
act_comm.c:			"are unable to do so.\n\r", ch->name);
act_comm.c:    ch->retell = victim;
act_comm.c:    	isalpha(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0]))
act_comm.c:		capitalize(IS_NPC(ch) ? ch->short_descr : ch->name),
act_comm.c:		tolower(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0]) - 'a';
act_comm.c:    if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:	int speakswell = UMIN(knows_language(victim, ch->speaking, ch),
act_comm.c:			      knows_language(ch, ch->speaking, victim));
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:	    REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_SILENCE) )
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    			"are unable to do so.\n\r", ch->name);
act_comm.c:    if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:	int speakswell = UMIN(knows_language(victim, ch->speaking, ch),
act_comm.c:			      knows_language(ch, ch->speaking, victim));
act_comm.c:    if ( knows_language( victim, ch->speaking, ch ) ||
act_comm.c:    	 (IS_NPC(ch) && !ch->speaking) )
act_comm.c:		act( AT_TELL, "$n tells you '$t'", ch, scramble(argument, ch->speaking), victim, TO_VICT );
act_comm.c:    ch->retell		= victim;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:		 IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    	isalpha(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0]))
act_comm.c:    		capitalize(IS_NPC(ch) ? ch->short_descr : ch->name),
act_comm.c:    		tolower(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0]) - 'a';
act_comm.c:	    if ( ch->speaking & lang_array[lang] )
act_comm.c:			REMOVE_BIT(ch->deaf, CHANNEL_TELLS);
act_comm.c:	if(IS_SET(ch->in_room->room_flags, ROOM_SILENCE))
act_comm.c:	if ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_SILENCE)
act_comm.c:	||   xIS_SET(ch->act, PLR_NO_TELL)) )
act_comm.c:	victim = ch->retell;
act_comm.c:				"are unable to do so.\n\r", ch->name);
act_comm.c:		isalpha(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0]))
act_comm.c:			capitalize(IS_NPC(ch) ? ch->short_descr : ch->name),
act_comm.c:			tolower(IS_NPC(ch) ? ch->short_descr[0] : ch->name[0])
act_comm.c:	if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:	    int speakswell = UMIN(knows_language(victim, ch->speaking, ch),
act_comm.c:			      knows_language(ch, ch->speaking, victim));
act_comm.c:	if(knows_language(victim, ch->speaking, ch) ||
act_comm.c:		(IS_NPC(ch) && !ch->speaking))
act_comm.c:			scramble(argument, ch->speaking), victim, TO_VICT);
act_comm.c:	if(IS_SET(ch->in_room->room_flags, ROOM_LOGSPEECH))
act_comm.c:			IS_NPC(ch) ? ch->short_descr : ch->name,
act_comm.c:	if(IS_NPC(ch) || !IS_IMMORTAL(ch) || !ch->pcdata->tell_history)
act_comm.c:		index = ch->pcdata->lt_index;
act_comm.c:	if(ch->pcdata->tell_history[index])
act_comm.c:		ch_printf(ch, ch->pcdata->tell_history[index]);
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_NO_EMOTE) )
act_comm.c:    actflags = ch->act;
act_comm.c:	xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:					" are unable to do so.\n\r", ch->name);
act_comm.c:		if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:		    int speakswell = UMIN(knows_language(vch, ch->speaking, ch),
act_comm.c:					  knows_language(ch, ch->speaking, vch));
act_comm.c:		if ( !knows_language( vch, ch->speaking, ch ) &&
act_comm.c:			 (!IS_NPC(ch) && ch->speaking != 0) )
act_comm.c:			sbuf = scramble(buf, ch->speaking);
act_comm.c:    ch->act = actflags;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:	sprintf( buf, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name,
act_comm.c:    if ( ch->position == POS_FIGHTING
act_comm.c:       || ch->position ==  POS_EVASIVE
act_comm.c:       || ch->position ==  POS_DEFENSIVE
act_comm.c:       || ch->position ==  POS_AGGRESSIVE
act_comm.c:       || ch->position ==  POS_BERSERK
act_comm.c:    if ( ch->position  < POS_STUNNED  )
act_comm.c:    if ( IS_PKILL( ch ) && ch->wimpy > (int) ch->max_hit / 2.25 )
act_comm.c:	drop_artifacts(ch, ch->last_carrying);
act_comm.c:    if ( ch->position == POS_MOUNTED )
act_comm.c:    sprintf( log_buf, "%s has quit (Room %d).", ch->name, 
act_comm.c:	( ch->in_room ? ch->in_room->vnum : -1 ) );
act_comm.c:    if ( sysdata.save_pets && ch->pcdata->pet )
act_comm.c:		ch->pcdata->pet, TO_ROOM );
act_comm.c:       extract_char( ch->pcdata->pet, TRUE );
act_comm.c:    if ( ch->pcdata->clan )
act_comm.c:        save_clan( ch->pcdata->clan );     
act_comm.c:    if ( ch->level >= 1 )
act_comm.c:	for ( vch = first_char; vch; vch = vch->next )
act_comm.c:	/* Expecting a ch->last_carrying or an obj->last_content
act_comm.c:			obj_to_room(tobj, ch->in_room);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:      write_to_buffer(ch->desc,BUFF,num);
act_comm.c:    sprintf(arg1,"%s: omenu %s",ch->name,argument);
act_comm.c:    ch->inter_type = OBJ_TYPE;
act_comm.c:    ch->inter_substate = SUB_NORTH;
act_comm.c:    if( ch->inter_editing != NULL) DISPOSE(ch->inter_editing);
act_comm.c:    ch->inter_editing      =  str_dup(obj->pIndexData->name);
act_comm.c:    sscanf(ch->inter_editing,"%s",ch->inter_editing);  /*one-arg*/
act_comm.c:    ch->inter_editing_vnum =  obj->pIndexData->vnum;
act_comm.c:    sprintf(arg1,"%s: rmenu %s",ch->name,argument);
act_comm.c:    idx = ch->in_room;
act_comm.c:    ch->inter_type = ROOM_TYPE;
act_comm.c:    ch->inter_substate = SUB_NORTH;
act_comm.c:    if( ch->inter_editing != NULL) DISPOSE(ch->inter_editing);
act_comm.c:    ch->inter_editing      =  str_dup(idx->name);  
act_comm.c:    sscanf(ch->inter_editing,"%s",ch->inter_editing);  /*one-arg*/
act_comm.c:    ch->inter_editing_vnum =  idx->vnum;
act_comm.c:    sprintf(arg1,"%s: cmenu %s",ch->name,argument);
act_comm.c:    ch->inter_type = CONTROL_TYPE;
act_comm.c:    if( ch->inter_editing != NULL) DISPOSE(ch->inter_editing);
act_comm.c:    ch->inter_editing      =  str_dup("Control Panel");  
act_comm.c:    sscanf(ch->inter_editing,"%s",ch->inter_editing);  /*one-arg*/
act_comm.c:    sprintf(arg1,"%s: mmenu %s",ch->name,argument);
act_comm.c:    ch->inter_type = MOB_TYPE;
act_comm.c:    if( ch->inter_editing != NULL) DISPOSE(ch->inter_editing);
act_comm.c:    ch->inter_editing      =  str_dup(arg1);
act_comm.c:    sscanf(ch->inter_editing,"%s",ch->inter_editing);  /*one-arg*/
act_comm.c:    ch->inter_editing_vnum =  victim->pIndexData->vnum;
act_comm.c:	xSET_BIT(ch->act,PLR_RIP);
act_comm.c:	xSET_BIT(ch->act,PLR_ANSI);
act_comm.c:	xREMOVE_BIT(ch->act,PLR_RIP);
act_comm.c:	xSET_BIT(ch->act,PLR_ANSI);
act_comm.c:	xREMOVE_BIT(ch->act,PLR_ANSI);
act_comm.c:    if ( ch->level < 2 ) {
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master )
act_comm.c:	act( AT_PLAIN, "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( !ch->master )
act_comm.c:    if ( ( ch->level - victim->level < -10 || ch->level - victim->level >  10 )
act_comm.c:    &&   !IS_HERO(ch) && !(ch->level < 15 && !IS_NPC(victim) 
act_comm.c:    if ( ch->master )
act_comm.c:    if ( ch->master )
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_PET) && !IS_NPC(master) )
act_comm.c:    if ( !ch->master )
act_comm.c:    if ( IS_NPC(ch) && !IS_NPC(ch->master) && ch->master->pcdata->pet == ch )
act_comm.c:	ch->master->pcdata->pet = NULL;
act_comm.c:	xREMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if ( can_see( ch->master, ch ) )
act_comm.c:	if (!(!IS_NPC(ch->master) && IS_IMMORTAL(ch) && !IS_IMMORTAL(ch->master)))
act_comm.c:	    act( AT_ACTION, "$n stops following you.",     ch, NULL, ch->master, TO_VICT  );
act_comm.c:    act( AT_ACTION, "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ( ch->master )
act_comm.c:    ch->leader = NULL;
act_comm.c:    for ( fch = first_char; fch; fch = fch->next )
act_comm.c:	if ( fch->master == ch )
act_comm.c:	if ( fch->leader == ch )
act_comm.c:	    fch->leader = fch;
act_comm.c:    for ( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:	och_next = och->next_in_room;
act_comm.c:	if ( IS_AFFECTED(och, AFF_CHARM) && och->master == ch 
act_comm.c:        sprintf( log_buf, "%s: order %s.", ch->name, argbuf );
act_comm.c:        log_string_plus( log_buf, LOG_NORMAL, ch->level );
act_comm.c:	leader = ch->leader ? ch->leader : ch;
act_comm.c:		ch->level < LEVEL_AVATAR ? " [to lvl]" : "" );
act_comm.c:	for ( gch = first_char; gch; gch = gch->next )
act_comm.c:		if (IS_AFFECTED(gch, AFF_POSSESS) || IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS)) /*reveal no information*/
act_comm.c:		    	gch->level,
act_comm.c:		    	IS_NPC(gch) ? "Mob" : class_table[gch->class]->who_name,
act_comm.c:              	    if      ( gch->alignment >  750 ) sprintf(buf, " A");
act_comm.c:                    else if ( gch->alignment >  350 ) sprintf(buf, "-A");
act_comm.c:                    else if ( gch->alignment >  150 ) sprintf(buf, "+N");
act_comm.c:                    else if ( gch->alignment > -150 ) sprintf(buf, " N");
act_comm.c:                    else if ( gch->alignment > -350 ) sprintf(buf, "-N");
act_comm.c:                    else if ( gch->alignment > -750 ) sprintf(buf, "+S");
act_comm.c:			gch->level,
act_comm.c:			IS_NPC(gch) ? "Mob" : class_table[gch->class]->who_name );
act_comm.c:                    if ( gch->hit < gch->max_hit/4 )
act_comm.c:                    else if ( gch->hit < gch->max_hit/2.5 )
act_comm.c:                    ch_printf( ch, "%5d", gch->hit );
act_comm.c:                    ch_printf( ch, "/%-5d ", gch->max_hit );
act_comm.c:		    if ( gch->class != CLASS_WARRIOR )
act_comm.c:			IS_VAMPIRE(gch) ? gch->pcdata->condition[COND_BLOODTHIRST] : gch->mana,
act_comm.c:                        IS_VAMPIRE(gch) ? 10 + gch->level : gch->max_mana );
act_comm.c:		    if ( gch->mental_state < -25 || gch->mental_state > 25 )
act_comm.c:                        gch->mental_state > 75  ? "+++" :
act_comm.c:                        gch->mental_state > 50  ? "=++" :
act_comm.c:                        gch->mental_state > 25  ? "==+" :
act_comm.c:                        gch->mental_state > -25 ? "===" :
act_comm.c:                        gch->mental_state > -50 ? "-==" :
act_comm.c:                        gch->mental_state > -75 ? "--=" :
act_comm.c:                        gch->move );
act_comm.c:		    ch_printf( ch, "%6s ", npc_race[gch->race]);
act_comm.c:		    if ( gch->level < LEVEL_AVATAR )
act_comm.c:			exp_level( gch, gch->level+1) - gch->exp );
act_comm.c:	if ( ch->leader || ch->master )
act_comm.c:	for ( gch = first_char; gch; gch = gch->next )
act_comm.c:		gch->leader = NULL;
act_comm.c:		gch->master = NULL;
act_comm.c:        for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:	   &&   rch->master == ch
act_comm.c:	   &&   !ch->master
act_comm.c:	   &&   !ch->leader
act_comm.c:/*    	   &&   abs( ch->level - rch->level ) < 8  Level restrict on groups is stupid -- Scion */
act_comm.c:		rch->leader = ch;
act_comm.c:    if ( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:    if ( ch->level - victim->level < -8
act_comm.c:    ||   ch->level - victim->level >  8 
act_comm.c:    if ( ch->gold < amount )
act_comm.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:    if ( xIS_SET(ch->act, PLR_AUTOGOLD) && members < 2 )
act_comm.c:    ch->gold -= amount;
act_comm.c:    ch->gold += share + extra;
act_comm.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:	    gch->gold += share;
act_comm.c:	if ( ch->speaking & lang_array[lang] )
act_comm.c:    if ( xIS_SET(ch->act, PLR_NO_TELL) )
act_comm.c:/*    sprintf( buf, "%s tells the group '%s'.\n\r", ch->name, argument );*/
act_comm.c:    for ( gch = first_char; gch; gch = gch->next )
act_comm.c:	    if ( speaking != -1 && (!IS_NPC(ch) || ch->speaking) )
act_comm.c:		int speakswell = UMIN(knows_language(gch, ch->speaking, ch),
act_comm.c:				      knows_language(ch, ch->speaking, gch));
act_comm.c:		    ch_printf( gch, "%s tells the group '%s'.\n\r", ch->name, translate(speakswell, argument, lang_names[speaking]) );
act_comm.c:		    ch_printf( gch, "%s tells the group '%s'.\n\r", ch->name, argument );
act_comm.c:		ch_printf( gch, "%s tells the group '%s'.\n\r", ch->name, argument );
act_comm.c:	    if ( knows_language( gch, ch->speaking, gch )
act_comm.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
act_comm.c:		ch_printf( gch, "%s tells the group '%s'.\n\r", ch->name, argument );
act_comm.c:		ch_printf( gch, "%s tells the group '%s'.\n\r", ch->name, scramble(argument, ch->speaking) );
act_comm.c:    if ( ach->leader ) ach = ach->leader;
act_comm.c:    if ( bch->leader ) bch = bch->leader;
act_comm.c:	if ( IS_NPC(ch) && !ch->speaks ) /* No langs = knows nothing for npcs */
act_comm.c:	if ( IS_NPC(ch) && IS_SET(ch->speaks, (language & ~LANG_CLAN)) )
act_comm.c:		return (50+(25 - ch->mod_int)*2);
act_comm.c:		return (50+(25 - ch->int)*2);
act_comm.c:			return (50+(25 - ch->int)*2);
act_comm.c:		if ( ch->pcdata->clan == cch->pcdata->clan &&
act_comm.c:			 ch->pcdata->clan != NULL )
act_comm.c:			return (50+(25 - ch->int)*2);
act_comm.c:	    if ( IS_SET(race_table[ch->race]->language, language) )
act_comm.c:			return ((65+(25 - ch->mod_int)*2)<=100 ? (65+(25 - ch->mod_int)*2) : 100);
act_comm.c:	      	   IS_SET(ch->speaks, lang_array[lang]) )
act_comm.c:		    return ch->pcdata->learned[sn];
act_comm.c:	if ( race_table[ch->race]->language & language )
act_comm.c:	if ( ch->speaks & language )
act_comm.c:				if ( ch->pcdata->learned[sn] >= 99 )
act_comm.c:		ch->speaking = ~LANG_CLAN;
act_comm.c:					(IS_NPC(ch) || !ch->pcdata->clan) )
act_comm.c:				ch->speaking = lang_array[langs];
act_comm.c:		if ( race_table[ch->race]->language & lang_array[lang] ||
act_comm.c:			 ch->pcdata->learned[sn] >= 99 )
act_comm.c:		for ( sch = ch->in_room->first_person; sch; sch = sch->next )
act_comm.c:			if ( IS_NPC(sch) && xIS_SET(sch->act, ACT_SCHOLAR)
act_comm.c:			&&   knows_language( sch, ch->speaking, ch )
act_comm.c:			&& (!sch->speaking || knows_language( ch, sch->speaking, sch )) )
act_comm.c:		if ( countlangs(ch->speaks) >= (ch->level / 10) &&
act_comm.c:			 ch->pcdata->learned[sn] <= 0 )
act_comm.c:		if ( ch->practice < prac )
act_comm.c:		ch->practice -= prac;
act_comm.c:		ch->pcdata->learned[sn] += prct;
act_comm.c:		ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn], 99);
act_comm.c:		SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:		if ( ch->pcdata->learned[sn] == prct )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 60 )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:		else if ( ch->pcdata->learned[sn] < 99 )
act_comm.c:			if ( ch->speaking & lang_array[lang] ||
act_comm.c:				(IS_NPC(ch) && !ch->speaking) )
act_info.c:    if (  (IS_AFFECTED(ch, AFF_DETECT_EVIL) || ch->class==CLASS_PALADIN)
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( ch->class==CLASS_PALADIN
act_info.c:    if ( !ch->desc )
act_info.c:	   if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) )
act_info.c:    ms  = (ch->mental_state ? ch->mental_state : 1)
act_info.c:	* (IS_NPC(ch) ? 1 : (ch->pcdata->condition[COND_DRUNK] ? (ch->pcdata->condition[COND_DRUNK]/12) : 1));
act_info.c:	   if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) )
act_info.c:	    if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) )
act_info.c:/*	if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:	if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) )
act_info.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:    &&   (  IS_AFFECTED(ch, AFF_DETECT_EVIL) || ch->class==CLASS_PALADIN)     ) strcat( buf, "(Red Aura) "   );
act_info.c:    &&   ch->class==CLASS_PALADIN  ) strcat( buf, "(Grey Aura) "   );
act_info.c:    &&   ch->class==CLASS_PALADIN  ) strcat( buf, "(White Aura) "   );
act_info.c:    if ( IS_NPC(victim) && ch->mount && ch->mount == victim
act_info.c:         && ch->in_room == ch->mount->in_room ) strcat( buf, "(Mount) "      );
act_info.c:    	   if ( !IS_NPC(victim) && !xIS_SET(ch->act, PLR_BRIEF) )
act_info.c:    if ( !IS_NPC(victim) && !xIS_SET(ch->act, PLR_BRIEF) )
act_info.c:        if (ch->position == POS_SITTING
act_info.c:        ||  ch->position == POS_RESTING )
act_info.c:        if (ch->position == POS_RESTING)
act_info.c:	if (ch->position == POS_MOUNTED)
act_info.c:        if (ch->position == POS_SITTING)
act_info.c:        if (ch->position == POS_RESTING)
act_info.c:    if ( can_see( victim, ch ) && !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_WIZINVIS ) )
act_info.c:      if ( ch->pcdata->learned[gsn_peek] > 0 )
act_info.c:    for ( rch = list; rch; rch = rch->next_in_room )
act_info.c:	else if ( room_is_dark( ch->in_room )
act_info.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:    if ( !ch->desc )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    &&   !xIS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:    &&   room_is_dark( ch->in_room ) )
act_info.c:	show_char_to_char( ch->in_room->first_person, ch );
act_info.c:	switch ( ch->inter_page )    /* rmenu */
act_info.c:        if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:        	ch_printf(ch,"[%d] ",ch->in_room->vnum);
act_info.c:	send_to_char( ch->in_room->name, ch );
act_info.c:	|| ( !IS_NPC(ch) && !xIS_SET(ch->act, PLR_BRIEF) ) )
act_info.c:	    send_to_char( ch->in_room->description, ch );
act_info.c:/*	if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOMAP) ) */   /* maps */
act_info.c:	    if(ch->in_room->map != NULL)
act_info.c:	if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOEXIT) )
act_info.c:	show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:	show_char_to_char( ch->in_room->first_person,  ch );
act_info.c:	if ( !CAN_WEAR( obj, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
act_info.c:	if ( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:	    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:		    original = ch->in_room;
act_info.c:    if ( (pdesc=get_extra_descr(arg1, ch->in_room->first_extradesc)) != NULL )
act_info.c:	||   ch->class == CLASS_THIEF
act_info.c:        ||   ch->class == CLASS_ASSASSIN
act_info.c:			if ( ch->class == CLASS_THIEF )
act_info.c:	    original = ch->in_room;
act_info.c:    for ( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:    for ( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:  if ( !ch->desc )
act_info.c:  if ( ch->position < POS_SLEEPING )
act_info.c:  if ( ch->position == POS_SLEEPING )
act_info.c:    if ( xIS_SET(ch->act, PLR_BRIEF) )
act_info.c:    xSET_BIT( ch->act, PLR_BRIEF );
act_info.c:	xREMOVE_BIT(ch->act, PLR_BRIEF);
act_info.c:    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_info.c:	temp = (ch->in_room->area->weather->temp + 3*weath_unit - 1)/
act_info.c:	precip = (ch->in_room->area->weather->precip + 3*weath_unit - 1)/
act_info.c:	wind = (ch->in_room->area->weather->wind + 3*weath_unit - 1)/
act_info.c:	SET_BIT(ch->pcdata->flags, PCFLAG_HELPSTART);
act_info.c:    if ( !ch->desc )
act_info.c:    switch( ch->substate )
act_info.c:	  if ( (pHelp = ch->dest_buf) == NULL )
act_info.c:		bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
act_info.c:    ch->substate = SUB_HELP_EDIT;
act_info.c:    ch->dest_buf = pHelp;
act_info.c:    if (!wch->leader || wch->leader == wch || !wch->leader->desc ||
act_info.c:         IS_NPC(wch->leader) || IS_IMMORTAL(wch) || IS_IMMORTAL(wch->leader))
act_info.c:      if (wch->leader && wch->leader != wch && wch->leader->desc &&
act_info.c:         !IS_NPC(wch->leader) && !IS_IMMORTAL(wch) &&
act_info.c:         !IS_IMMORTAL(wch->leader) &&
act_info.c:         (whogr_t = find_whogr(wch->leader->desc, first_whogr)))
act_info.c:	if ( wch->level < iLevelLower
act_info.c:	||   wch->level > iLevelUpper
act_info.c:	|| ( fImmortalOnly  && wch->level < LEVEL_IMMORTAL )
act_info.c:	|| ( fClassRestrict && !rgfClass[wch->class] )
act_info.c:	|| ( fRaceRestrict && !rgfRace[wch->race] )
act_info.c:	|| ( fClanMatch && ( pClan != wch->pcdata->clan ))  /* SB */
act_info.c:        || ( fCouncilMatch && ( pCouncil != wch->pcdata->council )) /* SB */ 
act_info.c:	|| ( fDeityMatch && ( pDeity != wch->pcdata->deity )) )
act_info.c:	if ( fLeader && !(wch->pcdata->council && 
act_info.c:	     ((wch->pcdata->council->head2 &&
act_info.c:	     !str_cmp(wch->pcdata->council->head2, wch->name)) ||
act_info.c:	     (wch->pcdata->council->head &&
act_info.c:	     !str_cmp(wch->pcdata->council->head, wch->name)))) &&
act_info.c:	     !(wch->pcdata->clan && ((wch->pcdata->clan->deity &&
act_info.c:	     !str_cmp(wch->pcdata->clan->deity,wch->name) )
act_info.c:	     || (wch->pcdata->clan->leader
act_info.c:	     && !str_cmp(wch->pcdata->clan->leader, wch->name ) )
act_info.c:	     || (wch->pcdata->clan->number1
act_info.c:	     && !str_cmp(wch->pcdata->clan->number1, wch->name ) )
act_info.c:	     || (wch->pcdata->clan->number2 
act_info.c:	     && !str_cmp(wch->pcdata->clan->number2, wch->name )))))
act_info.c:	if (fGroup && !wch->leader &&
act_info.c:	   !IS_SET(wch->pcdata->flags, PCFLAG_GROUPWHO) &&
act_info.c:	&&   wch->pcdata->homepage
act_info.c:	&&   wch->pcdata->homepage[0] != '\0' )
act_info.c:		show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:	  strcpy( char_name, wch->name );
act_info.c:	/*sprintf( class_text, "%s%2d %s", NOT_AUTHED(wch) ? "N" : " ", wch->level, class_table[wch->class]->who_name ); */
act_info.c:	sprintf( class_text, "%3d %3.3s", wch->level, class_table[wch->class]->who_name );
act_info.c:	switch ( wch->level )
act_info.c:        if ( !str_cmp( wch->name, sysdata.guild_overseer ) )
act_info.c:        else if ( !str_cmp( wch->name, sysdata.guild_advisor ) )
act_info.c:	else if ( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c:	  class = wch->pcdata->rank;
act_info.c:	if (IS_SET( wch->pcdata->flags, PCFLAG_ANONYMOUS))
act_info.c:	if ( wch->pcdata->clan )
act_info.c:          CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:	    if ( !str_cmp( wch->name, pclan->deity ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->leader ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            if ( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            if ( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->deity ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->leader ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:	    if ( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:	if ( wch->pcdata->council )
act_info.c:          if (  wch->pcdata->council->head2 == NULL )
act_info.c:             if (!str_cmp (wch->name, wch->pcdata->council->head))
act_info.c:             if (!str_cmp (wch->name, wch->pcdata->council->head)
act_info.c:                 || !str_cmp ( wch->name, wch->pcdata->council->head2) )
act_info.c:          strcat( council_name, wch->pcdata->council_name );
act_info.c:	if ( xIS_SET(wch->act, PLR_WIZINVIS) )
act_info.c:	  sprintf( invis_str, " &R(&W%d&R)&w", wch->pcdata->wizinvis );
act_info.c:          IS_SET( wch->pcdata->flags, PCFLAG_DEADLY ) ? "&WPK" : "&W--",
act_info.c:	  (wch->pcdata->extraname ? wch->pcdata->extraname : " "),
act_info.c:	      (wch->pcdata->lastname ? wch->pcdata->lastname : "" ),
act_info.c:          wch->pcdata->title,
act_info.c:          (wch->desc && wch->desc->connected) ? " &Y[&WWRITING&Y]&w " : "",
act_info.c:          xIS_SET(wch->act, PLR_AFK) ? " &Y[&WAWAY&Y]&w " : "",
act_info.c:          xIS_SET(wch->act, PLR_ATTACKER) ? " &R(&W^zATTACKER^x&R)&w " : "",
act_info.c:          xIS_SET(wch->act, PLR_KILLER) ? " &R(&W^zKILLER^x&R)&w " : "",
act_info.c:          xIS_SET(wch->act, PLR_THIEF)  ? " &R(&W^zTHIEF^x&R)&w "  : ""
act_info.c:            if ( wch->leader || (whogr_p && whogr_p->indent) )
act_info.c:	for ( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:        pager_printf( ch, "\n\rPlayers near you in %s:\n\r", ch->in_room->area->name );
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:    diff = victim->level - ch->level;
act_info.c:    diff = (int) (victim->max_hit - ch->max_hit) / 6;
act_info.c:    if ( ch->level < 2 )
act_info.c:		  || (ch->pcdata->clan->class != skill_table[sn]->guild) ) ) )
act_info.c:	    if ( ch->level < skill_table[sn]->skill_level[ch->class]
act_info.c:	    || (!IS_IMMORTAL(ch) && skill_table[sn]->skill_level[ch->class] == 0) )
act_info.c:	    if ( ch->pcdata->learned[sn] <= 0
act_info.c:	    if ( ch->pcdata->learned[sn] > 0 )
act_info.c:	    pager_printf( ch, " %3d%% ", ch->pcdata->learned[sn] );
act_info.c:	    ch->practice );
act_info.c:	for ( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:	if ( ch->practice <= 0 )
act_info.c:	            &&  ch->level < skill_table[sn]->skill_level[ch->class] 
act_info.c:                    &&  ch->level < skill_table[sn]->race_level[ch->race]  
act_info.c:	     && ch->pcdata->clan->class != skill_table[sn]->guild )
act_info.c:	if ( mob->level < skill_table[sn]->skill_level[ch->class]
act_info.c:	adept = class_table[ch->class]->skill_adept * 0.2;
act_info.c:	if ( ch->pcdata->learned[sn] >= adept )
act_info.c:	    ch->practice--;
act_info.c:	    ch->pcdata->learned[sn] += int_app[get_curr_int(ch)].learn;
act_info.c:	    if ( ch->pcdata->learned[sn] >= adept )
act_info.c:		ch->pcdata->learned[sn] = adept;
act_info.c:	wimpy = (int) ch->max_hit / 2.25;
act_info.c:	wimpy = (int) ch->max_hit / 1.2;
act_info.c:      wimpy = (int) ch->max_hit / 5;
act_info.c:    if ( IS_PKILL( ch ) && wimpy > (int) ch->max_hit / 2.25 )
act_info.c:    else if ( wimpy > (int) ch->max_hit / 1.2 )
act_info.c:    ch->wimpy	= wimpy;
act_info.c:    if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_info.c:    pwdnew = crypt( arg2, ch->name );
act_info.c:    DISPOSE( ch->pcdata->pwd );
act_info.c:    ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:        if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_SILENCE) )
act_info.c:	ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_RACETALK )?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_CHAT )    ?
act_info.c:          ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AUCTION ) ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_QUEST )   ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_WARTALK ) ?
act_info.c:          ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AVTALK )  ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_MUSIC )   ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_ASK )     ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_SHOUT )   ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_YELL )    ?
act_info.c:	ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_GRATZ )   ?
act_info.c:        ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_TELLS )   ?
act_info.c:        ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_WHISPER )   ?
act_info.c:        if ( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c:          if ( ch->pcdata->clan->clan_type == CLAN_ORDER )
act_info.c:	    send_to_char_color( !IS_SET( ch->deaf, CHANNEL_ORDER ) ?
act_info.c:          else if ( ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:	    send_to_char_color( !IS_SET( ch->deaf, CHANNEL_GUILD ) ?
act_info.c:	    send_to_char_color( !IS_SET( ch->deaf, CHANNEL_CLAN )  ?
act_info.c:        if ( IS_IMMORTAL(ch) || ( ch->pcdata->council
act_info.c:	&&   !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) )
act_info.c:          ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_NEWBIE) ?
act_info.c:        if ( !IS_NPC( ch ) && ch->pcdata->council )
act_info.c:          ch_printf_color( ch, "%s",   !IS_SET( ch->deaf, CHANNEL_COUNCIL)?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_IMMTALK )    ?
act_info.c:/*          send_to_char_color( !IS_SET( ch->deaf, CHANNEL_PRAY )       ?
act_info.c:              send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGHGOD )  ?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_MONITOR )    ?
act_info.c:	    send_to_char_color( !IS_SET( ch->deaf, CHANNEL_AUTH )	?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_LOG ) 	?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_BUILD)       ?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_COMM ) 	?
act_info.c:            send_to_char_color( !IS_SET (ch->deaf, CHANNEL_WARN)
act_info.c:              send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGH ) 	?
act_info.c:	    REMOVE_BIT (ch->deaf, CHANNEL_RACETALK);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_AUCTION);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_CHAT);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_QUEST);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_WARTALK);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_PRAY);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_MUSIC);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_ASK);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_SHOUT);
act_info.c:            REMOVE_BIT (ch->deaf, CHANNEL_YELL);
act_info.c:			REMOVE_BIT (ch->deaf, CHANNEL_GRATZ);
act_info.c:       /*     if (ch->pcdata->clan)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:	    if (ch->pcdata->council)
act_info.c:	      REMOVE_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:            if (ch->pcdata->guild)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:            if (ch->level >= LEVEL_IMMORTAL)
act_info.c:              REMOVE_BIT (ch->deaf, CHANNEL_AVTALK);
act_info.c:	    if (ch->level >= sysdata.log_level )
act_info.c:	      REMOVE_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:	    SET_BIT (ch->deaf, CHANNEL_RACETALK);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_AUCTION);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_CHAT);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_QUEST);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_PRAY);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_MUSIC);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_ASK);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_SHOUT);
act_info.c:	    SET_BIT (ch->deaf, CHANNEL_WARTALK);
act_info.c:            SET_BIT (ch->deaf, CHANNEL_YELL);
act_info.c:			SET_BIT (ch->deaf, CHANNEL_GRATZ);
act_info.c:       /*     if (ch->pcdata->clan)
act_info.c:              SET_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:	    if (ch->pcdata->council)
act_info.c:	      SET_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:              SET_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:            if (ch->level >= LEVEL_IMMORTAL)
act_info.c:              SET_BIT (ch->deaf, CHANNEL_AVTALK);
act_info.c:	    if (ch->level >= sysdata.log_level)
act_info.c:	      SET_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:	    REMOVE_BIT (ch->deaf, bit);
act_info.c:	    SET_BIT    (ch->deaf, bit);
act_info.c:        IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) 	? "[+] PAGER"
act_info.c:        IS_SET( ch->pcdata->flags, PCFLAG_GAG )     	? "[+] GAG"
act_info.c:        xIS_SET(ch->act, PLR_BRIEF )                	? "[+] BRIEF"
act_info.c:        xIS_SET(ch->act, PLR_COMBINE )              	? "[+] COMBINE"
act_info.c:        xIS_SET(ch->act, PLR_BLANK )                	? "[+] BLANK"
act_info.c:        xIS_SET(ch->act, PLR_PROMPT )               	? "[+] PROMPT"
act_info.c:        xIS_SET(ch->act, PLR_ANSI )                 	? "[+] ANSI"
act_info.c:        xIS_SET(ch->act, PLR_RIP )                  	? "[+] RIP"
act_info.c:		xIS_SET(ch->act, PLR_NOMENU )					? "[+] NOMENU"
act_info.c:		   IS_SET( ch->pcdata->flags, PCFLAG_NOBEEP )   ? "[+] NOBEEP"
act_info.c:		   IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS) ? "[+] ANONYMOUS"
act_info.c:        xIS_SET(ch->act, PLR_AUTOSAC  )             	? "[+] AUTOSAC"
act_info.c:        xIS_SET(ch->act, PLR_AUTOGOLD )             	? "[+] AUTOGOLD"
act_info.c:        xIS_SET(ch->act, PLR_AUTOLOOT )             	? "[+] AUTOLOOT"
act_info.c:        xIS_SET(ch->act, PLR_AUTOEXIT )             	? "[+] AUTOEXIT"
act_info.c:        IS_SET( ch->pcdata->flags, PCFLAG_NORECALL ) 	? "[+] NORECALL"
act_info.c:        IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON ) 	? "[+] NOSUMMON"
act_info.c:        IS_SET( ch->pcdata->flags, PCFLAG_IMMPROOF ) 	? "[+] IMMPROOF"
act_info.c:           xIS_SET(ch->act, PLR_SHOVEDRAG )             ? "[+] DRAG"
act_info.c:           xIS_SET(ch->act, PLR_NICE )               	? "[+] NICE"
act_info.c:	   xIS_SET(ch->act, PLR_TELNET_GA )		? "[+] TELNETGA"
act_info.c:           IS_SET( ch->pcdata->flags, PCFLAG_GROUPWHO ) ? "[+] GROUPWHO"
act_info.c:           IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO )  ? "[+] NOINTRO"
act_info.c:							ch->pcdata->pagerlen,
act_info.c:						        ch->wimpy );
act_info.c:	  xIS_SET(ch->act, PLR_ROOMVNUM ) 		? "+"
act_info.c:          xIS_SET(ch->act, PLR_AUTOMAP  ) 		? "+"
act_info.c:	xIS_SET( ch->act, PLR_ROOMVNUM )		? "[+] VNUM"
act_info.c:	xIS_SET( ch->act, PLR_AUTOMAP )			? "[+] MAP"
act_info.c:        /*IS_SET( ch->pcdata->flags, PCFLAG_IMMPROOF ) 	? "[+] IMMPROOF"
act_info.c:          xIS_SET(ch->act, PLR_SILENCE )  ?
act_info.c:          xIS_SET(ch->act, PLR_NO_EMOTE ) ?
act_info.c:          xIS_SET(ch->act, PLR_NO_TELL )  ?
act_info.c:          xIS_SET(ch->act, PLR_LITTERBUG )?
act_info.c:          xIS_SET(ch->act, PLR_THIEF )    ?
act_info.c:          xIS_SET(ch->act, PLR_KILLER )   ?
act_info.c:	    xSET_BIT   (ch->act, bit);
act_info.c:	    xREMOVE_BIT(ch->act, bit);
act_info.c:	    SET_BIT    (ch->pcdata->flags, bit);
act_info.c:	    REMOVE_BIT (ch->pcdata->flags, bit);
act_info.c:     if xIS_SET(ch->act, PLR_AFK)
act_info.c:    	xREMOVE_BIT(ch->act, PLR_AFK);
act_info.c:	xSET_BIT(ch->act, PLR_AFK);
act_info.c:	    if ( ch->pcdata->learned[sn] <= 0
act_info.c:	    if(i==skill_table[sn]->skill_level[ch->class]  )
act_info.c:                        ch->pcdata->learned[sn],
act_info.c:                        skill_table[sn]->skill_adept[ch->class],
act_info.c:    if ( IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) )
act_info.c:        ch_printf( ch, "Pager is now enabled at %d lines.\n\r", ch->pcdata->pagerlen );
act_info.c:  ch->pcdata->pagerlen = atoi(arg);
act_info.c:  if ( ch->pcdata->pagerlen < 5 )
act_info.c:    ch->pcdata->pagerlen = 5;
act_info.c:  ch_printf( ch, "Page pausing set to %d lines.\n\r", ch->pcdata->pagerlen );
act_info.c:		if(!ch->pcdata->first_ignored)
act_info.c:		for(temp = ch->pcdata->first_ignored; temp;
act_info.c:		for(temp = ch->pcdata->first_ignored; temp; temp = next)
act_info.c:			UNLINK(temp, ch->pcdata->first_ignored,
act_info.c:					ch->pcdata->last_ignored,
act_info.c:	else if(!strcmp(arg, "self") || nifty_is_name(arg, ch->name))
act_info.c:			if(!ch->reply)
act_info.c:				strcpy(arg, ch->reply->name);
act_info.c:		for(temp = ch->pcdata->first_ignored, i = 0; temp;
act_info.c:				UNLINK(temp, ch->pcdata->first_ignored,
act_info.c:					ch->pcdata->last_ignored,
act_info.c:			LINK(new, ch->pcdata->first_ignored,
act_info.c:				ch->pcdata->last_ignored, next, prev);
act_info.c:	for(temp = ch->pcdata->first_ignored; temp; temp = temp->next)
act_info.c:		if(nifty_is_name(temp->name, ign_ch->name))
act_move.c:    cur = ch->carry_weight;
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:    || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:	   bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:	move_char( ch, get_exit(ch->in_room, DIR_DOWN), ++fall );
act_move.c:    if (ch->on != NULL)		/* is char on floor ??? */
act_move.c:      if ( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE )
act_move.c:	&& ( ch->position != POS_DRAG ) )
act_move.c:      if ( ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 8 && 
act_move.c:	 ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) && 
act_move.c:	 number_percent() > (ch->pcdata->nuisance->flags*ch->pcdata->nuisance->power))
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:	sprintf( buf, "move_char: %s to door %d", ch->name, pexit->vdir );
act_move.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_MOUNTED) )
act_move.c:    in_room = ch->in_room;
act_move.c:	if ( drunk && ch->position != POS_MOUNTED
act_move.c:	&&   ch->in_room->sector_type != SECT_WATER_SWIM
act_move.c:	&&   ch->in_room->sector_type != SECT_WATER_NOSWIM
act_move.c:	&&   ch->in_room->sector_type != SECT_UNDERWATER
act_move.c:	&&   ch->in_room->sector_type != SECT_OCEANFLOOR )
act_move.c:		ch->position = POS_RESTING;
act_move.c:		ch->position = POS_INCAP;
act_move.c:    &&   ch->master
act_move.c:    &&   in_room == ch->master->in_room )
act_move.c:    &&  ch->in_room->area != to_room->area )
act_move.c:	if ( ch->level < to_room->area->low_hard_range )
act_move.c:	    switch( to_room->area->low_hard_range - ch->level )
act_move.c:	if ( ch->level > to_room->area->hi_hard_range )
act_move.c:	    if ( iClass != ch->class
act_move.c:        &&   !IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL )
act_move.c:	    if ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	    if ( !ch->mount && !IS_AFFECTED(ch, AFF_FLYING) )
act_move.c:	    if ( (ch->mount && !IS_FLOATING(ch->mount)) || !IS_FLOATING(ch) )
act_move.c:		    if ( ch->mount )
act_move.c:	    if ( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	    if ( !found && !ch->mount )
act_move.c:		||      drunk || ch->mental_state < -90 )
act_move.c:	if ( ch->mount )
act_move.c:	  switch (ch->mount->position)
act_move.c:	  if ( !IS_FLOATING(ch->mount) )
act_move.c:	  if ( ch->mount->move < move )
act_move.c:	  if ( ch->move < move )
act_move.c:	if ( ch->mount )
act_move.c:	  ch->mount->move -= move;
act_move.c:	  ch->move -= move;
act_move.c:	int count = ch->mount ? 1 : 0;
act_move.c:		if ( ch->mount && count == to_room->tunnel )
act_move.c:    && ( IS_NPC(ch) || !xIS_SET(ch->act, PLR_WIZINVIS) ) )
act_move.c:        if ( ch->mount )
act_move.c:	  if ( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:	  if ( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:          if ( ch->position == POS_SHOVE )
act_move.c:	  if ( ch->position == POS_DRAG )
act_move.c:      if ( ch->mount )
act_move.c:	act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:    if ( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:      if( ch->mount )
act_move.c:        char_from_room( ch->mount );
act_move.c:        char_to_room( ch->mount, to_room );
act_move.c:    && ( IS_NPC(ch) || !xIS_SET(ch->act, PLR_WIZINVIS) ) )
act_move.c:      if ( ch->mount )
act_move.c:	if ( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:	if ( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:	if ( ch->position == POS_SHOVE )
act_move.c:	if ( ch->position == POS_DRAG )
act_move.c:      if ( ch->mount )
act_move.c:	act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:    &&  ch->in_room->area != to_room->area )
act_move.c:	if ( ch->level < to_room->area->low_soft_range )
act_move.c:	if ( ch->level > to_room->area->hi_soft_range )
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:	if ( xIS_SET(ch->act, PLR_BRIEF) )
act_move.c:	xREMOVE_BIT(ch->act, PLR_BRIEF);
act_move.c: 	xSET_BIT(ch->act, PLR_BRIEF);
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:		     ch->name, ch->in_room->vnum );
act_move.c:      for ( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:	nextinroom = fch->next_in_room;
act_move.c:	&& fch->master == ch
act_move.c:	&& fch->position == POS_STANDING )
act_move.c:    if ( ch->in_room->first_content )
act_move.c:	|| ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTH), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_EAST), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTH), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_WEST), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_UP), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_DOWN), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTHEAST), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_NORTHWEST), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTHEAST), 0 );
act_move.c:    move_char( ch, get_exit(ch->in_room, DIR_SOUTHWEST), 0 );
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:    if ( (pexit = get_exit( ch->in_room, door )) == NULL )
act_move.c:	    &&   pexit_rev->to_room == ch->in_room )
act_move.c:		for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:	&&   pexit_rev->to_room == ch->in_room )
act_move.c:	    for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:	&& ch->level < skill_table[gsn_bashdoor]->skill_level[ch->class] )
act_move.c:	if ( ch->fighting )
act_move.c:	    &&   ch->move >= 15
act_move.c:		&&    pexit_rev->to_room	== ch->in_room )
act_move.c:			for ( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:		damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:		damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:	    damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:	   for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_move.c:		 && !gch->fighting
act_move.c:		 && ( ch->level - gch->level <= 4 )
act_move.c:	if (ch->position == POS_FIGHTING)
act_move.c:		ch->fur_pos = FURNITURE_UNUSED;
act_move.c:		ch->position = POS_STANDING;
act_move.c:		if (ch->on)
act_move.c:		   for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:		   for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:		   ch->on = NULL;
act_move.c:	obj = get_obj_list(ch, arg,ch->in_room->first_content);
act_move.c:		|| ((ch->on != obj) && (count_users(obj) >= obj->value[0])))
act_move.c:	ch->on=obj;
act_move.c:	ch->fur_pos=type;
act_move.c:   	for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:   	for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_STANDING;
act_move.c:        ch->position = POS_STANDING;
act_move.c:	ch->position = POS_STANDING;
act_move.c:	if(!ch->on)
act_move.c:    if(ch->on)
act_move.c:	ch->position = POS_STANDING;
act_move.c:	for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:   	for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:   	ch->on = NULL;
act_move.c:	ch->fur_pos = FURNITURE_UNUSED;
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_SITTING;
act_move.c:	ch->position = POS_SITTING;
act_move.c:		obj = get_obj_list(ch, arg,ch->in_room->first_content);
act_move.c:			|| ((ch->on != obj) && (count_users(obj) >= obj->value[0])))
act_move.c:        	ch->position = POS_SITTING;
act_move.c:		if (ch->weight >= ((obj->value[0] * 300) + number_range(-30, 30))) {
act_move.c:			ch->position = POS_RESTING;
act_move.c:			ch->on = obj;
act_move.c:			ch->fur_pos = type;
act_move.c:			for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:			for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:        ch->position = POS_SITTING;
act_move.c:    switch ( ch->position )
act_move.c:        ch->position = POS_RESTING;
act_move.c:        	obj = get_obj_list(ch, arg,ch->in_room->first_content);
act_move.c:                	|| ((ch->on != obj) && (count_users(obj) >= obj->value[0])))
act_move.c:		if (ch->weight >= ((obj->value[0] * 300) + number_range(-30, 30))) {
act_move.c:			ch->position = POS_RESTING;
act_move.c:        	ch->position = POS_RESTING;
act_move.c:		ch->on = obj;
act_move.c:		ch->fur_pos = type;
act_move.c:		for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:		for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:        ch->position = POS_RESTING;
act_move.c:	ch->position = POS_RESTING;
act_move.c:    switch ( ch->position )
act_move.c:	if ( ch->mental_state > 30 && (number_percent()+10) < ch->mental_state )
act_move.c:        ch->position = POS_SLEEPING;
act_move.c:	if ( ch->mental_state > 30 && (number_percent()+5) < ch->mental_state )
act_move.c:        ch->position = POS_SLEEPING;
act_move.c:	if ( ch->mental_state > 30 && number_percent() < ch->mental_state )
act_move.c:        	obj = get_obj_list(ch, arg,ch->in_room->first_content);
act_move.c:                	|| ((ch->on != obj) && (count_users(obj) >= obj->value[0])))
act_move.c:		if (ch->weight >= ((obj->value[0] * 300) + number_range(-30, 30))) {
act_move.c:			ch->position = POS_RESTING;
act_move.c:        	ch->position = POS_SLEEPING;
act_move.c:		ch->on = obj;
act_move.c:		ch->fur_pos = type;
act_move.c:		for ( paf = ch->on->pIndexData->first_affect; paf; paf = paf->next )
act_move.c:		for ( paf = ch->on->first_affect; paf; paf = paf->next )
act_move.c:        ch->position = POS_SLEEPING;
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:		     ch->name, ch->in_room->vnum );
act_move.c:    ROOM_INDEX_DATA *start = ch->in_room, *dest;
act_move.c:	nch_next = nch->next_in_room;
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	if ( ch->in_room->sector_type != SECT_INSIDE && IS_OUTSIDE(ch) )
act_move.c:	    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:	if ( ch->in_room->sector_type == SECT_INSIDE || !IS_OUTSIDE(ch) )
act_move.c:	    for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:    if ( (room=ch->in_room) == NULL )
act_move.c:	bug( "pullcheck: %s not in a room?!?", ch->name );
act_move.c:		    if ( (ch->mount && !IS_FLOATING(ch->mount))
act_move.c:		    ||  (!ch->mount && !IS_FLOATING(ch)) )
act_move.c:	    if ( (ch->mount && !IS_FLOATING(ch->mount))
act_move.c:	    ||  (!ch->mount && !IS_FLOATING(ch)) )
act_move.c:	if ( ch->mount )
act_move.c:	    char_from_room(ch->mount);
act_move.c:	    char_to_room(ch->mount, xit->to_room);
act_move.c:		do_look(ch->mount, "auto");
act_move.c:			room=get_room_index(ch->pcdata->memorize[slot]);
act_move.c:	switch (ch->substate) {
act_move.c:		ch->recall=slot;
act_move.c:		ch->substate=SUB_NONE;
act_move.c:		ch->substate = SUB_NONE;
act_move.c:		ch->pcdata->memorize[ch->recall]=ch->in_room->vnum;
act_obj.c:       && (ch->level < sysdata.level_getobjnotake )  )
act_obj.c:	    if ( ch->level - obj->value[5] > 5
act_obj.c:	    ||   obj->value[5] - ch->level > 5 )
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + weight > can_carry_w( ch ) )
act_obj.c:	&&  !IS_NPC( ch ) && str_cmp( container->name+7, ch->name ) )
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	  if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:        switch(ch->race){
act_obj.c:	ch->gold += amt;
act_obj.c:	if ( (ch->carry_number + number) > can_carry_n(ch) )
act_obj.c:	    obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:	    if ( IS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:	    for ( obj = ch->in_room->last_content; obj; obj = obj_next )
act_obj.c:		    ||   ch->carry_number >= can_carry_n( ch )
act_obj.c:		    ||   ch->carry_weight >= can_carry_w( ch )
act_obj.c:	    if ( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:		&& str_cmp( name, ch->name ) )
act_obj.c:		&&   str_cmp( name, ch->name )
act_obj.c:		&&   str_cmp( container->action_desc, ch->name ) )
act_obj.c:		&&  !IS_NPC(ch) && str_cmp( name, ch->name )
act_obj.c:		&&  !IS_NPC(ch) /*&& IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) */
act_obj.c:		&&   container->value[4] - ch->level < 10
act_obj.c:		&&   container->value[4] - ch->level > -10 )
act_obj.c:		if ( str_cmp( name, ch->name ) && !IS_IMMORTAL(ch) )
act_obj.c:		    for ( gch = first_char; gch; gch = gch->next )
act_obj.c:			&&   !str_cmp( name, gch->name ) )
act_obj.c:            &&  str_cmp( ch->name, container->name+7 ) )
act_obj.c:		    ||   ch->carry_number >= can_carry_n( ch )
act_obj.c:		    ||   ch->carry_weight >= can_carry_w( ch )
act_obj.c:	if ( ch->carry_weight + container->weight > can_carry_w(ch) )
act_obj.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	      if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:        if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) 
act_obj.c:	     if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:    if ( xIS_SET( ch->act, PLR_LITTERBUG ) )
act_obj.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NODROP )
act_obj.c:	    if ( ch->gold < number )
act_obj.c:	    ch->gold -= number;
act_obj.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:	    obj_to_room( create_money( number ), ch->in_room );
act_obj.c:	obj = obj_to_room( obj, ch->in_room );
act_obj.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_CLANSTOREROOM) )
act_obj.c: 	      if ( clan->storeroom == ch->in_room->vnum )
act_obj.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) 
act_obj.c:        ||   IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:		     obj_next = ch->first_carrying;
act_obj.c:		obj = obj_to_room( obj, ch->in_room );
act_obj.c:	if ( ch->gold < amount )
act_obj.c:	ch->gold     -= amount;
act_obj.c:    if ( !IS_NPC(ch) && (!IS_PKILL(ch) || (IS_PKILL(ch) && !IS_SET(ch->pcdata->flags, PCFLAG_GAG))) )
act_obj.c:	    ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:		ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:	    ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:    &&   ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( IS_NPC(ch) || ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:    for ( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:        && ch->class == CLASS_WARRIOR					)
act_obj.c:        && ch->class == 8					        )
act_obj.c:	&& ch->class == CLASS_MAGE					)
act_obj.c:	&& ch->class == CLASS_THIEF					)
act_obj.c:	&& ch->race == RACE_VAMPIRE					)
act_obj.c:	&& ch->class == CLASS_DRUID					)
act_obj.c:	&& ch->class == CLASS_RANGER					)
act_obj.c:	&& ch->class == CLASS_AUGURER					)
act_obj.c:	&& ch->class == CLASS_CLERIC					)) )
act_obj.c:	    bug( "wear_obj: uknown/unused item_wear bit %d. %s room %d", bit, ch->name, ch->in_room->vnum );
act_obj.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      for ( obj = ch->first_carrying; obj != NULL ; obj = obj_next )
act_obj.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:    obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:	|| IS_NPC(ch) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_obj.c:    switch( ch->in_room->sector_type )
act_obj.c:    if ( move > ch->move )
act_obj.c:    ch->move -= move;
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:    obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:            if ( ch->level - obj->value[5] > 5
act_obj.c:            ||   obj->value[5] - ch->level > 5 )
act_obj.c:    if ( !IS_NPC( ch ) && ch->pcdata->deity && ch->pcdata->deity->name[0] != '\0' )
act_obj.c:	strcpy( name, ch->pcdata->deity->name );
act_obj.c:    else if ( !IS_NPC( ch ) && ch->pcdata->clan && ch->pcdata->clan->deity[0] != '\0' )
act_obj.c:	strcpy( name, ch->pcdata->clan->deity );
act_obj.c:    ch->gold += 1;
act_obj.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:	    vch_next	= vch->next_in_room;
act_obj.c:            if ( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) 
act_obj.c:                  && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:    if ( arg[0] == '\0' && !ch->fighting )
act_obj.c:	if ( ch->fighting )
act_obj.c:	templvl = ch->level;
act_obj.c:	ch->level = LEVEL_HERO;		/* make sure EQ doesn't get lost */
act_obj.c:        contents = ch->in_room->last_content;
act_obj.c:	ch->level = templvl;
act_obj.c:    if ( ch->level < 3 )
act_obj.c:/*	    if ( ch->level < auction->item->level )
act_obj.c:            if (newbet > ch->gold)
act_obj.c:            ch->gold -= newbet; /* substract the gold - important :) */
act_obj.c:				rch = rch->next_in_room, chcnt++ )
act_obj.c:			damage( vch, vch, dam*vch->level, TYPE_UNDEFINED );
act_obj.c:  obj = recursive_note_find(ch->first_carrying, argument);
act_obj.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:	    if ( clan->storeroom == ch->in_room->vnum )
act_wiz.c:    for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:           /* pager_printf( ch, "Saving %-s...\n\r", vch->name ); */
act_wiz.c:   sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:   sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:   sprintf( fname, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:          if ( !str_cmp(ch->name, pw->imm_name) )
act_wiz.c:          if ( !str_cmp(ch->name, pw->imm_name) )
act_wiz.c:          if ( !str_cmp(ch->name, pw->imm_name)
act_wiz.c:   pinsert->imm_name     = str_dup( strlower( ch->name ) );
act_wiz.c:          if ( !str_cmp(ch->name, pw->imm_name)
act_wiz.c:   pinsert->imm_name     = str_dup( strlower( ch->name ) );
act_wiz.c:		if(!str_cmp(ch->name, pw->imm_name)
act_wiz.c:	pinsert->imm_name = str_dup(strlower(ch->name));
act_wiz.c:	     ch->name, cmd->name, level );
act_wiz.c:	victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:				strcpy(newbamf, ch->name);
act_wiz.c:				strcat(newbamf, ch->name);
act_wiz.c:			a+=strlen(ch->name);
act_wiz.c:	DISPOSE( ch->pcdata->bamfin );
act_wiz.c:	ch->pcdata->bamfin = str_dup( newbamf );
act_wiz.c:				strcpy(newbamf, ch->name);
act_wiz.c:				strcat(newbamf, ch->name);
act_wiz.c:			a+=strlen(ch->name);
act_wiz.c:	DISPOSE( ch->pcdata->bamfout );
act_wiz.c:	ch->pcdata->bamfout = str_dup( newbamf );
act_wiz.c:  DISPOSE( ch->pcdata->rank );
act_wiz.c:    ch->pcdata->rank = str_dup( "" );
act_wiz.c:    ch->pcdata->rank = str_dup( argument );
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\n\r", ch->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\n\r", ch->name );
act_wiz.c:    sprintf(arg,"Forceclose issued by %s on %s",ch->name,argument);
act_wiz.c:    if ( xIS_SET(ch->act, PLR_NO_EMOTE) ) {
act_wiz.c:    if ( xIS_SET(ch->act, PLR_NO_EMOTE) ) {
act_wiz.c:       echo_to_room ( color, ch->in_room, argument );
act_wiz.c:       echo_to_room ( AT_IMMORT, ch->in_room, argument );
act_wiz.c:	location = ch->in_room;
act_wiz.c:	sprintf(buf, "%d", ch->regoto);
act_wiz.c:    	 || !IS_NPC(wch) || wch->in_room == NULL)
act_wiz.c:    location = wch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:	location = ch->in_room;
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    if ( ch->in_room != location && room_is_private( location ) )
act_wiz.c:    switch( ch->in_room->sector_type ) {
act_wiz.c:    for ( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:	  one_argument( rch->name, buf );
act_wiz.c:    sprintf( buf, "Reboot by %s.", ch->name );
act_wiz.c:	for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:    sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:	for ( vch = first_char; vch; vch = vch->next )
act_wiz.c:	    if ( d->snoop_by == ch->desc )
act_wiz.c:    if ( ch->desc )
act_wiz.c:	for ( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:    if ( !ch->desc )
act_wiz.c:    if ( ch->desc->original )
act_wiz.c:    if ( !IS_NPC(victim) && ch->level < LEVEL_GREATER )
act_wiz.c:	if ( ch->level <= victim->level ) {
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c:    ch->switched	= victim;
act_wiz.c:    if ( !ch->desc )
act_wiz.c:    if ( !ch->desc->original )
act_wiz.c:	xREMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc;
act_wiz.c:    ch->desc->character->switched = NULL;
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
act_wiz.c:	obj = obj_to_room( obj, ch->in_room );
act_wiz.c:	for ( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:	for ( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:      sprintf( buf2, "%s balzhuring %s", ch->name, buf );
act_wiz.c:          sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:    sprintf(arg,"elevate issued by %s on %s",ch->name,argument);
act_wiz.c:        if ( !ch->pcdata )
act_wiz.c:        ch->pcdata->restore_time = current_time;
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:   		vch->hit = vch->max_hit;
act_wiz.c:		vch->mana = vch->max_mana;
act_wiz.c:		vch->move = vch->max_move;
act_wiz.c:		vch->pcdata->condition[COND_BLOODTHIRST] = (10 + vch->level);
act_wiz.c:  if ( !ch->pcdata )
act_wiz.c:  if ( !ch->pcdata->restore_time )
act_wiz.c:  time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:        ch_printf( victim, "%s is attempting to freeze you.\n\r", ch->name );
act_wiz.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting )
act_wiz.c:  for ( pwatch = first_watch; pwatch; pwatch = pwatch->next )
act_wiz.c:      fprintf( fp, "%d %s~%s~%s~\n", pwatch->imm_level, pwatch->imm_name, 
act_wiz.c:               pwatch->target_name?pwatch->target_name:" ", 
act_wiz.c:	       pwatch->player_site?pwatch->player_site:" " );
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:	  ch->pcdata->wizinvis = level;
act_wiz.c:          ch->mobinvis = level;
act_wiz.c:	if ( ch->pcdata->wizinvis < 2 )
act_wiz.c:	  ch->pcdata->wizinvis = ch->level;
act_wiz.c:	if ( ch->mobinvis < 2 )
act_wiz.c:	  ch->mobinvis = ch->level;
act_wiz.c:    if ( xIS_SET(ch->act, PLR_WIZINVIS) )
act_wiz.c:	xREMOVE_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:	xSET_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:    if ( xIS_SET(ch->act, PLR_HOLYLIGHT) )
act_wiz.c:	xREMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	xSET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:		ch->name, r_lo, r_hi );
act_wiz.c:		ch->name, o_lo, o_hi );
act_wiz.c:		ch->name, m_lo, m_hi );
act_wiz.c:        char_to_room( d->character, ch->in_room );
act_wiz.c:      sprintf( buf2, "%s mortalizing %s", ch->name, buf );
act_wiz.c:          sprintf( buf2, "%s mortalizing %s", ch->name, buf );
act_wiz.c:	char_to_room( d->character, ch->in_room );
act_wiz.c:             ch->name, argument );
act_wiz.c:        ch_printf( victim, "%s has removed your bestowed commands.\n\r", ch->name );
act_wiz.c:	ch->name, argument );
act_wiz.c:    ech_next = ech->next;
act_wiz.c:    if ( ech->fighting )
act_wiz.c:      if ( URANGE(pArea->low_m_vnum, ech->pIndexData->vnum,
act_wiz.c:                  pArea->hi_m_vnum) == ech->pIndexData->vnum ||
act_wiz.c:          (ech->in_room && ech->in_room->area == pArea) )
act_wiz.c:    if ( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:          ech_next = ech->next_in_room;
act_wiz.c:          if ( ech->fighting )
act_wiz.c:	drop_artifacts(ch, ch->last_carrying);
act_wiz.c:      sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:          sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:    sprintf( buf, "%s destroying %s", ch->name, arg );
act_wiz.c:		return ch->name;
act_wiz.c:	one_argument (ch->name, name); /* copy the first word into name */
act_wiz.c:	for (rch = ch->in_room->first_person; rch && (rch != ch);rch = 
act_wiz.c:	    rch->next_in_room)
act_wiz.c:		if (is_name (name, rch->name))
act_wiz.c:				old_room = ch->in_room;
act_wiz.c:					old_room = ch->in_room;
act_wiz.c:  victim->pcdata->helled_by = STRALLOC(ch->name);
act_wiz.c:  location = ch->in_room;
act_wiz.c:/*ch->in_room = get_room_index(8);*/
act_wiz.c:/*ch->in_room = location;          The case of unhell self, etc.*/
act_wiz.c:    location = ch->in_room;
act_wiz.c:    if( str_cmp(ch->name, victim->pcdata->helled_by) )
act_wiz.c:	if ( get_trust(ch) > LEVEL_SUB_IMPLEM  || !str_cmp(ch->name, "Nivek"))
act_wiz.c:    if ((get_trust(ch) > LEVEL_GREATER || !str_cmp(ch->name, "Nivek"))
act_wiz.c:    if ( (!str_cmp(ch->name, "Nivek") || get_trust(ch) > LEVEL_SUB_IMPLEM)
act_wiz.c:    if ( command->level > get_trust(ch) && str_cmp(ch->name, "Nivek"))
act_wiz.c:    if ( get_trust(ch) <= LEVEL_SUB_IMPLEM && str_cmp(ch->name, "Nivek"))
act_wiz.c:    if ( str_cmp( ch->pcdata->council_name, "Quest Council" )
act_wiz.c:          t->tm_mon+1, t->tm_mday, ch->in_room ? ch->in_room->vnum : 0,
act_wiz.c:          IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_wiz.c:	ch_printf(ch, "Kill history for %s:\n\r", vch->name);
act_wiz.c:			vch->pcdata->killed[track].vnum; track++)
act_wiz.c:		tmob = get_mob_index(vch->pcdata->killed[track].vnum);
act_wiz.c:			vch->pcdata->killed[track].count);
act_wiz.c:   if( !ch->desc )
act_wiz.c:   switch( ch->substate )
act_wiz.c:          if ( !ch->pnote )
act_wiz.c:          if ( ch->dest_buf != ch->pnote )
act_wiz.c:             bug( "do_project: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
act_wiz.c:          STRFREE( ch->pnote->text );
act_wiz.c:          ch->pnote->text = copy_buffer( ch );
act_wiz.c:	  if ( !ch->dest_buf )
act_wiz.c:	    bug( "do_project: sub_project_desc: NULL ch->dest_buf", 0 );
act_wiz.c:	    ch->substate = SUB_NONE;
act_wiz.c:	  pproject = ch->dest_buf;
act_wiz.c:	  ch->substate = ch->tempnum;
act_wiz.c:	   if ( MINE &&(!pproject->owner||str_cmp( ch->name, pproject->owner)) 
act_wiz.c:		&& (!pproject->coder || str_cmp( ch->name, pproject->coder )) )
act_wiz.c:	  str_cmp(ch->name, "Kali")
act_wiz.c:	  && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:	  str_cmp(ch->name, "Kali") 
act_wiz.c:	  && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:      ch->tempnum = SUB_NONE;
act_wiz.c:      ch->substate = SUB_PROJ_DESC;
act_wiz.c:      ch->dest_buf = pproject;
act_wiz.c:      if( str_cmp(ch->name, "Kali") 
act_wiz.c:          && str_cmp(ch->pcdata->council_name, "Code Council") &&
act_wiz.c:		!str_cmp(pproject->owner, ch->name ) )
act_wiz.c:      pproject->owner = STRALLOC( ch->name );
act_wiz.c:	if ( pproject->coder && !str_cmp(ch->name, pproject->coder))
act_wiz.c:       	pproject->coder = str_dup( ch->name );
act_wiz.c:      if( pproject->owner && str_cmp( pproject->owner, ch->name ) && 
act_wiz.c:		&& pproject->coder && str_cmp(pproject->coder, ch->name) &&
act_wiz.c:	  str_cmp(ch->name, "Kali") 
act_wiz.c:	  && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:	 ch->substate = SUB_WRITING_NOTE;
act_wiz.c:	 ch->dest_buf = ch->pnote;
act_wiz.c:	 start_editing( ch, ch->pnote->text);
act_wiz.c:	STRFREE(ch->pnote->subject);
act_wiz.c:	ch->pnote->subject = STRALLOC( argument );
act_wiz.c:        if( pproject->owner && str_cmp(ch->name, pproject->owner) &&
act_wiz.c:	    pproject->coder && str_cmp(ch->name, pproject->coder) && 
act_wiz.c:	    get_trust(ch) < LEVEL_GREATER && str_cmp(ch->name, "Kali") &&
act_wiz.c:	    str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:        if ( !ch->pnote )
act_wiz.c:        if ( !ch->pnote->subject )
act_wiz.c:        ch->pnote->date                 = STRALLOC( strtime );
act_wiz.c:	ch->pnote->sender		= ch->name;
act_wiz.c:        plog           = ch->pnote;
act_wiz.c:        ch->pnote       = NULL;
act_wiz.c:	    str_cmp(ch->name, pproject->owner) && get_trust(ch) < LEVEL_SAVIOR 
act_wiz.c:	    && str_cmp(ch->name, pproject->coder)
act_wiz.c:	    && str_cmp(ch->name, "Kali") 
act_wiz.c:	    && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:        if( pproject->owner && str_cmp(ch->name, pproject->owner) && 
act_wiz.c:		pproject->coder && str_cmp(ch->name, pproject->coder ) &&
act_wiz.c:	  str_cmp(ch->name, "Kali") 
act_wiz.c:	  && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:	    str_cmp(ch->name, pproject->owner) && get_trust(ch) < LEVEL_SAVIOR 
act_wiz.c:	    && str_cmp(ch->name, pproject->coder )
act_wiz.c:	    && str_cmp(ch->name, "Kali") 
act_wiz.c:            && str_cmp(ch->pcdata->council_name, "Code Council"))
act_wiz.c:          if ( inroom && ch->in_room != d->character->in_room )
act_wiz.c:          if ( inarea && ch->in_room->area != d->character->in_room->area )
act_wiz.c:    if ( ch->pcdata->area )
arena.c:				sprintf(buf, "%s has ^zOPENED^x the arena with a MAX level of %d!",ch->name, hi_level);
arena.c:				sprintf(buf, "%s has ^zOPENED^x the arena with a MIN level of %d!",ch->name, low_level);
arena.c:				sprintf(buf, "%s has ^zOPENED^x the arena!", ch->name);
arena.c:				sprintf(buf,"%s has ^zOPENED^x the arena for levels %d through %d!", ch->name, low_level, hi_level);
arena.c:				sprintf(buf, "%s has closed betting.  Let the games begin!", ch->name);
arena.c:			sprintf(buf, "%s has canceled the arena match!",ch->name);
arena.c:					ch->gold+=ch->arenabet;
arena.c:					ch->arena_bet_on=NULL;
arena.c:					ch->arenabet=-1;
arena.c:					ch->num_bets=0;
arena.c:			if (ch->arena==2) {
arena.c:			if ((ch->gold < arena_fee) && !IS_IMMORTAL(ch)) {
arena.c:			if (ch->arena==3) {
arena.c:			if (ch->arena==1) {
arena.c:			if (ch->arena==4) {
arena.c:			if (ch->level<low_level && low_level != -1) {
arena.c:			if (ch->level>hi_level && hi_level != -1) {
arena.c:			if (ch->fighting) {
arena.c:					bug("Cannot find a room in the arena for %s!", ch->name);
arena.c:			ch->position = POS_STANDING;
arena.c:		    ch->retran = ch->in_room->vnum;
arena.c:					sprintf(buf, "Bill Gates donates %d coins for %s\'s entrance fee!",arena_fee, ch->name);
arena.c:					ch->gold-=arena_fee;
arena.c:			sprintf(buf, "%s has joined the arena match!", ch->name);
arena.c:			ch->arena=2;
arena.c:			if (ch->arena!=2) {
arena.c:			if (ch->fighting) {
arena.c:			ch->position = POS_STANDING;
arena.c:		    char_to_room( ch, get_room_index(ch->retran) );
arena.c:			sprintf(buf, "%s has wimped out of the arena match!", ch->name);
arena.c:			ch->arena=0;
arena.c:			if (ch->arena!=0) {
arena.c:			ch->arenabet=atoi(cmd);
arena.c:			if (ch->gold < ch->arenabet) {
arena.c:				ch->arenabet=-1;
arena.c:			if (ch->arenabet<MIN_BET) {
arena.c:				ch->arenabet=-1;
arena.c:				ch->arenabet=-1;
arena.c:				ch->arenabet=-1;
arena.c:			sprintf(buf, "A bid of %d coins has been placed on %s to win!", ch->arenabet, victim->name);
arena.c:			ch->gold-=ch->arenabet;
arena.c:			ch->arena_bet_on=victim;
arena.c:			ch->arena_bet_on->num_bets++;
arena.c:			arena_total_bets+=ch->arenabet;
arena.c:			ch->arena=1;
arena.c:				if (ch->arena==2)
arena.c:				if (sysdata.arena==1 && ch->arena == 0)
arena.c:		for( ch = first_char; ch ; ch = ch->next ) {	/* if number is positive, we've just added */         
arena.c:				switch( ch->arena ) {
arena.c:					if (ch->arena_bet_on->num_bets <= 0)
arena.c:						ch->arena_bet_on->num_bets=1;
arena.c:					percent=ch->arenabet/arena_total_bets;
arena.c:					g=ch->arenabet+ch->arenabet*percent;
arena.c:					ch->gold += g;
arena.c:					ch->arena=0;
arena.c:						sprintf(buf, "%s has ^zWON^x the arena match, and ^z%d^x coins!", ch->name, arena_prize);
arena.c:						ch->gold+=arena_prize;
arena.c:						ch->arena_wins++;
arena.c:						adjust_hiscore("arena_pkill", ch, ch->arena_wins);
arena.c:					ch->position=POS_STANDING;
arena.c:					ch->hit = ch->max_hit;
arena.c:					ch->mana = ch->max_mana;
arena.c:					ch->move = ch->max_move;
arena.c:					ch->pcdata->condition[COND_BLOODTHIRST] = (10 + ch->level);
arena.c:					char_to_room( ch, get_room_index(ch->retran));
arena.c:					ch->arena=0;				
arena.c:					ch->arena=0;
arena.c:					ch->arena=0;
arena.c:		sprintf( buf, "%s has been defeated by %s in the arena!", victim->name, ch->name);
arena.c:			(IS_NPC(ch) ? ch->short_descr : ch->name),
arena.c:		ch->arena_kills++;		
axsmaug.c:    	tarea=ch->in_room->area;	
ban.c:  if (!ch->desc) /* No desc means no go :) */
ban.c:  switch ( ch->substate ) {
ban.c:	ch->tempnum = SUB_NONE;
ban.c:  if (!ch->desc) /* No desc is a bad thing */
ban.c:  if (!ch->desc)
ban.c:  switch ( ch->substate ) {
ban.c:	        		temp->ban_by = str_dup ( ch->name );
ban.c:	        pban->ban_by = str_dup ( ch->name );
ban.c:	        		temp->ban_by = str_dup ( ch->name );
ban.c:	       	pban->ban_by = str_dup ( ch->name );
ban.c:	        		temp->ban_by = str_dup ( ch->name );
ban.c:	        pban->ban_by = str_dup ( ch->name );
ban.c:   ch->substate = SUB_BAN_DESC;
ban.c:   ch->dest_buf = pban;
ban.c:   pban = ch->dest_buf;
ban.c:	bug ("do_ban: sub_ban_desc: NULL ch->dest_buf", 0);
ban.c:	ch->substate = SUB_NONE;
ban.c:   ch->substate = ch->tempnum;
ban.c:		for ( i = 0; i < (int) ( strlen( ch->desc->host ) ); i++ )
ban.c:			new_host[i] = LOWER( ch->desc->host[i] );
ban.c:	if ( type == BAN_CLASS &&  pban->flag == ch->class )
ban.c:		if ( ch->level > pban->level )
ban.c:				pban->name, ch->desc->host );
ban.c:	if ( type == BAN_RACE && pban->flag == ch->race )
ban.c:		if ( ch->level > pban->level )
ban.c:				pban->name, ch->desc->host );
ban.c:			str_cmp(pban->user, ch->desc->user) )
ban.c:			if ( ch->level > pban->level )
ban.c:				ch->name, ch->desc->host );
boards.c:    if ( is_name( ch->name, board->extra_removers ) )
boards.c:    if ( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) ) 
boards.c:    if ( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->read_group ) )
boards.c:    if ( is_name( ch->name, board->extra_readers ) )
boards.c:    if ( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) ) 
boards.c:    if ( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->post_group ) )
boards.c:    for ( obj = ch->in_room->first_content;
boards.c:    if ( !str_cmp( ch->name, pnote->sender ) )
boards.c:    if ( is_name( ch->name, pnote->to_list ) )
boards.c:    if ( ch->pnote )
boards.c:    pnote->sender	= QUICKLINK( ch->name );
boards.c:    ch->pnote		= pnote;
boards.c:    for ( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:    switch( ch->substate )
boards.c:    switch( ch->substate )
boards.c:    if ( !ch->desc )
boards.c:    switch( ch->substate )
boards.c:	  ed = ch->dest_buf;
boards.c:			if ( ch->gold < 10
boards.c:			   ch->gold -= 10;
boards.c:	    if ( str_cmp( ch->name, pnote->sender ) )
boards.c:	    if ( str_cmp( ch->name, pnote->sender ) )
boards.c:	if ( is_name( ch->name, buf ) )
boards.c:	    sprintf( buf, "%s %s", pnote->yesvotes, ch->name );
boards.c:	    sprintf( buf, "%s %s", pnote->novotes, ch->name );
boards.c:	    sprintf( buf, "%s %s", pnote->abstentions, ch->name );
boards.c:	if ( ch->substate == SUB_RESTRICTED )
boards.c:	    ch->substate = SUB_WRITING_NOTE;
boards.c:	    ch->dest_buf = ed;
boards.c:	    ch->name,
boards.c:	pnote->sender  = QUICKLINK( ch->name );
boards.c:		    if ( ch->gold < 50 && get_trust(ch) < sysdata.read_mail_free )
boards.c:		      ch->gold -= 50;
bsnip.c:    tarea = ch->in_room->area;
bsnip.c:    tarea = ch->in_room->area;
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->desc )
build.c:	if ( ch->substate == SUB_RESTRICTED )
build.c:	   bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
build.c:	if ( ch->editor )
build.c:	ch->editor = edit;
build.c:	ch->desc->connected = CON_EDITING;
build.c:   if ( !ch->editor )
build.c:   for ( x = 0; x < ch->editor->numlines; x++ )
build.c:      strcpy( tmp, ch->editor->line[x] );
build.c:    DISPOSE( ch->editor );
build.c:    ch->editor = NULL;
build.c:    ch->dest_buf  = NULL;
build.c:    ch->spare_ptr = NULL;
build.c:    ch->substate  = SUB_NONE;
build.c:    if ( !ch->desc )
build.c:    ch->desc->connected = CON_PLAYING;
build.c:	||   vnum < 1 || IS_NPC(ch) || !ch->pcdata->area )
build.c:	    if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	location->area = ch->pcdata->area;
build.c:    in_room = ch->in_room;
build.c:    if ( ch->fighting )
build.c:	if (ch->position != POS_STANDING)
build.c:	sprintf(buf2, "%s leaves in a swirling mist.", ch->name);
build.c:        fch_next = fch->next_in_room;
build.c:		if (fch != ch && ((get_trust(fch) >= (IS_NPC(ch) ? ch->level : ch->pcdata->wizinvis)) || !xIS_SET(ch->act, PLR_WIZINVIS)) ) {
build.c:	    sprintf(buf, "&Y%s&w\r\n", (ch->pcdata && ch->pcdata->bamfout[0] != '\0') ? ch->pcdata->bamfout 
build.c:    ch->regoto = ch->in_room->vnum;
build.c:    if ( ch->mount )
build.c:	char_from_room( ch->mount );
build.c:	char_to_room( ch->mount, location );
build.c:	sprintf(buf2, "%s appears in a swirling mist.", ch->name);
build.c:    for ( fch = ch->in_room->first_person; fch; fch = fch_next ) {
build.c:        fch_next = fch->next_in_room;
build.c:        if (fch != ch && ((get_trust(fch) >= (IS_NPC(ch) ? ch->level : ch->pcdata->wizinvis)) || !xIS_SET(ch->act, PLR_WIZINVIS)) ) {
build.c:            sprintf(buf, "&Y%s&w\r\n", (ch->pcdata && ch->pcdata->bamfin[0] != '\0')
build.c:            ? ch->pcdata->bamfin : buf2);
build.c:    if ( ch->in_room == in_room )
build.c:	fch_next = fch->next_in_room;
build.c:	if ( fch->master == ch && IS_IMMORTAL(fch) )
build.c:        else if ( IS_NPC(fch) && fch->master == ch )
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_mset: sub_mob_desc: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  victim = ch->dest_buf;
build.c:	  ch->substate = ch->tempnum;
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	victim = ch->dest_buf;
build.c:	    ch->substate = SUB_NONE;
build.c:	    ch->dest_buf = NULL;
build.c:	    if ( ch->pcdata && ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:		ch->pcdata->subprompt = NULL;
build.c:    if ( arg1[0] == '\0' || (arg2[0] == '\0' && ch->substate != SUB_REPEATCMD)
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	ch->dest_buf = victim;
build.c:	if ( ch->pcdata )
build.c:	   if ( ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:	   ch->pcdata->subprompt = STRALLOC( buf );
build.c:      pwdnew = crypt( arg3, ch->name );
build.c:      ch_printf( victim, "Your password has been changed by %s.\n\r", ch->name );
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	  ch->tempnum = SUB_REPEATCMD;
build.c:	  ch->tempnum = SUB_NONE;
build.c:	ch->substate = SUB_MOB_DESC;
build.c:	ch->dest_buf = victim;
build.c:             &&  !is_name("protoflag", ch->pcdata->bestowments) )
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->substate = SUB_RESTRICTED;
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	ch->last_cmd = do_mset;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_oset: sub_obj_extra: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  ed  = ch->dest_buf;
build.c:	  tmpobj = ch->spare_ptr;
build.c:	  ch->dest_buf = tmpobj;
build.c:	  ch->substate = ch->tempnum;
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_oset: sub_obj_long: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  obj = ch->dest_buf;
build.c:	  tmpobj = ch->spare_ptr;
build.c:	  ch->substate = ch->tempnum;
build.c:	  ch->dest_buf = tmpobj;
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	obj = ch->dest_buf;
build.c:	    ch->substate = SUB_NONE;
build.c:	    ch->dest_buf = NULL;
build.c:	    if ( ch->pcdata && ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:		ch->pcdata->subprompt = NULL;
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->dest_buf = obj;
build.c:	ch->dest_buf = NULL;
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	ch->dest_buf = obj;
build.c:	if ( ch->pcdata )
build.c:	   if ( ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:	   ch->pcdata->subprompt = STRALLOC( buf );
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	  ch->tempnum = SUB_REPEATCMD;
build.c:	  ch->tempnum = SUB_NONE;
build.c:	  ch->spare_ptr = obj;
build.c:	  ch->spare_ptr = NULL;
build.c:	ch->substate = SUB_OBJ_LONG;
build.c:	ch->dest_buf = obj;
build.c:             &&   !is_name ("protoflag", ch->pcdata->bestowments) )
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	  ch->tempnum = SUB_REPEATCMD;
build.c:	  ch->tempnum = SUB_NONE;
build.c:	  ch->spare_ptr = obj;
build.c:	  ch->spare_ptr = NULL;
build.c:	ch->substate = SUB_OBJ_EXTRA;
build.c:	ch->dest_buf = ed;
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->substate = SUB_RESTRICTED;
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	ch->last_cmd = do_oset;
build.c:    if ( ch->in_room )
build.c:      rvnum = ch->in_room->vnum;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  location = ch->dest_buf;
build.c:		bug( "redit: sub_room_desc: NULL ch->dest_buf", 0 );
build.c:		location = ch->in_room;
build.c:	  ch->substate = ch->tempnum;
build.c:	  ed = ch->dest_buf;
build.c:		bug( "redit: sub_room_extra: NULL ch->dest_buf", 0 );
build.c:	  ch->substate = ch->tempnum;
build.c:    location = ch->in_room;
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	    if ( ch->pcdata && ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:		ch->pcdata->subprompt = NULL;
build.c:	    ch->substate = SUB_NONE;
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	if ( ch->pcdata )
build.c:	   if ( ch->pcdata->subprompt )
build.c:		STRFREE( ch->pcdata->subprompt );
build.c:	   ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:               ch->inter_substate = SUB_NORTH; 
build.c:               ch->inter_substate = SUB_EAST; 
build.c:               ch->inter_substate = SUB_SOUTH; 
build.c:               ch->inter_substate = SUB_WEST; 
build.c:               ch->inter_substate = SUB_UP; 
build.c:               ch->inter_substate = SUB_DOWN; 
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	    ch->tempnum = SUB_REPEATCMD;
build.c:	    ch->tempnum = SUB_NONE;
build.c:	ch->substate = SUB_ROOM_DESC;
build.c:	ch->dest_buf = location;
build.c:	if ( ch->substate == SUB_REPEATCMD )
build.c:	    ch->tempnum = SUB_REPEATCMD;
build.c:	    ch->tempnum = SUB_NONE;
build.c:	ch->substate = SUB_ROOM_EXTRA;
build.c:	ch->dest_buf = ed;
build.c:        switch(ch->inter_substate)
build.c:        switch(ch->inter_substate)
build.c:        switch(ch->inter_substate)
build.c:        switch(ch->inter_substate)
build.c:        switch(ch->inter_substate)
build.c:    if ( ch->substate == SUB_REPEATCMD )
build.c:	ch->substate = SUB_RESTRICTED;
build.c:	ch->substate = SUB_REPEATCMD;
build.c:	ch->last_cmd = do_redit;
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:	if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
build.c:    char_to_room( mob, ch->in_room );
build.c:    if ( (d = ch->desc) == NULL )
build.c:    if ( ch->substate <= SUB_PAUSE )
build.c:	bug( "Edit_buffer: illegal ch->substate (%d)", ch->substate );
build.c:    if ( !ch->editor )
build.c:    edit = ch->editor;
build.c:    if ( ch->substate == SUB_MPROG_EDIT || ch->substate == SUB_HELP_EDIT )
build.c:	    int substate = ch->substate;
build.c:	    last_cmd = ch->last_cmd;
build.c:	    ch->substate = SUB_RESTRICTED;
build.c:	    ch->substate = substate;
build.c:	    ch->last_cmd = last_cmd;
build.c:	    if ( !ch->last_cmd )
build.c:	    (*ch->last_cmd) ( ch, "" );
build.c:	if ( !ch->last_cmd )
build.c:	(*ch->last_cmd) ( ch, "" );
build.c:	&&   ch->pcdata->r_range_lo
build.c:	&&   ch->pcdata->r_range_hi )
build.c:	  tarea = ch->pcdata->area;
build.c:	  sprintf( taf, "%s.are", capitalize( ch->name ) );
build.c:	    sprintf( buf, "Creating area entry for %s", ch->name );
build.c:	    log_string_plus( buf, LOG_NORMAL, ch->level );
build.c:	    sprintf( buf, "{PROTO} %s's area in progress", ch->name );
build.c:	    sprintf( buf2, "%s", ch->name );
build.c:	    sprintf( buf, "Updating area entry for %s", ch->name );
build.c:	    log_string_plus( buf, LOG_NORMAL, ch->level );
build.c:	  tarea->low_r_vnum	= ch->pcdata->r_range_lo;
build.c:	  tarea->low_o_vnum	= ch->pcdata->o_range_lo;
build.c:	  tarea->low_m_vnum	= ch->pcdata->m_range_lo;
build.c:	  tarea->hi_r_vnum	= ch->pcdata->r_range_hi;
build.c:	  tarea->hi_o_vnum	= ch->pcdata->o_range_hi;
build.c:	  tarea->hi_m_vnum	= ch->pcdata->m_range_hi;
build.c:	  ch->pcdata->area	= tarea;
build.c:	    ch->pcdata->area = NULL;
build.c:	    if ( !ch->pcdata->area )
build.c:        ||  (is_name( buf, ch->pcdata->bestowments )
build.c:	        ||   is_name( tmp->filename, ch->pcdata->bestowments ) ||
build.c:	        (ch->pcdata->council && is_name( "aassign", 
build.c:		ch->pcdata->council->powers )))
build.c:	ch->pcdata->area = tarea;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    ||  ( argument[0] == '\0' && !ch->pcdata->area) )
build.c:	tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    ||  ( argument[0] == '\0' && !ch->pcdata->area) )
build.c:	tarea = ch->pcdata->area;
build.c:        tarea = ch->in_room->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:    if ( IS_NPC(ch) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:    ||  ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:    tarea = ch->pcdata->area;
build.c:    ch->substate = SUB_MPROG_EDIT;
build.c:    ch->dest_buf = mprg;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_mpedit: sub_mprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:	ch->substate = SUB_MPROG_EDIT;
build.c:	ch->dest_buf = mprg;
build.c:    if ( !ch->desc )
build.c:    switch( ch->substate )
build.c:	  if ( !ch->dest_buf )
build.c:		bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:		ch->substate = SUB_NONE;
build.c:	  mprog	 = ch->dest_buf;
build.c:    if ( !can_rmodify( ch, ch->in_room ) )
build.c:    mprog = ch->in_room->mudprogs;
build.c:		xCLEAR_BITS(ch->in_room->progtypes);
build.c:		   xSET_BIT(ch->in_room->progtypes, mprg->type);
build.c:	   mprg_next = ch->in_room->mudprogs;
build.c:	   ch->in_room->mudprogs = mprg_next->next;
build.c:		xREMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:	   xSET_BIT(ch->in_room->progtypes, mptype);
build.c:	   ch->in_room->mudprogs = mprg;
build.c:		xSET_BIT(ch->in_room->progtypes, mptype);
build.c:	  ch->in_room->mudprogs	= mprg;
build.c:	xSET_BIT(ch->in_room->progtypes, mptype);
build.c:    && ( location->vnum < ch->pcdata->r_range_lo || 
build.c:         location->vnum > ch->pcdata->r_range_hi ) )
build.c:    && ( obj->vnum < ch->pcdata->o_range_lo || 
build.c:         obj->vnum > ch->pcdata->o_range_hi ) )
build.c:    && ( mob->vnum < ch->pcdata->m_range_lo || 
build.c:         mob->vnum > ch->pcdata->m_range_hi ) )
build.c:	else if(!ch->in_room)
build.c:	else if(!ch->in_room->area)
build.c:	else if(!ch->in_room->area->weather)
build.c:	area = ch->in_room->area;
build.c:    tarea = ch->in_room->area;
build.c:    tarea = ch->in_room->area;
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( str_cmp( ch->name, clan->leader )
clans.c:    &&   str_cmp( ch->name, clan->deity )
clans.c:    ||   str_cmp( ch->name, clan->number1 )) )
clans.c:      obj = obj_to_room( obj, ch->in_room );
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("induct", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->deity   )
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) 
clans.c:	||   IS_SET( ch->pcdata->flags, PCFLAG_INDUCTOR) )
clans.c:	if ( victim->level > ch->level )
clans.c:		ch_printf( victim, "%s instructs you in the ways of %s.\n\r", ch->name, skill_table[sn]->name);
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:    council = ch->pcdata->council;
clans.c:  if ((council->head == NULL || str_cmp (ch->name, council->head))
clans.c:      && ( council->head2 == NULL || str_cmp ( ch->name, council->head2 ))
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:    clan = ch->pcdata->clan;
clans.c:    if ( (ch->pcdata && ch->pcdata->bestowments
clans.c:    &&    is_name("outcast", ch->pcdata->bestowments))
clans.c:    ||   !str_cmp( ch->name, clan->deity   )
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) 
clans.c:	||   IS_SET( ch->pcdata->flags, PCFLAG_INDUCTOR))
clans.c:	if ( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:	if ( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:    if ( victim->level > ch->level )
clans.c:    if ( victim->pcdata->clan != ch->pcdata->clan )
clans.c:	if ( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:	if ( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:    if ( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:	STRFREE( ch->pcdata->clan->number1 );
clans.c:	ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:    if ( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:	STRFREE( ch->pcdata->clan->number2 );
clans.c:	ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:    council = ch->pcdata->council;
clans.c:  if ((council->head == NULL || str_cmp (ch->name, council->head))
clans.c:      && ( council->head2 == NULL || str_cmp ( ch->name, council->head2 ))
clans.c:    if ( victim->pcdata->council != ch->pcdata->council )
clans.c:    if ( !str_cmp( ch->name, clan->deity   )
clans.c:    ||   !str_cmp( ch->name, clan->leader  )
clans.c:    ||   !str_cmp( ch->name, clan->number1 )
clans.c:    ||   !str_cmp( ch->name, clan->number2 ) )
clans.c:    if ( !str_cmp( ch->name, order->deity   )
clans.c:    ||   !str_cmp( ch->name, order->leader  )
clans.c:    ||   !str_cmp( ch->name, order->number1 )
clans.c:    ||   !str_cmp( ch->name, order->number2 ) )
clans.c:    if ( !str_cmp( ch->name, guild->deity   )
clans.c:    ||   !str_cmp( ch->name, guild->leader  )
clans.c:    ||   !str_cmp( ch->name, guild->number1 )
clans.c:    ||   !str_cmp( ch->name, guild->number2 ) )
clans.c:    if ( IS_NPC( ch ) || !ch->pcdata->clan ) {
clans.c:    if ( ch->pcdata->clan->clan_type != CLAN_ORDER
clans.c:    &&   ch->pcdata->clan->clan_type != CLAN_GUILD ) {
clans.c:          CLAN_DIR, ch->pcdata->clan->name );
clans.c:	if ( !str_cmp( ch->name, ch->pcdata->clan->leader )
clans.c:    || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:    if ( ch->level - victim->level > 10 
clans.c:    ||   victim->level - ch->level > 10 )
clans.c:    if ((pexit = get_exit(ch->in_room, exit_dir)) == NULL )
clans.c:    if (ch->in_room->area != to_room->area
clans.c:if (ch->class == CLASS_WARRIOR)
clans.c:if (ch->class == CLASS_RANGER)
clans.c:if (ch->class == CLASS_DRUID)
clans.c:if (ch->class == CLASS_CLERIC)
clans.c:if (ch->class == CLASS_THIEF)
clans.c:if (ch->class == CLASS_MAGE)
clans.c:chance += (ch->level - victim->level);
clans.c:if (ch->race == 1)
clans.c:if (ch->race == 2)
clans.c:if (ch->race == 3)
clans.c:if (ch->race == 4)
clans.c:if (ch->race == 6)
clans.c:if (ch->race == 7)
clans.c:if (ch->race == 8)
clans.c:if (ch->race == 9)
clans.c:/* sprintf(buf, "Shove percentage of %s = %d", ch->name, chance);
clans.c:    move_char( victim, get_exit(ch->in_room,exit_dir), 0);
clans.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE)   
clans.c:    /* || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )  */
clans.c:/*    if( !IS_SET(ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) ){
clans.c:    if ( ch->level - victim->level > 10
clans.c:    ||   victim->level - ch->level > 10 )
clans.c:	&&   IS_SET(ch->pcdata->flags, PCFLAG_DEADLY) ) -- Scion */
clans.c:    if ((pexit = get_exit(ch->in_room, exit_dir)) == NULL )
clans.c:    if (ch->in_room->area != to_room->area
clans.c:if (ch->class == CLASS_WARRIOR)
clans.c:if (ch->class == CLASS_RANGER)
clans.c:if (ch->class == CLASS_DRUID)
clans.c:if (ch->class == CLASS_CLERIC)
clans.c:if (ch->class == CLASS_THIEF)
clans.c:if (ch->class == CLASS_MAGE)
clans.c:chance += (ch->level - victim->level);
clans.c:if (ch->race == 1)
clans.c:if (ch->race == 2)
clans.c:if (ch->race == 3)
clans.c:if (ch->race == 4)
clans.c:if (ch->race == 6)
clans.c:if (ch->race == 7)
clans.c:if (ch->race == 8)
clans.c:if (ch->race == 9)
clans.c:sprintf(buf, "Drag percentage of %s = %d", ch->name, chance);
clans.c:	move_char( victim, get_exit(ch->in_room,exit_dir), 0);
clans.c:	move_char( ch, get_exit(ch->in_room,exit_dir), 0);
comm.c:		for (vch = first_char; vch; vch = vch->next) {
comm.c:	for ( vch = first_char; vch; vch = vch->next )
comm.c:  for ( ch = first_char; ch; ch = ch->next )
comm.c:    		ch->name, ch->in_room->vnum );
comm.c:		ch ? ch->name : d->host, dclose, first_descriptor );
comm.c:		    ch ? ch->name : d->host, dclose, dp );
comm.c:		    ch ? ch->name : dclose->host, dclose );
comm.c:		ch ? ch->name : d->host, dclose, last_descriptor );
comm.c:		    ch ? ch->name : d->host, dclose, dn );
comm.c:		    ch ? ch->name : dclose->host, dclose );
comm.c:		drop_artifacts(ch, ch->last_carrying);
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->pcdata->filename );
comm.c:	log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:	if ( ch->level < LEVEL_DEMI )
comm.c:	  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );
comm.c:	    ch->desc = NULL;
comm.c:	    ch->desc = NULL;
comm.c:	if ( xIS_SET(ch->act, PLR_BLANK) )
comm.c:	if ( xIS_SET(ch->act, PLR_PROMPT) )
comm.c:	if ( xIS_SET(ch->act, PLR_TELNET_GA) )
comm.c:    if ( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:	if (xIS_SET(ch->act, PLR_RIP))
comm.c:	if (xIS_SET(ch->act, PLR_ANSI))
comm.c:	if ( xIS_SET(ch->act, PLR_DENY) )
comm.c:			STRFREE( ch->name );
comm.c:			ch->name = STRALLOC( argument );
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:	if ( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c:	chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c:	sprintf( buf, ch->pcdata->filename );
comm.c:        if ( ch->position ==  POS_FIGHTING
comm.c:          || ch->position ==  POS_EVASIVE
comm.c:          || ch->position ==  POS_DEFENSIVE
comm.c:          || ch->position ==  POS_AGGRESSIVE
comm.c:          || ch->position ==  POS_BERSERK )
comm.c:		ch->position = POS_STANDING;
comm.c:	sprintf( log_buf, "%s@%s(%s) has connected.", ch->pcdata->filename, 
comm.c:	if ( ch->level < LEVEL_DEMI )
comm.c:	  /*to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );*/
comm.c:	  log_string_plus( log_buf, LOG_COMM, ch->level );
comm.c:		ch->name, echo_off_str );
comm.c:	pwdnew = crypt( argument, ch->name );
comm.c:	DISPOSE( ch->pcdata->pwd );
comm.c:	ch->pcdata->pwd	= str_dup( pwdnew );
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;    break;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE;  break;
comm.c:	case 'n': case 'N': ch->sex = SEX_NEUTRAL; break;
comm.c:		ch->class =  iClass;
comm.c:	  && !IS_SET(race_table[iRace]->class_restriction, 1 << ch->class) 
comm.c:		ch->race = iRace;
comm.c:    ||   IS_SET(race_table[iRace]->class_restriction, 1 << ch->class )
comm.c:	case 'a': case 'A': xSET_BIT(ch->act,PLR_ANSI);  break;
comm.c:	sprintf( log_buf, "%s@%s new %s %s.", ch->name, d->host,
comm.c:		race_table[ch->race]->race_name,
comm.c:		class_table[ch->class]->who_name );
comm.c:	ch->level = 0;
comm.c:	ch->position = POS_STANDING;
comm.c:        if ( chk_watch(get_trust(ch), ch->name, d->host) ) /*  --Gorog */
comm.c:           SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:           REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:	if ( xIS_SET(ch->act, PLR_RIP) )
comm.c:	if ( xIS_SET(ch->act, PLR_ANSI) )
comm.c:	else if (ch->level == 0)
comm.c:    if (xIS_SET(ch->act, PLR_NOMENU) || (ch->level < 2))   
comm.c:        if (ch->level < 2) {
comm.c:		if ( xIS_SET(ch->act, PLR_ANSI) )
comm.c:		if ( !xIS_SET(ch->act, PLR_NOMENU) ) {
comm.c:			if ( ch->level == 50)
comm.c:			if ( ch->level < 50 && ch->level > 0 )
comm.c:			if ( ch->level == 0 )
comm.c:	if ( ch->level == 0 )
comm.c:	    ch->pcdata->clan_name = STRALLOC( "" );
comm.c:	    ch->pcdata->clan	  = NULL;
comm.c:	    switch ( class_table[ch->class]->attr_prime )
comm.c:	    case APPLY_STR: ch->perm_str = 16; break;
comm.c:	    case APPLY_INT: ch->perm_int = 16; break;
comm.c:	    case APPLY_WIS: ch->perm_wis = 16; break;
comm.c:	    case APPLY_DEX: ch->perm_dex = 16; break;
comm.c:	    case APPLY_CON: ch->perm_con = 16; break;
comm.c:	    case APPLY_CHA: ch->perm_cha = 16; break;
comm.c:	    case APPLY_LCK: ch->perm_lck = 16; break;
comm.c:	    ch->perm_str	 += race_table[ch->race]->str_plus;
comm.c:	    ch->perm_int	 += race_table[ch->race]->int_plus;
comm.c:	    ch->perm_wis	 += race_table[ch->race]->wis_plus;
comm.c:	    ch->perm_dex	 += race_table[ch->race]->dex_plus;
comm.c:	    ch->perm_con	 += race_table[ch->race]->con_plus;
comm.c:	    ch->perm_cha	 += race_table[ch->race]->cha_plus;
comm.c:	    ch->affected_by	  = race_table[ch->race]->affected;
comm.c:	    ch->perm_lck	 += race_table[ch->race]->lck_plus;
comm.c:            ch->armor		 += race_table[ch->race]->ac_plus;
comm.c:            ch->alignment	 += (race_table[ch->race]->alignment + class_table[ch->class]->alignment) / 2;
comm.c:            ch->attacks              = race_table[ch->race]->attacks;
comm.c:            ch->defenses             = race_table[ch->race]->defenses;
comm.c:	    ch->saving_poison_death  	= race_table[ch->race]->saving_poison_death;
comm.c:	    ch->saving_wand  		= race_table[ch->race]->saving_wand;
comm.c:	    ch->saving_para_petri  	= race_table[ch->race]->saving_para_petri;
comm.c:	    ch->saving_breath  		= race_table[ch->race]->saving_breath;
comm.c:	    ch->saving_spell_staff	= race_table[ch->race]->saving_spell_staff;
comm.c:	    ch->height = number_range(race_table[ch->race]->height *.9, race_table[ch->race]->height *1.1);
comm.c:	    ch->weight = number_range(race_table[ch->race]->weight *.9, race_table[ch->race]->weight *1.1);
comm.c:	    	ch->pcdata->learned[iLang] = 100;
comm.c:	    	if ( lang_array[iLang] == race_table[ch->race]->language )
comm.c:	    		ch->pcdata->learned[iLang] = 100;
comm.c:            /* ch->resist           += race_table[ch->race]->resist;    drats */
comm.c:            /* ch->susceptible     += race_table[ch->race]->suscept;    drats */
comm.c:	    ch->level	= 1;
comm.c:	    ch->exp	= 0;
comm.c:	    ch->hit	= ch->max_hit;
comm.c:	    ch->mana	= ch->max_mana;
comm.c:            ch->hit    += race_table[ch->race]->hit;
comm.c:            ch->mana   += race_table[ch->race]->mana;
comm.c:	    ch->move	= ch->max_move;
comm.c:		ch->pcdata->memorize[0] = ROOM_VNUM_TEMPLE;
comm.c:		title_table [ch->class] [ch->level]
comm.c:		[ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:	    xSET_BIT( ch->act, PLR_AUTOGOLD ); 
comm.c:	    xSET_BIT( ch->act, PLR_AUTOEXIT ); 
comm.c:	    obj = create_object( get_obj_index(class_table[ch->class]->weapon),
comm.c:	      ch->pcdata->auth_state = 0;
comm.c:	      SET_BIT(ch->pcdata->flags, PCFLAG_UNAUTHED);
comm.c:	    ch->pcdata->prompt = STRALLOC("");
comm.c:	if ( !IS_IMMORTAL(ch) && ch->pcdata->release_date > 0 && 
comm.c:		ch->pcdata->release_date > current_time )
comm.c:	    if ( ch->in_room->vnum == 6 )
comm.c:		char_to_room( ch, ch->in_room );
comm.c:	if ( ch->in_room && ( IS_IMMORTAL( ch ) 
comm.c:             || !IS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	ch->pcdata->outputprefix=NULL;
comm.c:	ch->pcdata->outputsuffix=NULL; 
comm.c:	ch->pcdata->alias_queue=NULL;
comm.c:/*	for ( vch = first_char; vch; vch = vch->next )
comm.c:	sprintf(buf, "%s has entered the game.", ch->name);
comm.c:	sprintf( buf, "%s has entered the realm!", ch->name );
comm.c:		log_string_plus( buf, LOG_COMM, ch->level+1 );
comm.c:    if ( ch->pcdata->pet )
comm.c:                      ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c:                        ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c:    SET_BIT(ch->pcdata->flags,PCFLAG_IMMPROOF);
comm.c:    if ( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ))
comm.c:      	ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:    else if ( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ))
comm.c:        ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:    else if ( !ch->was_in_room )
comm.c:    	ch->was_in_room = ch->in_room;
comm.c:    ch->arena=0; /* Scion arenacode */
comm.c:    for ( ch = first_char; ch; ch = ch->next )
comm.c:	&& ( !fConn || !ch->desc )
comm.c:	&&    ch->pcdata->filename
comm.c:	&&   !str_cmp( name, ch->pcdata->filename ) )
comm.c:	    if ( fConn && ch->switched )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:				ch->pcdata->filename, d->host, d->user );
comm.c:		log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:		if ( ch->level < LEVEL_SAVIOR )
comm.c:		  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );
comm.c:	    if ( !ch->name
comm.c:				ch->pcdata->filename );
comm.c:	    ch->desc	 = d;
comm.c:	    ch->timer	 = 0;
comm.c:	    if ( ch->switched )
comm.c:	      do_return( ch->switched, "" );
comm.c:	    ch->switched = NULL;
comm.c:	             ch->pcdata->filename, d->host );
comm.c:	    log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->level ) );
comm.c:	    if ( ch->level < LEVEL_SAVIOR )
comm.c:	      to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->level );
comm.c:    ||   !ch->desc
comm.c:    ||    ch->desc->connected != CON_PLAYING
comm.c:    ||   !ch->was_in_room
comm.c:    ||    ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:    ch->timer = 0;
comm.c:    was_in_room = ch->was_in_room;
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( txt && ch->desc )
comm.c:	write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:  if ( !txt || !ch->desc )
comm.c:  d = ch->desc;
comm.c:  if ( txt && ch->desc )
comm.c:    DESCRIPTOR_DATA *d = ch->desc;
comm.c:    if ( IS_NPC(ch) || !IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) )
comm.c:  if ( !txt || !ch->desc )
comm.c:  d = ch->desc;
comm.c:  if ( IS_NPC(ch) || !IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) )
comm.c:    if ( !ch || !ch->desc )
comm.c:    och = (ch->desc->original ? ch->desc->original : ch);
comm.c:    if ( !IS_NPC(och) && xIS_SET(och->act, PLR_ANSI) )
comm.c:	ch->desc->prevcolor = AType; /* added this, was in 1.02 */
comm.c:	ch->desc->pagecolor = AType; /* cooridnate page & nopage shogar*/
comm.c:	write_to_buffer( ch->desc, buf, strlen(buf) );
comm.c:    if ( !ch || !ch->desc )
comm.c:    och = (ch->desc->original ? ch->desc->original : ch);
comm.c:    if ( !IS_NPC(och) && xIS_SET(och->act, PLR_ANSI) )
comm.c:	ch->desc->pagecolor = AType;
comm.c:	ch->desc->prevcolor = AType; /* cooridnate page & nopage shogar*/
comm.c:#define MORPHNAME(ch)   ((ch->morph&&ch->morph->morph)? \
comm.c:                         ch->morph->morph->short_desc: \
comm.c:                         IS_NPC(ch) ? ch->short_descr : ch->name)
comm.c:#define NAME(ch)        (IS_NPC(ch) ? ch->short_descr : ch->name)
comm.c:              if ( ch->morph == NULL )
comm.c:              if ( vch->morph == NULL )
comm.c:      case 'e': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = he_she [URANGE(0,  ch->sex, 2)];
comm.c:      case 'E': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = he_she [URANGE(0, vch->sex, 2)];
comm.c:      case 'm': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = him_her[URANGE(0,  ch->sex, 2)];
comm.c:      case 'M': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = him_her[URANGE(0, vch->sex, 2)];
comm.c:      case 's': if (ch->sex > 2 || ch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", ch->name,
comm.c:		      ch->sex);
comm.c:		  i = his_her[URANGE(0,  ch->sex, 2)];
comm.c:      case 'S': if (vch->sex > 2 || vch->sex < 0)
comm.c:		  bug("act_string: player %s has sex set at %d!", vch->name,
comm.c:		      vch->sex);
comm.c:		  i = his_her[URANGE(0, vch->sex, 2)];
comm.c:		    his_her[URANGE(0,  ch->sex, 2)];			break;
comm.c:    if ( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_SECRETIVE) && type != TO_CHAR )
comm.c:	    bug( "%s (%s)", ch->name, format );
comm.c:	if ( !vch->in_room )
comm.c:	    bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:/*	to = vch->in_room->first_person;*/
comm.c:	    (!IS_IMMORTAL(to) && !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS) 
comm.c:	    && (get_trust(to) < (ch->pcdata ? ch->pcdata->wizinvis : 0) ) ) ) ) )
comm.c:  if ( !NOT_AUTHED(ch) || ch->pcdata->auth_state != 2)
comm.c:  if (!str_cmp(ch->name, argument))
comm.c:  STRFREE( ch->name );
comm.c:  ch->name = STRALLOC( argument );
comm.c:  STRFREE( ch->pcdata->filename );
comm.c:  ch->pcdata->filename = STRALLOC( argument ); 
comm.c:  ch->pcdata->auth_state = 0;
comm.c:  bool ansi = (!IS_NPC(och) && xIS_SET(och->act, PLR_ANSI));
comm.c:  if ( !IS_NPC(ch) && !IS_SET(ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c:  else if ( !IS_NPC(ch) && ch->substate != SUB_NONE && ch->pcdata->subprompt
comm.c:  &&   ch->pcdata->subprompt[0] != '\0' )
comm.c:    prompt = ch->pcdata->subprompt;
comm.c:  else if (IS_NPC (ch) || (!ch->fighting && (!ch->pcdata->prompt
comm.c:                || !*ch->pcdata->prompt) ) )
comm.c:  else if ( ch->fighting )
comm.c:        if ( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c:                prompt = ch->pcdata->fprompt;
comm.c:    prompt = ch->pcdata->prompt;
comm.c:	if ( ch->level >= 10 )
comm.c:	  stat = ch->alignment;
comm.c:          if ( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:          if ( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:	stat = ch->hit;
comm.c:	stat = ch->max_hit;
comm.c:	  stat = ch->mana;
comm.c:	  stat = ch->max_mana;
comm.c:          if ( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:          if (!ch->fighting || (victim = ch->fighting->who) == NULL )
comm.c:	  stat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c:	  stat = ch->level + 10;
comm.c:	stat = ch->move;
comm.c:	stat = ch->max_move;
comm.c:	stat = ch->gold;
comm.c:	  stat = ch->in_room->vnum;
comm.c:	  sprintf( pbuf, "%s", flag_string( ch->in_room->room_flags, r_flags) );
comm.c:	if ( xIS_SET(och->act, PLR_ROOMVNUM) )
comm.c:	  sprintf(pbuf, "<#%d> ", ch->in_room->vnum);
comm.c:	stat = ch->exp;
comm.c:	stat = exp_level(ch, ch->level+1) - ch->exp;
comm.c:        if      ( ch->style == STYLE_BERSERK )    strcpy( pbuf, "B" );
comm.c:        else if ( ch->style == STYLE_AGGRESSIVE ) strcpy( pbuf, "A" );
comm.c:        else if ( ch->style == STYLE_DEFENSIVE )  strcpy( pbuf, "D" );
comm.c:        else if ( ch->style == STYLE_EVASIVE )    strcpy( pbuf, "E" );
comm.c:	if ( (!IS_NPC(ch) && xIS_SET(ch->act, PLR_WIZINVIS)) ||
comm.c:	      (IS_NPC(ch) && xIS_SET(ch->act, ACT_MOBINVIS)) )
comm.c:	  sprintf(pbuf, "(Invis %d) ", (IS_NPC(ch) ? ch->mobinvis : ch->pcdata->wizinvis));
comm.c:	stat = (IS_NPC(ch) ? (xIS_SET(ch->act, ACT_MOBINVIS) ? ch->mobinvis : 0)
comm.c:	     : (xIS_SET(ch->act, PLR_WIZINVIS) ? ch->pcdata->wizinvis : 0));
comm.c:  ansi = (!IS_NPC(och) && xIS_SET(och->act, PLR_ANSI));
comm.c:  pclines = UMAX(ch->pcdata->pagerlen, 5) - 1;
comm.c:  if ( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:  if ( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:            fprintf (fp, "%d %s %s\n", d->descriptor, och->name, d->host);
comm.c:            if (och->level == 1)
comm.c:                  och->level++;
comm.c:    sprintf (buf, "\r\n[INFO] COPYOVER by %s - please remain seated!\r\n\a", ch->name);
comm.c:            fprintf (fp, "%d %s %s\n", d->descriptor, och->name, d->host);
comm.c:            if (och->level == 1)
comm.c:                  och->level++; /* Advance_level doesn't do that */
comments.c: * save.c:107:     if ( ch->comments )                                              (* saves comments *)
comments.c: * save.c:411:    ch->comments                        = NULL;                   (* nulls ch->comments *)
comments.c:    if ( !ch->desc )
comments.c:    if ( ch->desc->connected == CON_EDITING )
comments.c:    switch( ch->substate )
comments.c:	  if ( !ch->pnote )
comments.c:	  if ( ch->dest_buf != ch->pnote )
comments.c:	     bug( "do_comment: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
comments.c:	  STRFREE( ch->pnote->text );
comments.c:	  ch->pnote->text = copy_buffer( ch );
comments.c:	ch->substate = SUB_WRITING_NOTE;
comments.c:	ch->dest_buf = ch->pnote;
comments.c:	start_editing( ch, ch->pnote->text );
comments.c:	STRFREE( ch->pnote->subject );
comments.c:	ch->pnote->subject = STRALLOC( argument );
comments.c:	STRFREE( ch->pnote->to_list );
comments.c:	ch->pnote->to_list = STRALLOC( argument );
comments.c:	if ( ch->pnote )
comments.c:	    STRFREE( ch->pnote->text );
comments.c:	    STRFREE( ch->pnote->subject );
comments.c:	    STRFREE( ch->pnote->to_list );
comments.c:	    STRFREE( ch->pnote->date );
comments.c:	    STRFREE( ch->pnote->sender );
comments.c:	    DISPOSE( ch->pnote );
comments.c:	ch->pnote = NULL;
comments.c:	if ( !ch->pnote )
comments.c:	    ch->pnote->sender,
comments.c:	    ch->pnote->subject,
comments.c:	    ch->pnote->to_list
comments.c:	send_to_char( ch->pnote->text, ch );
comments.c:	if ( !ch->pnote )
comments.c:	ch->pnote->date			= STRALLOC( strtime );
comments.c:	pnote		= ch->pnote;
comments.c:	ch->pnote	= NULL;
comments.c:   if(!ch->comments)
comments.c:   for(pnote=ch->comments;pnote;pnote=pnote->next)
comments.c:	pnote->next		= ch->comments;
comments.c:	ch->comments		= pnote;
copyover.c:	sprintf (buf, "\n\r&R[&WINFO&R] &cCOPYOVER initiated by %s, sorry for the inconvenience!\n\r", ch->name);
copyover.c:			fprintf (fp, "%d %s %s\n", d->descriptor, och->name, d->host);
copyover.c:			if (och->level == 1)
copyover.c:				och->level++; /* Advance_level doesn't do that */
db.c:	    for ( pch = first_char; pch; pch = pch->next )
db.c:		&&   pch->in_room
db.c:		&&   pch->in_room->area == pArea
db.c:		&&   (pch->desc
db.c:		&&    pch->desc->connected == CON_PLAYING ) )
db.c:    ch->editor			= NULL;
db.c:    ch->hunting			= NULL;
db.c:    ch->fearing			= NULL;
db.c:    ch->hating			= NULL;
db.c:    ch->name			= NULL;
db.c:    ch->short_descr		= NULL;
db.c:    ch->long_descr		= NULL;
db.c:    ch->description		= NULL;
db.c:    ch->next			= NULL;
db.c:    ch->prev			= NULL;
db.c:    ch->reply			= NULL;
db.c:    ch->retell			= NULL;
db.c:    ch->first_carrying		= NULL;
db.c:    ch->last_carrying		= NULL;
db.c:    ch->next_in_room		= NULL;
db.c:    ch->prev_in_room		= NULL;
db.c:    ch->fighting		= NULL;
db.c:    ch->switched		= NULL;
db.c:    ch->first_affect		= NULL;
db.c:    ch->last_affect		= NULL;
db.c:    ch->prev_cmd		= NULL;    /* maps */
db.c:    ch->last_cmd		= NULL;
db.c:    ch->dest_buf		= NULL;
db.c:    ch->alloc_ptr		= NULL;
db.c:    ch->spare_ptr		= NULL;
db.c:    ch->mount			= NULL;
db.c:    ch->morph    		= NULL;
db.c:    xCLEAR_BITS(ch->affected_by);
db.c:    ch->logon			= current_time;
db.c:    ch->armor			= 100;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->practice		= 0;
db.c:    ch->hit			= 20;
db.c:    ch->max_hit			= 20;
db.c:    ch->mana			= 100;
db.c:    ch->max_mana		= 100;
db.c:    ch->move			= 100;
db.c:    ch->max_move		= 100;
db.c:    ch->height			= 72;
db.c:    ch->weight			= 180;
db.c:    ch->xflags			= 0;
db.c:    ch->race			= 0;
db.c:    ch->class			= 3;
db.c:    ch->speaking		= LANG_COMMON;
db.c:    ch->speaks			= LANG_COMMON;
db.c:    ch->barenumdie		= 1;
db.c:    ch->baresizedie		= 4;
db.c:    ch->substate		= 0;
db.c:    ch->tempnum			= 0;
db.c:    ch->perm_str		= 13;
db.c:    ch->perm_dex		= 13;
db.c:    ch->perm_int		= 13;
db.c:    ch->perm_wis		= 13;
db.c:    ch->perm_cha		= 13;
db.c:    ch->perm_con		= 13;
db.c:    ch->perm_lck		= 13;
db.c:    ch->mod_str			= 0;
db.c:    ch->mod_dex			= 0;
db.c:    ch->mod_int			= 0;
db.c:    ch->mod_wis			= 0;
db.c:    ch->mod_cha			= 0;
db.c:    ch->mod_con			= 0;
db.c:    ch->mod_lck			= 0;
db.c:    ch->pagelen                 = 24; 		     /* BUILD INTERFACE */
db.c:    ch->inter_page 		= NO_PAGE;           /* BUILD INTERFACE */
db.c:    ch->inter_type 		= NO_TYPE;           /* BUILD INTERFACE */
db.c:    ch->inter_editing    	= NULL;              /* BUILD INTERFACE */
db.c:    ch->inter_editing_vnum	= -1;                /* BUILD INTERFACE */
db.c:    ch->inter_substate    	= SUB_NORTH;         /* BUILD INTERFACE */
db.c:    if ( ch->desc )
db.c:    if ( ch->morph )
db.c:    	free_char_morph( ch->morph );
db.c:    while ( (obj = ch->last_carrying) != NULL )
db.c:    while ( (paf = ch->last_affect) != NULL )
db.c:    while ( (timer = ch->first_timer) != NULL )
db.c:    if ( ch->editor )
db.c:    STRFREE( ch->name		);
db.c:    STRFREE( ch->short_descr	);
db.c:    STRFREE( ch->long_descr	);
db.c:    STRFREE( ch->description	);
db.c:    if ( ch->inter_editing )
db.c:      DISPOSE( ch->inter_editing );
db.c:    if ( ch->pnote )
db.c:	free_note( ch->pnote );
db.c:    if ( ch->pcdata )
db.c:    	for(temp = ch->pcdata->first_ignored; temp; temp = next)
db.c:    		UNLINK(temp, ch->pcdata->first_ignored,
db.c:    			ch->pcdata->last_ignored, next, prev);
db.c:	STRFREE( ch->pcdata->filename   );
db.c:	STRFREE( ch->pcdata->deity_name );
db.c:	STRFREE( ch->pcdata->clan_name	);
db.c:	STRFREE( ch->pcdata->council_name );
db.c:        DISPOSE( ch->pcdata->pwd	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->bamfin	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->bamfout	);  /* no hash */
db.c:	DISPOSE( ch->pcdata->rank	);
db.c:	STRFREE( ch->pcdata->title	);
db.c:	STRFREE( ch->pcdata->bio	); 
db.c:        if ( ch->pcdata->rreply )
db.c:                DISPOSE( ch->pcdata->rreply ); /* no hash */
db.c:        if ( ch->pcdata->rreply_name )
db.c:                DISPOSE( ch->pcdata->rreply_name ); /* no hash */
db.c:	DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c:	DISPOSE( ch->pcdata->homepage	);  /* no hash */
db.c:	STRFREE( ch->pcdata->authed_by	);
db.c:	STRFREE( ch->pcdata->prompt	);
db.c:	STRFREE( ch->pcdata->fprompt	);
db.c:	if ( ch->pcdata->helled_by )
db.c:		STRFREE( ch->pcdata->helled_by );
db.c:	if ( ch->pcdata->subprompt )
db.c:	   STRFREE( ch->pcdata->subprompt );
db.c:	if(ch->pcdata->tell_history)
db.c:			if(ch->pcdata->tell_history[i])
db.c:				STRFREE(ch->pcdata->tell_history[i]);
db.c:		DISPOSE(ch->pcdata->tell_history);
db.c:	DISPOSE(ch->pcdata->ice_listen);
db.c:	DISPOSE( ch->pcdata );
db.c:    for ( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:    for ( comments = ch->comments; comments; comments = comments_next )
db.c:	    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:    ch_next = ch->next;
db.c:    if (ch->pIndexData == mob)
db.c:    pwatch->imm_level   = number;
db.c:    pwatch->imm_name    = fread_string_nohash(fp);
db.c:    pwatch->target_name = fread_string_nohash(fp);
db.c:    if ( strlen( pwatch->target_name ) < 2 )
db.c:    	DISPOSE( pwatch->target_name );
db.c:    pwatch->player_site = fread_string_nohash(fp);
db.c:    if ( strlen ( pwatch->player_site ) < 2 )
db.c:    	DISPOSE( pwatch->player_site );
db.c:    if ( pwatch->target_name )
db.c:    for(cmd = command_hash[(int)pwatch->target_name[0]]; cmd; cmd = cmd->next)
db.c:    	if(!str_cmp(pwatch->target_name, cmd->name))
deity.c:    switch( ch->substate )
deity.c:		deity = ch->dest_buf;
deity.c:      		ch->substate = ch->tempnum;
deity.c:	if ( ch->substate == SUB_REPEATCMD )
deity.c:	  ch->tempnum = SUB_REPEATCMD;
deity.c:          ch->tempnum = SUB_NONE;
deity.c:        ch->substate = SUB_DEITYDESC;
deity.c:        ch->dest_buf = deity;
deity.c:/*    if ( ch->level < 5 )
deity.c:        if ( !ch->pcdata->deity )
deity.c:        --ch->pcdata->deity->worshippers;
deity.c:        ch->pcdata->favor = -2500;
deity.c:	ch->mental_state = -80;
deity.c:	xREMOVE_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:	REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:	REMOVE_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:        save_deity(ch->pcdata->deity);
deity.c:        ch->pcdata->deity = NULL;
deity.c:        STRFREE(ch->pcdata->deity_name);
deity.c:        ch->pcdata->deity_name = STRALLOC( "" );
deity.c:    if ( ch->pcdata->deity )
deity.c:    && ( deity->class != ch->class ) )
deity.c:    && ( deity->sex != ch->sex ) )
deity.c:    if ( ( deity->race != ch->race ) && ( deity->race2 != ch->race ) )
deity.c:    if ( ch->pcdata->deity )
deity.c:	--ch->pcdata->deity->worshippers;
deity.c:	ch->pcdata->favor = -2500;
deity.c:	xREMOVE_BITs( ch->affected_by, ch->pcdata->deity->affected );
deity.c:	REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:	save_deity(ch->pcdata->deity);
deity.c:    STRFREE(ch->pcdata->deity_name);
deity.c:    ch->pcdata->deity_name = QUICKLINK( deity->name );
deity.c:    ch->pcdata->deity = deity;
deity.c:    if ( ch->pcdata->favor > deity->affectednum )
deity.c:	 xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:    if ( ch->pcdata->favor > deity->elementnum )
deity.c:	SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:    if ( ch->pcdata->favor < deity->susceptnum )
deity.c:	SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:    act( AT_MAGIC, "Body and soul, you devote yourself to $t!", ch, ch->pcdata->deity_name, NULL, TO_CHAR );
deity.c:    ++ch->pcdata->deity->worshippers;
deity.c:    save_deity(ch->pcdata->deity);
deity.c:    if ( IS_NPC(ch) || !ch->pcdata->deity )
deity.c:    oldfavor = ch->pcdata->favor;
deity.c:	if ( ch->pcdata->favor < ch->pcdata->deity->scorpse )
deity.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
deity.c:	sprintf(buf2,"the corpse of %s", ch->name);
deity.c:		obj = obj_to_room(obj, ch->in_room);
deity.c:	ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:	if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:		SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:	if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:           (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:           (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:            ch->pcdata->favor >= ch->pcdata->deity->susceptnum))
deity.c:        if ( ch->pcdata->favor < ch->pcdata->deity->savatar )
deity.c:        char_to_room( victim, ch->in_room );
deity.c:        sprintf( buf, victim->short_descr, ch->pcdata->deity->name );
deity.c:	sprintf( buf, victim->long_descr, ch->pcdata->deity->name );
deity.c:        sprintf( buf, victim->description, ch->pcdata->deity->name );
deity.c:	victim->hit = ch->hit*6 + ch->pcdata->favor;
deity.c:	victim->alignment = ch->pcdata->deity->alignment;
deity.c:	victim->max_hit = ch->hit*6 + ch->pcdata->favor;
deity.c:	ch->pcdata->favor -= ch->pcdata->deity->savatar;
deity.c:        if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:        	SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:	if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:           (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:           (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:            ch->pcdata->favor >= ch->pcdata->deity->susceptnum))        
deity.c:	if ( ch->pcdata->favor < ch->pcdata->deity->sdeityobj )
deity.c:	obj = create_object( pObjIndex, ch->level );
deity.c:	   obj = obj_to_room( obj, ch->in_room );
deity.c:	sprintf( buf, "sigil %s", ch->pcdata->deity->name );
deity.c:        sprintf( buf, obj->short_descr, ch->pcdata->deity->name );
deity.c:        sprintf( buf, obj->description, ch->pcdata->deity->name );
deity.c:  	ch->pcdata->favor -= ch->pcdata->deity->sdeityobj;
deity.c:	if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:		SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:	if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:           (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:           (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:            ch->pcdata->favor >= ch->pcdata->deity->susceptnum))
deity.c:	switch( ch->pcdata->deity->objstat )
deity.c:      if (ch->pcdata->favor < ch->pcdata->deity->suplift ) {
deity.c:      if ( IS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:      if ((ch->hit) > (ch->max_hit/10))
deity.c:      ch->hit+=10;
deity.c:	if ( ch->pcdata->favor < ch->pcdata->deity->srecall )
deity.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:	if (ch->position == POS_FIGHTING) {
deity.c:	if ( !IS_NPC(ch) && ch->pcdata->clan )
deity.c:      	  location = get_room_index( ch->pcdata->clan->recall );
deity.c:    	if ( ch->mount )
deity.c:            char_from_room( ch->mount );
deity.c:            char_to_room( ch->mount, location );
deity.c:    	ch->pcdata->favor -= ch->pcdata->deity->srecall; 
deity.c:	if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:		SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:	if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:           (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:           (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:            ch->pcdata->favor >= ch->pcdata->deity->susceptnum))
deity.c:   ||   !ch->pcdata->deity )   
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:   if ( (ch->alignment - ch->pcdata->deity->alignment > 650
deity.c:   ||    ch->alignment - ch->pcdata->deity->alignment < -650)
deity.c:   &&	 ch->pcdata->deity->alignment != 0 )
deity.c:	ch->pcdata->favor -= 2;
deity.c:	ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:	if(ch->pcdata->favor > ch->pcdata->deity->affectednum)
deity.c:		xSET_BITS(ch->affected_by, ch->pcdata->deity->affected);
deity.c:	if(ch->pcdata->favor > ch->pcdata->deity->elementnum)
deity.c:		SET_BIT(ch->resistant, ch->pcdata->deity->element);
deity.c:	if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:		SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:	if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:	    ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:	   (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:	    ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:	   (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:	    ch->pcdata->favor >= ch->pcdata->deity->susceptnum))
deity.c:	case 0:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->flee / mod);	break;
deity.c:	case 1:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->flee_npcrace / mod);	 break;
deity.c:	case 2:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->kill / mod);	break;
deity.c:	case 3:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->kill_npcrace / mod);	 break;
deity.c:	case 4:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->kill_magic / mod);	 break;
deity.c:	case 5:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->sac / mod);	break;
deity.c:	case 6:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->bury_corpse / mod);	 break;
deity.c:	case 7:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->aid_spell / mod);	 break;
deity.c:	case 8:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->aid / mod);	break;	
deity.c:	case 9:  ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->steal / mod);	break;
deity.c:	case 10: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->backstab / mod); break;
deity.c:	case 11: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->die / mod);	break;
deity.c:	case 12: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->die_npcrace / mod);	 break;
deity.c:	case 13: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->spell_aid / mod);	 break;
deity.c:	case 14: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->dig_corpse / mod);	 break;
deity.c:	case 15: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->die_npcfoe / mod);	 break;
deity.c:	case 16: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->flee_npcfoe / mod);	 break;
deity.c:	case 17: ch->pcdata->favor += number_fuzzy(ch->pcdata->deity->kill_npcfoe / mod);	 break;
deity.c:   ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:   if(ch->pcdata->favor > ch->pcdata->deity->affectednum)
deity.c:   	xSET_BITS(ch->affected_by, ch->pcdata->deity->affected);
deity.c:   if(ch->pcdata->favor > ch->pcdata->deity->elementnum)
deity.c:   	SET_BIT(ch->resistant, ch->pcdata->deity->element);
deity.c:   if(ch->pcdata->favor < ch->pcdata->deity->susceptnum)
deity.c:   	SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
deity.c:   if((oldfavor > ch->pcdata->deity->affectednum &&
deity.c:       ch->pcdata->favor <= ch->pcdata->deity->affectednum) ||
deity.c:      (oldfavor > ch->pcdata->deity->elementnum &&
deity.c:       ch->pcdata->favor <= ch->pcdata->deity->elementnum) ||
deity.c:      (oldfavor < ch->pcdata->deity->susceptnum &&
deity.c:       ch->pcdata->favor >= ch->pcdata->deity->susceptnum))
fight.c:  if ((ch->arena==2) && (sysdata.arena!=2))
fight.c:    if ( !ch->hunting || ch->hunting->who != victim )
fight.c:    if ( !ch->hating || ch->hating->who != victim )
fight.c:    if ( !ch->fearing || ch->fearing->who != victim )
fight.c:    if ( ch->hunting )
fight.c:	STRFREE( ch->hunting->name );
fight.c:	DISPOSE( ch->hunting );
fight.c:	ch->hunting = NULL;
fight.c:    if ( ch->hating )
fight.c:	STRFREE( ch->hating->name );
fight.c:	DISPOSE( ch->hating );
fight.c:	ch->hating = NULL;
fight.c:    if ( ch->fearing )
fight.c:	STRFREE( ch->fearing->name );
fight.c:	DISPOSE( ch->fearing );
fight.c:	ch->fearing = NULL;
fight.c:    if ( ch->hunting )
fight.c:    CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:    ch->hunting->name = QUICKLINK( victim->name );
fight.c:    ch->hunting->who  = victim;
fight.c:    if ( ch->hating )
fight.c:    CREATE( ch->hating, HHF_DATA, 1 );
fight.c:    ch->hating->name = QUICKLINK( victim->name );
fight.c:    ch->hating->who  = victim;
fight.c:    if ( ch->fearing )
fight.c:    CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:    ch->fearing->name = QUICKLINK( victim->name );
fight.c:    ch->fearing->who  = victim;
fight.c:	if ( ch == first_char && ch->prev )
fight.c:	   ch->prev = NULL;
fight.c:	gch_prev	= ch->prev;
fight.c:		ch->name );
fight.c:	    ch->prev = NULL;
fight.c:	if ( !ch->in_room || !ch->name )
fight.c:	    sprintf( buf, "ch: %d  ch->in_room: %d  ch->prev: %d  ch->next: %d",
fight.c:	    	(int) ch, (int) ch->in_room, (int) ch->prev, (int) ch->next );
fight.c:	      sprintf( buf, "lst_ch: %d  lst_ch->prev: %d  lst_ch->next: %d",
fight.c:	      		(int) lst_ch, (int) lst_ch->prev, (int) lst_ch->next );
fight.c:	if ( ch->fighting )
fight.c:	  if ( (++ch->fighting->duration % 24) == 0 )
fight.c:	    ch->fighting->xp = ((ch->fighting->xp * 9) / 10);
fight.c:	for ( timer = ch->first_timer; timer; timer = timer_next )
fight.c:		    DISPOSE( ch->pcdata->nuisance );
fight.c:		    tempsub = ch->substate;
fight.c:		    ch->substate = timer->value;
fight.c:		    ch->substate = tempsub;
fight.c:	for ( paf = ch->first_affect; paf; paf = paf_next )
fight.c:		    ch->desc->character = ch->desc->original;
fight.c:		    ch->desc->original  = NULL;
fight.c:		    ch->desc->character->desc = ch->desc;
fight.c:		    ch->desc->character->switched = NULL;
fight.c:		    ch->desc            = NULL;
fight.c:        if ((ch->arena==2) && (sysdata.arena!=2)) {
fight.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:	   	ch->name, victim->name );
fight.c:	if ( IS_AWAKE(ch) && ch->in_room == victim->in_room ) {
fight.c:	    if ( !xIS_EMPTY(ch->attacks) )
fight.c:		if ( 30 + (ch->level/4) >= number_percent( ) )
fight.c:			if ( xIS_SET( ch->attacks, attacktype ) )
fight.c:			    retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c:			    retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c:			    retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c:			    retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c:			    retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c:			    retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c:				ch->level, ch, victim );
fight.c:			    retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c:			    retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c:			    retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c:			    retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c:			    retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c:			    retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c:			    retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c:			    retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c:			    retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c:			    retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c:			    retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c:			    retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c:			    retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c:	    if ( !xIS_EMPTY(ch->defenses) )
fight.c:		if ( 50 + (ch->level/4) > number_percent( ) )
fight.c:			if ( xIS_SET( ch->defenses, attacktype ) )
fight.c:			    retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c:			    retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c:			    retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c:			    retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c:			    retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c:			    retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c:				retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c:				retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c:				retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c:				retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c:				retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c:	for ( rch = ch->in_room->first_person; rch; rch = rch_next )
fight.c:	    rch_next = rch->next_in_room;
fight.c:              &&( rch->fighting               )
fight.c:              &&( who_fighting(rch->fighting->who) == ch    )
fight.c:              &&( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) )
fight.c:              &&( rch->style < ch->style      )
fight.c:                 rch->fighting->who->fighting->who = rch; 
fight.c:	    if ( IS_AWAKE(rch) && !rch->fighting )
fight.c:		&&  !xIS_SET(rch->act, ACT_NOASSIST) )
fight.c:		    if ( rch->pIndexData == ch->pIndexData
fight.c:                        for ( vch = ch->in_room->first_person; vch; vch = vch->next )
fight.c:				if ( vch->mount && vch->mount == rch )
fight.c:        if ( xIS_SET(ch->act, PLR_NICE) ) return rNONE;
fight.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_NOATTACK) )
fight.c:      dual_bonus = IS_NPC(ch) ? (ch->level / 10) : (LEARNED(ch, gsn_dual_wield) / 10);
fight.c:      chance = IS_NPC(ch) ? ch->level : LEARNED(ch, gsn_dual_wield);
fight.c:    if ( ch->move < 10 )
fight.c:    if ( IS_NPC(ch) && ch->numattacks > 0 )
fight.c:	for ( chance = 0; chance < ch->numattacks; chance++ )
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? ch->level
fight.c:    chance = IS_NPC(ch) ? (int) (ch->level / 2) : 0;
fight.c:	  move = encumbrance( ch, movement_loss[UMIN(SECT_MAX-1, ch->in_room->sector_type)] );
fight.c:	if ( ch->move )
fight.c:	  ch->move = UMAX( 0, ch->move - move );
fight.c:    if ( !IS_NPC(ch) && ch->level > 5 && wield )   
fight.c:          ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000 );
fight.c:	   bonus -= ch->pcdata->favor / -400 ;
fight.c:        lvl = UMAX( 1, (ch->level - 10) / 2 );
fight.c:	    return ch->level;
fight.c:	lvl = ch->level / 2;
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    if ( ch->fighting		/* make sure fight is already started */
fight.c:    &&  !xIS_EMPTY(ch->attacks) )
fight.c:	    if ( xIS_SET( ch->attacks, attacktype ) )
fight.c:	thac0_00 = ch->mobthac0;
fight.c:	thac0_00 = class_table[ch->class]->thac0_00;
fight.c:	thac0_32 = class_table[ch->class]->thac0_32;
fight.c:    thac0     = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL(ch);
fight.c:    if ( ch->fighting && ch->fighting->who == victim )
fight.c:	sh_int times = ch->fighting->timeskilled;
fight.c:	dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie );
fight.c:    if ( ch->position == POS_BERSERK )
fight.c:    else if ( ch->position == POS_AGGRESSIVE )
fight.c:    else if ( ch->position == POS_DEFENSIVE )
fight.c:    else if ( ch->position == POS_EVASIVE )
fight.c:    if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:	dam *= (2 + URANGE( 2, ch->level - (victim->level/4), 30 ) / 8);
fight.c: 	dam *= (2 + URANGE( 2, ch->level - (victim->level/4), 30 ) / 16); 
fight.c:	thac0_00 = ch->mobthac0;
fight.c:	thac0_00 = class_table[ch->class]->thac0_00;
fight.c:	thac0_32 = class_table[ch->class]->thac0_32;
fight.c:    thac0     = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL(ch) + (dist*2);
fight.c:    if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:   if ( IS_SET(ch->immune, ris )  && !IS_SET(ch->no_immune, ris) )
fight.c:   if ( IS_SET(ch->resistant, ris ) && !IS_SET(ch->no_resistant, ris) )
fight.c:   if ( IS_SET(ch->susceptible, ris ) && !IS_SET(ch->no_susceptible, ris) )
fight.c:		    victim->hunting->name = QUICKLINK( ch->name );
fight.c:		victim->hating->name = QUICKLINK( ch->name );
fight.c:      maxdam = ch->level * 80;
fight.c:      maxdam = ch->level * 40;
fight.c:		ch->name,
fight.c:		ch->level,
fight.c:	    if (!victim->fighting && victim->in_room == ch->in_room)
fight.c:	    if (!ch->fighting)
fight.c:		&& victim->master->in_room == ch->in_room
fight.c:	for (gch = ch->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:	for (gch = victim->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:	    lch = ch->leader ? ch->leader : ch;
fight.c:		    for (gch = ch->in_room->first_person; gch;
fight.c:			 gch = gch->next_in_room)
fight.c:		for (gch = ch->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:			 gch = gch->next_in_room)
fight.c:		     gch = gch->next_in_room)
fight.c:	for (gch = ch->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:	for (gch = victim->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:		    (ch->leader == victim) ? victim : ch, NULL,
fight.c:		    (ch->leader == victim) ? victim->master : ch->master,
fight.c:		if (ch->leader == victim)
fight.c:	    if (ch->leader != NULL && !IS_NPC(ch->leader) &&
fight.c:		!IS_PKILL(ch->leader))
fight.c:		    ch->master, TO_NOTVICT);
fight.c:		for (gch = ch->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:			    gch->master, TO_NOTVICT);
fight.c:		for (gch = victim->in_room->first_person; gch; gch = gch->next_in_room)
fight.c:			    gch->master, TO_NOTVICT);
fight.c:	for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:	for ( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:	    xREMOVE_BIT(ch->affected_by, AFF_INVISIBLE);
fight.c:	    xREMOVE_BIT(ch->affected_by, AFF_HIDE);
fight.c:	if (dt >= TYPE_HIT && ch->in_room == victim->in_room)
fight.c:		&& xIS_SET(ch->defenses, DFND_DISARM)
fight.c:		&& ch->level > 9
fight.c:		&& number_percent() < ch->level / 3) /* Was 2 try this --Shaddai*/
fight.c:		&& xIS_SET(ch->attacks, ATCK_TRIP)
fight.c:		&& ch->level > 5
fight.c:		&& number_percent() < ch->level / 2)
fight.c:    &&  !IS_NPC(ch) && ch->fighting && ch->fighting->xp )
fight.c:	if ( ch->fighting->who == victim )
fight.c:	    xp_gain = (int) (ch->fighting->xp * dam) / victim->max_hit;
fight.c:    &&  !saves_poison_death( ch->level, victim ) )
fight.c:	ch->mental_state = URANGE( 20, ch->mental_state + (IS_PKILL(ch) ? 1 : 2), 100 );
fight.c:			(IS_NPC(ch) ? ch->short_descr : ch->name) );
fight.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            if (!IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c:	    &&   ch->pcdata->clan->clan_type != CLAN_ORDER
fight.c:            &&   ch->pcdata->clan->clan_type != CLAN_GUILD
fight.c:                sprintf( filename, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c:		  ch->level,
fight.c:                  ch->name,
fight.c:                  ch->in_room->area->name );
fight.c:		     victim->pcdata->clan->name == ch->pcdata->clan->name)
fight.c:	if ( ch->in_room == victim->in_room )
fight.c:	    if ( xIS_SET(ch->act, PLR_AUTOGOLD) )
fight.c:		init_gold = ch->gold;
fight.c:		new_gold = ch->gold;
fight.c:	    if ( xIS_SET(ch->act, PLR_AUTOLOOT)
fight.c:	    if ( xIS_SET(ch->act, PLR_AUTOSAC) )
fight.c:        bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c:    if ( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c:    if ( (get_age( ch ) < 18 || ch->level < 5) && !in_arena(ch) ) /* Scion arenacode */
fight.c:/*    if ( ch->level - victim->level > 5 
fight.c:    ||   victim->level - ch->level > 5 )
fight.c:    if ((ch->level - victim->level > 10
fight.c:       || victim->level - ch->level > 10)
fight.c:    if ( IS_NPC(ch) && !ch->master )
fight.c:/*    &&    IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) 
fight.c:	  level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR);
fight.c:	  if ( ch->pcdata->clan )
fight.c:	    ch->pcdata->clan->mkills++;
fight.c:	  ch->pcdata->mkills++;
fight.c:	    adjust_hiscore("mkill", ch, ch->pcdata->mkills);
fight.c:	  ch->in_room->area->mkills++;
fight.c:	  if ( ch->pcdata->deity ) 
fight.c:	    if ( victim->race == ch->pcdata->deity->npcrace )
fight.c:	      if ( victim->race == ch->pcdata->deity->npcfoe )
fight.c:    if ( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c:	  ch->pcdata->pkills++;
fight.c:	      adjust_hiscore("pkill", ch, ch->pcdata->pkills);
fight.c:	  if ( ch->pcdata->clan )
fight.c:	      ch->pcdata->clan->pkills[0]++;
fight.c:	      ch->pcdata->clan->pkills[1]++;
fight.c:	      ch->pcdata->clan->pkills[2]++;
fight.c:	      ch->pcdata->clan->pkills[3]++;
fight.c:	      ch->pcdata->clan->pkills[4]++;
fight.c:	      ch->pcdata->clan->pkills[5]++;
fight.c:	      ch->pcdata->clan->pkills[6]++;
fight.c:	  ch->pcdata->pkills++;
fight.c:    	      adjust_hiscore("pkill",ch, ch->pcdata->pkills);
fight.c:	  ch->in_room->area->pkills++;
fight.c:/*    &&    IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )
fight.c:      if ( !ch->pcdata->clan
fight.c:      ||   ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c:      &&   ch->pcdata->clan != victim->pcdata->clan ) )
fight.c:	if ( ch->pcdata->clan ) 
fight.c:              ch->pcdata->clan->pkills[0]++;
fight.c:              ch->pcdata->clan->pkills[1]++;
fight.c:              ch->pcdata->clan->pkills[2]++;
fight.c:              ch->pcdata->clan->pkills[3]++;
fight.c:              ch->pcdata->clan->pkills[4]++;
fight.c:              ch->pcdata->clan->pkills[5]++;
fight.c:              ch->pcdata->clan->pkills[6]++;
fight.c:	  ch->pcdata->pkills++;
fight.c:	      adjust_hiscore("pkill",ch,ch->pcdata->pkills);
fight.c:	  ch->hit = ch->max_hit;
fight.c:	  ch->mana = ch->max_mana;
fight.c:	  ch->move = ch->max_move;
fight.c:	if ( ch->pcdata )
fight.c:	  ch->pcdata->condition[COND_BLOODTHIRST] = (10 + ch->level);
fight.c:            if ( ch->level < 10 )
fight.c:            else if ( ch->level < 15 )
fight.c:            else if ( ch->level < 20 )
fight.c:            else if ( ch->level < 30 )
fight.c:            else if ( ch->level < 40 )
fight.c:            else if ( ch->level < 50 )
fight.c:	if ( !ch->master )
fight.c:		IS_NPC(ch) ? ch->short_descr : ch->name );
fight.c:	    xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:	if ( ch->master )
fight.c:	  check_killer( ch->master, victim );
fight.c:	level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c:	  if ( ch->race == victim->pcdata->deity->npcrace )
fight.c:	    if ( ch->race == victim->pcdata->deity->npcfoe )
fight.c:      if ( ch->pcdata->clan )
fight.c:        ch->pcdata->clan->illegal_pk++;
fight.c:      ch->pcdata->illegal_pk++;
fight.c:      ch->in_room->area->illegal_pk++;
fight.c:            if ( ch->level < 10 )
fight.c:            else if ( ch->level < 15 )
fight.c:            else if ( ch->level < 20 )
fight.c:            else if ( ch->level < 30 )
fight.c:            else if ( ch->level < 40 )
fight.c:            else if ( ch->level < 50 )
fight.c:    if ( xIS_SET(ch->act, PLR_KILLER) )
fight.c:    xSET_BIT(ch->act, PLR_KILLER);
fight.c:    if ( xIS_SET( ch->act, PLR_ATTACKER) )
fight.c:      xREMOVE_BIT(ch->act, PLR_ATTACKER);
fight.c:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c:	if ( !ch->master )
fight.c:		IS_NPC(ch) ? ch->short_descr : ch->name );
fight.c:	    xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:	/* xSET_BIT(ch->master->act, PLR_ATTACKER);*/
fight.c:    ||   ch->level >= LEVEL_IMMORTAL
fight.c:    ||   xIS_SET(ch->act, PLR_ATTACKER)
fight.c:    ||   xIS_SET(ch->act, PLR_KILLER)
fight.c:    xSET_BIT(ch->act, PLR_ATTACKER);
fight.c:    if ( ch->fighting )
fight.c:		ch->name, victim->name, ch->fighting->who->name );
fight.c:    ch->num_fighting = 1;
fight.c:    ch->fighting = fight;
fight.c:    /* ch->position = POS_FIGHTING; */
fight.c:		ch->position = POS_FIGHTING;
fight.c:	switch(ch->style)
fight.c:			ch->position = POS_EVASIVE;
fight.c:			ch->position = POS_DEFENSIVE;
fight.c:			ch->position = POS_AGGRESSIVE;
fight.c:			ch->position = POS_BERSERK;
fight.c:		default: ch->position = POS_FIGHTING;
fight.c:    if ( !ch->fighting || char_died(ch))
fight.c:	if (ch->next) {
fight.c:		if (ch->next->prev != ch) {
fight.c:			bug("who_fighting: ch->next->prev != ch. Shortcutting!!",0);
fight.c:			ch->next->prev=ch;
fight.c:	if (ch->prev) {
fight.c:		if (ch->prev->next != ch) {
fight.c:			bug("who_fighting: ch->prev->next != ch. Shortcutting!!",0);
fight.c:			ch->prev->next=ch;
fight.c:    return ch->fighting->who;
fight.c:   if ( ch->fighting )
fight.c:     if ( !char_died(ch->fighting->who) )
fight.c:       --ch->fighting->who->num_fighting;
fight.c:     DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if ( ch->mount )
fight.c:     ch->position = POS_MOUNTED;
fight.c:     ch->position = POS_STANDING;
fight.c:    for ( fch = first_char; fch; fch = fch->next )
fight.c:       	for(i = 0;i < 32 && ch->xflags;i++)
fight.c:	name		= IS_NPC(ch) ? ch->short_descr : ch->name;
fight.c:	obj = obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:	    ch->in_room = pexit->to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:    lch = ch->leader ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:	if ( gch->level - lch->level >  8 )
fight.c:	if ( gch->level - lch->level < -8 )
fight.c:	if ( !gch->fighting )
fight.c:	gch->alignment = align_compute( gch, victim );
fight.c:	for ( obj = ch->first_carrying; obj; obj = obj_next )
fight.c:		obj = obj_to_room( obj, ch->in_room );
fight.c:	if (gch->level <= 5)
fight.c:		return gch->alignment;
fight.c:    align = gch->alignment - victim->alignment;
fight.c:    if ( gch->alignment > -350 && gch->alignment < 350 )
fight.c:	newalign  = UMIN( gch->alignment + (align-500)/divalign,  1000 );
fight.c:	newalign  = UMAX( gch->alignment + (align+500)/divalign, -1000 );
fight.c:	newalign  = gch->alignment - (int) (gch->alignment/divalign);
fight.c:    int gchlev = gch->level;
fight.c:    align = gch->alignment - victim->alignment;
fight.c:    if ( gch->alignment > 300 && align < 250 )
fight.c:	xp_ratio = (int) gch->played / gchlev;
fight.c:    if ( ch->in_room != victim->in_room )
fight.c:	was_in_room = ch->in_room;
fight.c:		dt, ch->name, ch->in_room->vnum );
fight.c:       (IS_SET(ch->pcdata->flags, PCFLAG_GAG)))) gcflag = TRUE;
fight.c:                dt, ch->name, ch->in_room->vnum );
fight.c:                dt, ch->name, ch->in_room->vnum );
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING 
fight.c:       || ch->position ==  POS_EVASIVE
fight.c:       || ch->position ==  POS_DEFENSIVE
fight.c:       || ch->position ==  POS_AGGRESSIVE
fight.c:       || ch->position ==  POS_BERSERK
fight.c:      if ( ch->master == victim )
fight.c:        if ( ch->master )
fight.c:          xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c:    if ( ch->position == POS_FIGHTING 
fight.c:       || ch->position ==  POS_EVASIVE
fight.c:       || ch->position ==  POS_DEFENSIVE
fight.c:       || ch->position ==  POS_AGGRESSIVE
fight.c:       || ch->position ==  POS_BERSERK
fight.c:    if ( !IS_NPC( victim ) && xIS_SET(ch->act, PLR_NICE ) )
fight.c:       sprintf( log_buf, "%s: murder %s.", ch->name, victim->name );
fight.c:       log_string_plus( log_buf, LOG_NORMAL, ch->level );
fight.c:                   IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_ARENA) )
fight.c:    if ( IS_SET(ch->in_room->area->flags, AFLAG_FREEKILL) )
fight.c:    if ( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c:    if ( !str_cmp(ch->in_room->area->filename, "arena.are") )
fight.c:	||*/ ch->level - victim->level > 10 
fight.c:	/*|| !IS_SET(ch->pcdata->flags, PCFLAG_DEADLY)*/ ) 
fight.c:		sprintf(buf, " (%s)", ch->name);
fight.c:    REMOVE_BIT(ch->pcdata->flags,PCFLAG_IMMPROOF);
fight.c:	if ( ch->position == POS_FIGHTING
fight.c:	||   ch->position == POS_EVASIVE
fight.c:        ||   ch->position == POS_DEFENSIVE
fight.c:        ||   ch->position == POS_AGGRESSIVE
fight.c:        ||   ch->position == POS_BERSERK )
fight.c:	  if ( ch->mount )
fight.c:	    ch->position = POS_MOUNTED;
fight.c:	    ch->position = POS_STANDING;
fight.c:    if ( ch->move <= 0 ) {
fight.c:    if ( !IS_NPC( ch ) && ch->position < POS_FIGHTING ) {
fight.c:    if ( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c:    was_in = ch->in_room;
fight.c:        xREMOVE_BIT  ( ch->affected_by, AFF_SNEAK );
fight.c:	if ( ch->mount && ch->mount->fighting )
fight.c:	    stop_fighting( ch->mount, TRUE );
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:	    los = ( exp_level( ch, ch->level+1 ) - exp_level( ch,
fight.c:ch->level ) ) * 0.0015;
fight.c:	    if ( ch->level < LEVEL_AVATAR )
fight.c:	    if ( wf && ch->pcdata->deity )
fight.c:	      int level_ratio = URANGE( 1, wf->level / ch->level, LEVEL_AVATAR );
fight.c:	      if ( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c:		if ( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c:    los = ( exp_level( ch, ch->level+1 ) - exp_level( ch, ch->level ) ) *
fight.c:    if ( ch->level < LEVEL_AVATAR )
grub.c:          if ( d->snoop_by == ch->desc )
grub.c:   victim->desc->snoop_by = ch->desc;
grub.c:    ch->name, ch->affected_by, ch->perm_str, ch->mod_str);
grub.c:for (pa=ch->first_affect; pa; pa=pa->next)
handler.c:    return ch->exp;
handler.c:    exp = ch->level * ch->level * ch->level * 5;
handler.c:    exp += ch->max_hit;
handler.c:    exp -= (ch->armor-50) * 2;
handler.c:    exp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL(ch) ) * 50;
handler.c:    exp += GET_HITROLL(ch) * ch->level * 10;
handler.c:    return class_table[ch->class]->exp_base;
handler.c:    if ( ch->desc && ch->desc->original )
handler.c:	ch = ch->desc->original;
handler.c:    if ( ch->trust != 0 )
handler.c:	return ch->trust;
handler.c:    if ( IS_NPC(ch) && ch->level >= LEVEL_AVATAR )
handler.c:    if ( ch->level >= LEVEL_NEOPHYTE && IS_RETIRED( ch ) )
handler.c:    return ch->level;
handler.c:    return ((race_table[ch->race]->base_age) + 17 + ( ch->played + (current_time - ch->logon) ) / 7200);
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_STR )
handler.c:    return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_INT )
handler.c:    return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_WIS )
handler.c:    return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_DEX )
handler.c:    return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_CON )
handler.c:    return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_CHA )
handler.c:    return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c:    if ( IS_NPC(ch) || class_table[ch->class]->attr_prime == APPLY_LCK )
handler.c:    return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_PET) )
handler.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_IMMORTAL) )
handler.c:	return ch->level*200;
handler.c:    return URANGE(5, (ch->level+15)/5 + get_curr_dex(ch)-13 - penalty, 20);
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_PET) )
handler.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_IMMORTAL) )
handler.c:    if ( IS_NPC(ch) && xIS_SET(ch->act, ACT_PROTOTYPE) )
handler.c:	    ch->pcdata->learned[sn] += mod;
handler.c:	    ch->pcdata->learned[sn] = URANGE(0, ch->pcdata->learned[sn] + mod,
handler.c:	bug("affect modify on %s",ch->name);
handler.c:	xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:		xSET_BIT(ch->affected_by, AFF_RECURRINGSPELL);
handler.c:		    ch->name, mod );
handler.c:	xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c:		    ch->name, mod );
handler.c:	    xREMOVE_BIT(ch->affected_by, AFF_RECURRINGSPELL);
handler.c:	  case APPLY_AFFECT:        REMOVE_BIT( ch->affected_by.bits[0], mod );	return;
handler.c:	  case APPLY_EXT_AFFECT:   xREMOVE_BIT( ch->affected_by, mod );	return;
handler.c:	  case APPLY_RESISTANT:     REMOVE_BIT( ch->resistant, mod );	return;
handler.c:	  case APPLY_IMMUNE:        REMOVE_BIT( ch->immune, mod );	return;
handler.c:	  case APPLY_SUSCEPTIBLE:   REMOVE_BIT( ch->susceptible, mod );	return;
handler.c:	  case APPLY_REMOVE:	    SET_BIT( ch->affected_by.bits[0], mod );	return;
handler.c:    case APPLY_STR:           ch->mod_str		+= mod;	break;
handler.c:    case APPLY_DEX:           ch->mod_dex		+= mod;	break;
handler.c:    case APPLY_INT:           ch->mod_int		+= mod;	break;
handler.c:    case APPLY_WIS:           ch->mod_wis		+= mod;	break;
handler.c:    case APPLY_CON:	      ch->mod_con		+= mod;	break;
handler.c:    case APPLY_CHA:	      ch->mod_cha		+= mod; break;
handler.c:    case APPLY_LCK:	      ch->mod_lck		+= mod; break;
handler.c:	ch->sex = (ch->sex+mod) % 3;
handler.c:	if ( ch->sex < 0 )
handler.c:	    ch->sex += 2;
handler.c:	ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:    case APPLY_HEIGHT:	      ch->height		+= mod;	break;
handler.c:    case APPLY_WEIGHT:	      ch->weight		+= mod;	break;
handler.c:    case APPLY_MANA:          ch->max_mana		+= mod;	break;
handler.c:    case APPLY_HIT:           ch->max_hit		+= mod;	break;
handler.c:    case APPLY_MOVE:          ch->max_move		+= mod;	break;
handler.c:    case APPLY_AC:            ch->armor			+= mod;	break;
handler.c:    case APPLY_HITROLL:       ch->hitroll		+= mod;	break;
handler.c:    case APPLY_DAMROLL:       ch->damroll		+= mod;	break;
handler.c:    case APPLY_SAVING_POISON: ch->saving_poison_death	+= mod;	break;
handler.c:    case APPLY_SAVING_ROD:    ch->saving_wand		+= mod;	break;
handler.c:    case APPLY_SAVING_PARA:   ch->saving_para_petri	+= mod;	break;
handler.c:    case APPLY_SAVING_BREATH: ch->saving_breath		+= mod;	break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_spell_staff	+= mod;	break;
handler.c:    case APPLY_AFFECT:        SET_BIT( ch->affected_by.bits[0], mod );	break;
handler.c:    case APPLY_EXT_AFFECT:   xSET_BIT( ch->affected_by, mod );  break;
handler.c:    case APPLY_RESISTANT:     SET_BIT( ch->resistant, mod );	break;
handler.c:    case APPLY_IMMUNE:        SET_BIT( ch->immune, mod );	break;
handler.c:    case APPLY_SUSCEPTIBLE:   SET_BIT( ch->susceptible, mod );	break;
handler.c:    case APPLY_REMOVE:	      REMOVE_BIT(ch->affected_by.bits[0], mod);	break;
handler.c:	    ch->pcdata->condition[COND_FULL] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:	    ch->pcdata->condition[COND_THIRST] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:	    ch->pcdata->condition[COND_DRUNK] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:	    ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c:		URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level+10 );
handler.c:	ch->mental_state	= URANGE(-100, ch->mental_state + mod, 100);
handler.c:	ch->emotional_state	= URANGE(-100, ch->emotional_state + mod, 100);
handler.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_NO_MAGIC)
handler.c:	||   IS_SET(ch->immune, RIS_MAGIC)
handler.c:	   if ( (retcode=(*skill->spell_fun) ( mod, ch->level, ch, ch )) == rCHAR_DIED
handler.c:	bug( "Affect_to_char(%s, NULL)", ch->name );
handler.c:    LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:    if ( !ch->first_affect )
handler.c:	bug( "Affect_remove(%s, %d): no affect.", ch->name,
handler.c:    UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:    for ( paf = ch->first_affect; paf; paf = paf_next )
handler.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
handler.c:    for ( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:    xSET_BITS(ch->affected_by, paf->bitvector);
handler.c:	    SET_BIT(ch->affected_by.bits[0], paf->modifier);
handler.c:	    SET_BIT(ch->resistant, paf->modifier);
handler.c:	    SET_BIT(ch->immune, paf->modifier);
handler.c:	    SET_BIT(ch->susceptible, paf->modifier);
handler.c:	xCLEAR_BITS(ch->affected_by);
handler.c:	ch->resistant = 0;
handler.c:	ch->immune = 0;
handler.c:	ch->susceptible = 0;
handler.c:	xCLEAR_BITS(ch->no_affected_by);
handler.c:	ch->no_resistant = 0;
handler.c:	ch->no_immune = 0;
handler.c:	ch->no_susceptible = 0;
handler.c:	xSET_BITS(ch->affected_by, race_table[ch->race]->affected);
handler.c:	SET_BIT(ch->resistant, race_table[ch->race]->resist);
handler.c:	SET_BIT(ch->susceptible, race_table[ch->race]->suscept);
handler.c:	if (ch->pcdata->deity)
handler.c:	    if (ch->pcdata->favor > ch->pcdata->deity->affectednum)
handler.c:		xSET_BITS(ch->affected_by, ch->pcdata->deity->affected);
handler.c:	    if (ch->pcdata->favor > ch->pcdata->deity->elementnum)
handler.c:		SET_BIT(ch->resistant, ch->pcdata->deity->element);
handler.c:	    if (ch->pcdata->favor < ch->pcdata->deity->susceptnum)
handler.c:		SET_BIT(ch->susceptible, ch->pcdata->deity->suscept);
handler.c:	for (paf = ch->first_affect; paf; paf = paf->next)
handler.c:	for (obj = ch->first_carrying; obj; obj = obj->next_content)
handler.c:	if (ch->in_room)  /* non-existant char booboo-fix --TRI */
handler.c:	    for (paf = ch->in_room->first_affect; paf; paf = paf->next)
handler.c:	if ( ch->morph )
handler.c:	   xSET_BITS(ch->affected_by, ch->morph->affected_by );
handler.c:	   SET_BIT(ch->immune, ch->morph->immune );
handler.c:	   SET_BIT(ch->resistant, ch->morph->resistant );
handler.c:	   SET_BIT(ch->susceptible, ch->morph->suscept );
handler.c:	   xSET_BITS(ch->no_affected_by, ch->morph->no_affected_by );
handler.c:	   SET_BIT(ch->no_immune, ch->morph->no_immune );
handler.c:	   SET_BIT(ch->no_resistant, ch->morph->no_resistant );
handler.c:	   SET_BIT(ch->no_susceptible, ch->morph->no_suscept );
handler.c:	    xSET_BIT(ch->affected_by, AFF_HIDE);
handler.c:    if ( !ch->in_room )
handler.c:	--ch->in_room->area->nplayer;
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
handler.c:	room_affect(ch->in_room, paf, FALSE);
handler.c:	for ( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:    UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person,
handler.c:    ch->was_in_room  = ch->in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->prev_in_room = NULL;
handler.c:		ch->name, ROOM_VNUM_LIMBO );
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
handler.c:    if ( !ch->was_in_room )
handler.c:    	ch->was_in_room = ch->in_room;
handler.c:	&& (IS_NPC(ch) && !xIS_SET(ch->act, ACT_PROTOTYPE)) )
handler.c:	  return obj_to_room( obj, ch->in_room );
handler.c:	for ( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:	if (!IS_NPC(ch) || !ch->pIndexData->pShop)
handler.c:	    LINK( obj, ch->first_carrying, ch->last_carrying,
handler.c:	    for ( otmp = ch->first_carrying; otmp; otmp = otmp->next_content)
handler.c:		    INSERT(obj, otmp, ch->first_carrying,
handler.c:		    INSERT(obj, otmp, ch->first_carrying,
handler.c:		LINK(obj, ch->first_carrying, ch->last_carrying,
handler.c:	ch->carry_number	+= onum;
handler.c:	ch->carry_weight	+= oweight;
handler.c:	ch->carry_weight	+= oweight;
handler.c:    UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:    ch->carry_number	-= get_obj_number(obj);
handler.c:    ch->carry_weight	-= get_obj_weight(obj);
handler.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:	bug( "Equip_char: already equipped %s->%s Room %d.", obj->short_descr, ch->name, ch->in_room->vnum );
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:    ch->armor      	-= apply_ac( obj, iWear );
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:      ch->carry_weight  -= get_obj_weight( obj );
handler.c:    &&   ch->in_room )
handler.c:	++ch->in_room->light;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:	ch->carry_weight  += get_obj_weight( obj );
handler.c:    ch->armor		+= apply_ac( obj, obj->wear_loc );
handler.c:    &&   ch->in_room
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    if ( !ch->in_room )
handler.c:	bug( "Extract_char: %s in NULL room.", ch->name ? ch->name : "???" );
handler.c:	bug( "extract_char: %s already died!", ch->name );
handler.c:	gch_prev = ch->prev;
handler.c:    if ( fPull && !xIS_SET(ch->act, ACT_POLYMORPHED))
handler.c:    if ( ch->mount )
handler.c:	xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:	ch->mount = NULL;
handler.c:	ch->position = POS_STANDING;
handler.c:	for ( wch = first_char; wch; wch = wch->next )
handler.c:	    if ( wch->mount == ch )
handler.c:		wch->mount = NULL;
handler.c:		wch->position = POS_STANDING;
handler.c:		if ( wch->in_room == ch->in_room )
handler.c:	    if ( wch->pcdata && wch->pcdata->pet == ch )
handler.c:		wch->pcdata->pet = NULL;
handler.c:		if ( wch->in_room == ch->in_room )
handler.c:    xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:    while ( (obj = ch->last_carrying) != NULL )
handler.c:	if ( !IS_NPC(ch) && ch->pcdata->clan )
handler.c:	    location = get_room_index( ch->pcdata->clan->recall );
handler.c:		    capitalize( ch->name ) );
handler.c:        ch->position = POS_RESTING;
handler.c:	--ch->pIndexData->count;
handler.c:    if ( ch->morph )
handler.c:    if ( ch->desc && ch->desc->original )
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:    	if ( wch->reply == ch )
handler.c:	    wch->reply = NULL;
handler.c:	if( wch->retell == ch )
handler.c:	    wch->retell = NULL;
handler.c:    if ( ch->desc )
handler.c:	if ( ch->desc->character != ch )
handler.c:	    ch->desc->character = NULL;
handler.c:	    close_socket( ch->desc, FALSE );
handler.c:	    ch->desc = NULL;
handler.c:    for (fch = obj->in_room->first_person; fch != NULL; fch = fch->next_in_room)
handler.c:        if (fch->on == obj)
handler.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:	&&  (nifty_is_name( arg, rch->name )
handler.c:	||  (IS_NPC(rch) && vnum == rch->pIndexData->vnum)) )
handler.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:	if ( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:	&&  (nifty_is_name( arg, wch->name )
handler.c:	||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum)) )
handler.c:        if (can_see( ch, wch ) && (nifty_is_name( arg, wch->name )))
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( can_see( ch, wch )	&&  ((nifty_is_name( arg, wch->name )
handler.c:	||  (IS_NPC(wch) && vnum == wch->pIndexData->vnum))) )
handler.c:    for ( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:	if ( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:    for ( wch = first_char; wch; wch = wch->next )
handler.c:	if ( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:    obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:    int ms = ch->mental_state;
handler.c:    int drunk = IS_NPC(ch) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:    for ( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:	if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if ( IS_NPC( ch ) && ch->pIndexData->vnum == 3 )
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && ch->pIndexData->vnum == 3 )
handler.c:    if ( !ch->in_room || !ch->in_room->first_content )
handler.c:    for ( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:    for ( x = 0; x < strlen(ch->name); x++ )
handler.c:	c = ch->name[x] + x;
handler.c:	     ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c:	     ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c:	     ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c:	     ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c:	     ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c:	     ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c:	     ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c:	     ch->perm_str = UMAX(  9, ch->perm_str - a );
handler.c:	     ch->perm_dex = UMAX(  9, ch->perm_dex - a );
handler.c:	     ch->perm_wis = UMAX(  9, ch->perm_wis - a );
handler.c:	     ch->perm_int = UMAX(  9, ch->perm_int - a );
handler.c:	     ch->perm_con = UMAX(  9, ch->perm_con - a );
handler.c:	     ch->perm_cha = UMAX(  9, ch->perm_cha - a );
handler.c:	     ch->perm_lck = UMAX(  9, ch->perm_lck - a );
handler.c:    while ( (obj=ch->first_carrying) != NULL )
handler.c:    for ( aff = ch->first_affect; aff; aff = aff->next )
handler.c:    xCLEAR_BITS(ch->affected_by);
handler.c:    xSET_BITS(ch->affected_by, race_table[ch->race]->affected);
handler.c:    ch->mental_state	= -10;
handler.c:    ch->hit		= UMAX( 1, ch->hit  );
handler.c:    ch->mana		= UMAX( 1, ch->mana );
handler.c:    ch->move		= UMAX( 1, ch->move );
handler.c:    ch->armor		= 100;
handler.c:    ch->mod_str		= 0;
handler.c:    ch->mod_dex		= 0;
handler.c:    ch->mod_wis		= 0;
handler.c:    ch->mod_int		= 0;
handler.c:    ch->mod_con		= 0;
handler.c:    ch->mod_cha		= 0;
handler.c:    ch->mod_lck		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->alignment	= URANGE( -1000, ch->alignment, 1000 );
handler.c:    ch->saving_breath	= 0;
handler.c:    ch->saving_wand	= 0;
handler.c:    ch->saving_para_petri = 0;
handler.c:    ch->saving_spell_staff = 0;
handler.c:    ch->saving_poison_death = 0;
handler.c:    ch->carry_weight	= 0;
handler.c:    ch->carry_number	= 0;
handler.c:    for ( aff = ch->first_affect; aff; aff = aff->next )
handler.c:    cur_room	   = ch->in_room;
handler.c:    ccd->room			= ch->in_room;
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:	LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:    UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:    for ( timer = ch->first_timer; timer; timer = timer->next )
handler.c:  if ( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c:  ||   IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c:  ||   victim->level >= ch->level + 15
handler.c:  || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c:  if ( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:    deity_factor = ch->pcdata->favor / -500;
handler.c:  ms = 10 - abs(ch->mental_state);
handler.c:    deity_factor = ch->pcdata->favor / -500;
handler.c:    if ( ch->mental_state < 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:    if ( ch->mental_state > 0 )
handler.c:	ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c:    if ( !IS_NPC(ch) && ch->pcdata->nuisance &&ch->pcdata->nuisance->flags > 2 )
handler.c:	c += .4*((ch->pcdata->nuisance->flags-2)*ch->pcdata->nuisance->power);
handler.c:    if ( ch->mental_state < 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:    if ( ch->mental_state > 0 )
handler.c:	ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:	ch->mental_state -= c;
handler.c:    track = URANGE( 2, ((ch->level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:	if ( ch->pcdata->killed[x].vnum == vnum )
handler.c:	    if ( ch->pcdata->killed[x].count < 50 )
handler.c:		++ch->pcdata->killed[x].count;
handler.c:	if ( ch->pcdata->killed[x].vnum == 0 )
handler.c:    memmove( (char *) ch->pcdata->killed+sizeof(KILLED_DATA),
handler.c:		ch->pcdata->killed, (track-1) * sizeof(KILLED_DATA) );
handler.c:    ch->pcdata->killed[0].vnum  = vnum;
handler.c:    ch->pcdata->killed[0].count = 1;
handler.c:	ch->pcdata->killed[track].vnum = 0;
handler.c:    track = URANGE( 2, ((ch->level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:	if ( ch->pcdata->killed[x].vnum == vnum )
handler.c:	    return ch->pcdata->killed[x].count;
handler.c:	if ( ch->pcdata->killed[x].vnum == 0 )
hiscores.c:	old_pos = get_position( keyword, ch->name);
hiscores.c:	add_hiscore( keyword, ch->name, score );
hiscores.c:	pos = get_position( keyword, ch->name );
hiscores.c:       for ( vch = first_char; vch; vch = vch->next )
hiscores.c:		ch->name, pos, table->desc );
hskelter.c:		if( !str_cmp( hpk->name, ch->name ) )
hskelter.c:		hpk->name = STRALLOC( ch->name );
ibuild.c:	ch->pagelen = lines;
ibuild.c:	switch (ch->inter_page) {
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_room_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = ROOM_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_control_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = CONTROL_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = CONTROL_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:	ch->inter_editing = NO_PAGE;
ibuild.c:	ch->inter_page = NO_PAGE;
ibuild.c:	sprintf(buf, "\E[%d;%dr", 1, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_E;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = OBJ_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	if (!ch->desc) {
ibuild.c:		bug("Send_page_to_char: NULL ch->desc", 0);
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_HELP_PAGE;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_F;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_E;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_D;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_C;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_B;
ibuild.c:		format_string(buf,ch->inter_editing,10);
ibuild.c:		ch->inter_page = MOB_PAGE_A;
ibuild.c:	write_to_buffer(ch->desc, "50\E[;H\E[2J", strlen("50\E[;H\E[2J"));
ibuild.c:	write_to_buffer(ch->desc, menu_picture, strlen(menu_picture));
ibuild.c:	switch (ch->inter_page) {
ibuild.c:	if(ch->inter_type== MOB_TYPE)
ibuild.c:	   idx = get_mob_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_mob_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:	if(ch->inter_type== ROOM_TYPE)
ibuild.c:	   ridx = get_room_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_room_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:	if(ch->inter_type== OBJ_TYPE)
ibuild.c:	   oidx = get_obj_index(ch->inter_editing_vnum);
ibuild.c:		   bug("do_redraw_page: Get_obj_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:        if(ch->inter_type== CONTROL_TYPE)
ibuild.c:        bug("do_redraw_page: Bad ch->inter_type: vnum %d.", ch->inter_editing_vnum);
ibuild.c:	switch (ch->inter_type) {
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (MOB_INDEX_DATA *) get_mob_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_mob_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (ROOM_INDEX_DATA *) get_room_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_room_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:		idx = (OBJ_INDEX_DATA *) get_obj_index(ch->inter_editing_vnum);
ibuild.c:			bug("refresh_page: Get_obj_index: bad vnum %d.", ch->inter_editing_vnum);
ibuild.c:		switch (ch->inter_page) {
ibuild.c:	if ((ch->inter_substate < 0) || (ch->inter_substate > 5)) {
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	if ((ch->inter_substate < 0) || (ch->inter_substate > 5)) {
ibuild.c:		room_page_c_data[0].data = (ch->inter_substate == SUB_NORTH) ? check : space;
ibuild.c:		room_page_c_data[1].data = (ch->inter_substate == SUB_UP) ? check : space;
ibuild.c:		room_page_c_data[2].data = (ch->inter_substate == SUB_EAST) ? check : space;
ibuild.c:		room_page_c_data[3].data = (ch->inter_substate == SUB_WEST) ? check : space;
ibuild.c:		room_page_c_data[4].data = (ch->inter_substate == SUB_SOUTH) ? check : space;
ibuild.c:		room_page_c_data[5].data = (ch->inter_substate == SUB_DOWN) ? check : space;
ibuild.c:		xit = get_exit(idx, ch->inter_substate);
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:		write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;%dr", offset, ch->pagelen);
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
ibuild.c:	sprintf(buf, "\E[%d;1H", (ch->pagelen));
ibuild.c:	write_to_buffer(ch->desc, buf, strlen(buf));
icec-mercbase.c:        victim->in_room=ch->in_room;
icec-mercbase.c:  	icec_sendmessage(c, ch->name, color_mtoi(argument), emote);
ident.c:          (ch ? ch->name : "(unknown)"), a->d->host);
ident.c:  bug(bs, (ch ? ch->name : "(unknown)"), a->d->host); \
ident.c:          user, a->d->host, (ch ? ch->name : "(unknown)"));
ident.c:          (ch ? ch->name : "(unknown)"), a->d->host);
ident.c:  bug(bs, (ch ? ch->name : "(unknown)"), d->host); \
imc-interp.c:  else if (!strcasecmp(p->type, "switch-reply")) /* hub confirmed that it added a connection to us. -- Scion */
imc-interp.c:/* call catch-all fn if present */
imc-interp.c:  strcpy(out.type, "switch-reply");
imc-mercbase.c:  d.wizi=(ch->invis_level || ch->incog_level ||
imc-mercbase.c:  d.wizi=(xIS_SET(ch->act, PLR_WIZINVIS) ||
imc-mercbase.c:  d.wizi=(IS_SET(ch->act, PLR_WIZINVIS) ||
imc-mercbase.c:  d.wizi=(IS_SET(ch->act, PLR_WIZINVIS) ||
imc-mercbase.c:  if (IS_SET(ch->pcdata->pflags, PFLAG_AFK))
imc-mercbase.c:  if (IS_SET(ch->comm, COMM_AFK))
imc-mercbase.c:  if (IS_SET(ch->comm, COMM_DEAF))
imc-mercbase.c:  if (IS_SET(ch->pcdata->pflags, PFLAG_AFK))
imc-mercbase.c:  if (IS_SET(ch->comm, COMM_AFK))
imc-mercbase.c:  if (IS_SET(ch->comm, COMM_DEAF))
imc-mercbase.c:  if (IS_SET(ch->comm, COMM_DEAF))
imc-mercbase.c:  strcpy(pinger, ch->player.name);
imc-mercbase.c:  strcpy(pinger, ch->name );
imc-mercbase.c:          !str_cmp(ch->player.name, pinger))
imc-mercbase.c:	  !str_cmp(ch->name, pinger))
imc-mercbase.c:		  wch->pcdata->extraname,
imc-mercbase.c:		  wch->pcdata->lastname,
imc-mercbase.c:          wch->pcdata->title,
imc-mercbase.c:          (wch->desc && wch->desc->connected) ? " &Y[&WWRITING&Y]&G " : "",
imc-mercbase.c:          xIS_SET(wch->act, PLR_AFK) ? " &Y[&WAWAY&Y]&G " : "",
imc-mercbase.c:          xIS_SET(wch->act, PLR_ATTACKER) ? " &R(&W^zATTACKER^x&R)&G " : "",
imc-mercbase.c:          xIS_SET(wch->act, PLR_KILLER) ? " &R(&W^zKILLER^x&R)&G " : "",
imc-mercbase.c:          xIS_SET(wch->act, PLR_THIEF)  ? " &R(&W^zTHIEF^x&R)&G "  : ""
imm_host.c:  for ( i = 0; i < strlen( ch->name ); i++ )
imm_host.c:        my_name[i] = LOWER( ch->name[i] );
interp.c:    if ( IS_NPC( ch ) && ch->position > 3 ) /*Band-aid alert?  -- Blod*/
interp.c:    if ( ch->position < position )
interp.c:	switch( ch->position )
interp.c:                        if(!found && ch->desc && get_trust(ch) < pw->imm_level 
interp.c:                        !str_prefix(pw->player_site, ch->desc->host))))
interp.c:               				ch->name, logline );
interp.c:                if (((pw->target_name && !str_cmp   (pw->target_name, ch->name))
interp.c:                && !str_prefix(pw->player_site, ch->desc->host)) )
interp.c:                &&    ch->desc )
interp.c:               			ch->name, logline );
interp.c:    if ( !ch->in_room )
interp.c:    if ( ch->substate == SUB_REPEATCMD )
interp.c:	if ( (fun=ch->last_cmd) == NULL )
interp.c:	    ch->substate = SUB_NONE;
interp.c:	/* xREMOVE_BIT( ch->affected_by, AFF_HIDE ); */
interp.c:	if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_FREEZE) )
interp.c:	    ||  (!IS_NPC(ch) && ch->pcdata->council
interp.c:	    &&    is_name( cmd->name, ch->pcdata->council->powers )
interp.c:	    ||  (!IS_NPC(ch) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:	    &&    is_name( cmd->name, ch->pcdata->bestowments )
interp.c:	if ( xIS_SET ( ch->act, PLR_AFK)  && (str_cmp(command, "AWAY")))
interp.c:	    xREMOVE_BIT( ch->act, PLR_AFK );
interp.c:    sprintf( lastplayercmd, "** %s: %s", ch->name, logline );
interp.c:    sprintf( lastplayercmd, "%s used %s", ch->name, logline );
interp.c:    if ( !IS_NPC(ch) && ch->desc
interp.c:    	else if(IS_SET(ch->pcdata->flags, PCFLAG_WATCH))
interp.c:    if ( ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_LOG) )
interp.c:        if ( ch->desc && ch->desc->original ) 
interp.c:          sprintf( log_buf, "Log %s (%s): %s", ch->name,
interp.c:                   ch->desc->original->name, logline );
interp.c:          sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:	&&  (IS_NPC(ch) || !xIS_SET(ch->act, PLR_LOG)) )
interp.c:/*	if ( ch->desc && ch->desc->original )
interp.c:		ch->desc->original->level );
interp.c:    if ( ch->desc && ch->desc->snoop_by )
interp.c:  	sprintf( logname, "%s", ch->name);
interp.c:	write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:    if( ch->inter_type == OBJ_TYPE )
interp.c:        switch (ch->inter_page)
interp.c:		       sprintf(newcommand,m_data[i].cmdString,ch->inter_editing);
interp.c:		       sprintf(newcommand,m_data[i].cmdString,ch->inter_editing, argument);
interp.c:             sprintf(newcommand,"omenu %s %c",argument,ch->inter_page);
interp.c:    if( ch->inter_type == MOB_TYPE )
interp.c:        switch (ch->inter_page)
interp.c:		       sprintf(newcommand,m_data[i].cmdString,ch->inter_editing);
interp.c:		       sprintf(newcommand,m_data[i].cmdString,ch->inter_editing, argument);
interp.c:             sprintf(newcommand,"mmenu %s %c",argument,ch->inter_page);
interp.c:    if( ch->inter_type == ROOM_TYPE )
interp.c:        switch (ch->inter_page)
interp.c:					  ch->inter_editing, 
interp.c:	tempsub = ch->substate;
interp.c:	ch->substate = SUB_TIMER_DO_ABORT;
interp.c:	if ( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:	    ch->substate = tempsub;
interp.c:	    ch->substate = tempsub;
interp.c:			if (!IS_NPC(ch) && ch->pcdata->outputprefix) {
interp.c:				send_to_char(ch->pcdata->outputprefix, ch);
interp.c:			if (!IS_NPC(ch) && ch->pcdata->outputsuffix) {
interp.c:				send_to_char(ch->pcdata->outputsuffix, ch);
interp.c:	if (!IS_NPC(ch) && ch->pcdata->outputprefix) {
interp.c:		send_to_char(ch->pcdata->outputprefix, ch);
interp.c:    if ( !IS_NPC(ch) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 9 
interp.c:         && number_percent() < ((ch->pcdata->nuisance->flags-9)*10
interp.c:         *ch->pcdata->nuisance->power))
interp.c:    ch->prev_cmd = ch->last_cmd;    /* haus, for automapping */
interp.c:    ch->last_cmd = cmd->do_fun;
interp.c:	if (!IS_NPC(ch) && ch->pcdata->outputsuffix) {
interp.c:		send_to_char(ch->pcdata->outputsuffix, ch);
interp.c:        sprintf(log_buf, "[*****] LAG: %s: %s %s (R:%d S:%d.%06d)", ch->name,
interp.c:		ch->in_room ? ch->in_room->vnum : 0,
interp.c:        sprintf(log_buf, "[*****] LAG: %s: %s %s (R:%d S:%ld.%06ld)", ch->name,
interp.c:		ch->in_room ? ch->in_room->vnum : 0,
interp.c:	if (!IS_NPC(ch) && ch->pcdata->outputprefix) {
interp.c:		send_to_char(ch->pcdata->outputprefix, ch);
interp.c:	if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_NO_EMOTE) )
interp.c:    switch ( ch->position )
interp.c:    for(victim = ch->in_room->first_person;victim;
interp.c:    				" but are unable to do so.\n\r", ch->name);
interp.c:    	char_to_room(victim, ch->in_room);
interp.c:	if (!IS_NPC(ch) && ch->pcdata->outputsuffix) {
interp.c:		send_to_char(ch->pcdata->outputsuffix, ch);
interp.c:	 for (alias=ch->pcdata->first_alias; alias; alias=alias->next) {
interp.c:	 queue=ch->pcdata->alias_queue;
interp.c:	 first=ch->pcdata->alias_queue;
interp.c:			 sprintf(buf, "Alias limit reached on character %s!", ch->name);
interp.c:			 ch->pcdata->alias_queue=NULL;
interp.c:                  WAIT_STATE( ch, sysdata.alias_wait + ch->wait );
interp.c:                  WAIT_STATE( ch, 4 + ch->wait );
interp.c:	 ch->pcdata->alias_queue=first;
interp.c:  else if ( ch->morph != NULL
interp.c:        if ( !ch->pcdata->first_alias )
interp.c:            for( alias = ch->pcdata->first_alias; alias; alias = alias->next, count++ )
interp.c:    for( alias = ch->pcdata->first_alias; alias; alias = alias->next )
interp.c:        LINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
interp.c:        UNLINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
magic.c:	case SD_FIRE:	     if (IS_SET(ch->immune, RIS_FIRE))	 return TRUE;
magic.c:	case SD_COLD:	     if (IS_SET(ch->immune, RIS_COLD))	 return TRUE;
magic.c:	case SD_ELECTRICITY: if (IS_SET(ch->immune, RIS_ELECTRICITY)) return TRUE;
magic.c:	case SD_ENERGY:	     if (IS_SET(ch->immune, RIS_ENERGY)) return TRUE;
magic.c:	case SD_ACID:	     if (IS_SET(ch->immune, RIS_ACID))	 return TRUE;
magic.c:	case SD_POISON:	     if (IS_SET(ch->immune, RIS_POISON)) return TRUE;
magic.c:	case SD_DRAIN:	     if (IS_SET(ch->immune, RIS_DRAIN))	 return TRUE;
magic.c:	if ( ch->pcdata->learned[sn] > 0
magic.c:	&&   ch->level >= skill_table[sn]->skill_level[ch->class]
magic.c:    if ( !ch->pcdata )
magic.c:	if ( !ch->pcdata->special_skills[sn]
magic.c:	||   !ch->pcdata->special_skills[sn]->name )
magic.c:	if ( LOWER(name[0]) == LOWER(ch->pcdata->special_skills[sn]->name[0])
magic.c:	&&  !str_prefix( name, ch->pcdata->special_skills[sn]->name ) )
magic.c:	&&   ch->pcdata->learned[sn] > 0
magic.c:	&&   ch->level >= skill_table[sn]->skill_level[ch->class] )
magic.c:	&&   ch->pcdata->learned[sn] > 0
magic.c:	&&   ch->level >= skill_table[sn]->skill_level[ch->class] )
magic.c:        if ( IS_NPC ( ch ) || ch->class == CLASS_MAGE )
magic.c:    for ( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c:	act( AT_MAGIC, ch->class==rch->class ? buf : buf2, ch, NULL, rch, TO_VICT );
magic.c:   if ( IS_SET(ch->immune, ris ) )
magic.c:   if ( IS_SET(ch->resistant, ris ) )
magic.c:   if ( IS_SET(ch->susceptible, ris ) )
magic.c:	    case 'H': case 'h':	return ch->hit;
magic.c:	    case 'M': case 'm':	return ch->mana;
magic.c:	    case 'V': case 'v':	return ch->move;
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:		for ( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:	    	if ( ch->gold >= value )
magic.c:		 	ch->gold -= value;
magic.c:		if ( ch->hit >= value )
magic.c:			ch->hit -= value;
magic.c:	  if ( !IS_NPC(ch) && ch->pcdata->nuisance && 
magic.c:			ch->pcdata->nuisance->flags > 5
magic.c:		&& number_percent() < (((ch->pcdata->nuisance->flags-5)*8)+
magic.c:		ch->pcdata->nuisance->power*6))
magic.c:		    if ( xIS_SET(ch->act, PLR_NICE) && ch != *victim )
magic.c:		if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == *victim )
magic.c:	  if ( !IS_NPC(ch) && ch->fighting && ch->pcdata->nuisance &&
magic.c:		ch->pcdata->nuisance->flags > 5
magic.c:		&& number_percent() < (((ch->pcdata->nuisance->flags-5)*8) +
magic.c:		6*ch->pcdata->nuisance->power))
magic.c:	  if ( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c:    switch( ch->substate )
magic.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:	    || ( !IS_NPC(ch) && ch->level < skill_table[sn]->skill_level[ch->class] ) )
magic.c:	if ( ch->position < skill->minimum_position && !IS_NPC(ch) )
magic.c:	    switch( ch->position )
magic.c:	&&  (!ch->pcdata->clan
magic.c:	|| skill->guild != ch->pcdata->clan->class) )
magic.c:	   100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion */
magic.c:	    if (ch->pcdata->condition[COND_BLOODTHIRST] < blood)
magic.c:	if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->alloc_ptr = str_dup( staticbuf );
magic.c:	ch->tempnum = sn;
magic.c:        DISPOSE( ch->alloc_ptr );
magic.c:	if ( IS_VALID_SN((sn = ch->tempnum)) )
magic.c:	       100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion */
magic.c:	    if (ch->level < LEVEL_IMMORTAL)    /* so imms dont lose mana */
magic.c:	      ch->mana -= mana / 3;
magic.c:	sn = ch->tempnum;
magic.c:	if ( !ch->alloc_ptr || !IS_VALID_SN(sn) || skill->type != SKILL_SPELL )
magic.c:	    bug( "do_cast: ch->alloc_ptr NULL or bad sn (%d)", sn );
magic.c:	   100 / ( 2 + ch->level - skill->skill_level[ch->class] ) ); -- Scion */
magic.c:	strcpy( staticbuf, ch->alloc_ptr );
magic.c:	DISPOSE( ch->alloc_ptr );
magic.c:	ch->substate = SUB_NONE;
magic.c:	    for ( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:		for ( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:		if (ch->level < LEVEL_IMMORTAL)    /* so imms dont lose mana */
magic.c:		  ch->mana -= mana / 2;
magic.c:	if (ch->level < LEVEL_IMMORTAL)    /* so imms dont lose mana */
magic.c:	  ch->mana -= mana / 2;
magic.c:    &&   (number_percent( ) + skill->difficulty * 5) > ch->pcdata->learned[sn] )
magic.c:		if ( ch->fighting )
magic.c:		if ( ch->fighting )
magic.c:		ch->mana -= mana / 2;
magic.c:	  ch->mana -= mana;
magic.c:	chance = (IS_NPC(ch) ? ch->level : (int)( ( LEARNED(ch, gsn_second_cast) + (ch->level / 10) )/1.5 ));
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_third_cast)+(ch->level / 10*1.5))/2);
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_fourth_cast)+(ch->level / 10*2))/2.5);
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_fifth_cast)+(ch->level / 10*2.5))/3);
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_sixth_cast)+(ch->level / 10*3))/3.5);
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_seventh_cast)+(ch->level / 10*3.5))/4);
magic.c:	chance = IS_NPC(ch) ? ch->level
magic.c:	   : (int) ((LEARNED(ch, gsn_eighth_cast)+(ch->level / 10*4))/4.5);
magic.c:	  ch->mana -= mana;
magic.c:			retcode = (*skill->spell_fun) ( sn, ch->level, ch, vo );
magic.c:		for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:    	   vch_next = vch->next_in_room;
magic.c:    int levdiff = ch->level - level;
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && 
magic.c:	&&   IS_SET(ch->immune, RIS_MAGIC ) )
magic.c:	for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:    if ( ch->in_room->area->weather->precip <= 0 )
magic.c:	vch_next	= vch->next;
magic.c:	if ( !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:            if ( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS )
magic.c:	    &&    vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	&&   vch->in_room->area == ch->in_room->area
magic.c:    sprintf( buf, "%s has charmed %s.", ch->name, victim->name);
magic.c:    log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:    weath = ch->in_room->area->weather;
magic.c:    	(ch->level*3)/(2*max_vector);
magic.c:    mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:    weath = ch->in_room->area->weather;
magic.c:    if ( ch->alignment < 350 ) {
magic.c:    if ( IS_SET( ch->immune, RIS_MAGIC ) ) {
magic.c:  if ( IS_NPC(ch) || ch->class == CLASS_MAGE )
magic.c:      if ( ch->first_affect )
magic.c:          while ( ch->first_affect )
magic.c:            affect_remove ( ch, ch->first_affect );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:	vch_next	= vch->next;
magic.c:	if ( !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:            if ( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS )
magic.c:                 && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	if ( !ch_died && vch->in_room->area == ch->in_room->area )
magic.c:    ch->alignment = UMAX(-1000, ch->alignment - 200);
magic.c:	dam		 = ch->hit + 1;
magic.c:	ch->hit		+= dam;
magic.c:    if ( ch->hit > ch->max_hit )
magic.c:	ch->hit = ch->max_hit;
magic.c:    for ( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:	if ( !IS_NPC(ich) && xIS_SET(ich->act, PLR_WIZINVIS) )
magic.c:	xREMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	xREMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic.c:	xREMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:	ch->in_room );
magic.c:	((ch->level > victim->level + 10) 
magic.c:	(ch->level > victim->level + 10) 
magic.c:    if ( (chance(ch, 50) && ch->level >= victim->level + 10 )
magic.c:    if ( !ch->in_room->first_content )
magic.c:    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:	sprintf( log_buf, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:	log_string_plus( log_buf, LOG_NORMAL, ch->level );
magic.c:	to_channel( log_buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:    ||   IS_SET(ch->in_room->room_flags,     ROOM_NO_ASTRAL)
magic.c:    ||   !in_hard_range( victim, ch->in_room->area )
magic.c:    ||  (IS_SET(ch->in_room->area->flags, AFLAG_NOPKILL) && IS_PKILL(victim))
magic.c:    if ( ch->in_room->area != victim->in_room->area )
magic.c:	sprintf( buf, "%s summoned %s to room %d.", ch->name,
magic.c:					     ch->in_room->vnum );
magic.c:	log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:    char_to_room( victim, ch->in_room );
magic.c:	sprintf( buf, "%s teleported %s to room %d.", ch->name,
magic.c:	log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:	pRoomIndex = get_room_index(ch->pcdata->memorize[i]);
magic.c:	sprintf( buf, "%s teleported %s to room %d.", ch->name,
magic.c:	log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:	to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:	if ( !is_name( speaker, vch->name ) ) {
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:        if ( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) 
magic.c:             && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:	    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_ASTRAL)
magic.c:    if (victim->in_room == ch->in_room)
magic.c:    fromRoom = ch->in_room;
magic.c:    sprintf( buf, "a portal created by %s", ch->name );
magic.c:    portalObj = obj_to_room( portalObj, ch->in_room );
magic.c:             ch->name, fromRoom->vnum, targetRoomVnum );
magic.c:    log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level)  );
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    original = ch->in_room;
magic.c:	if ( chance(ch, 50 - (ch->level/2) ) )
magic.c:    ||  (ch->in_room->sector_type     != SECT_FOREST
magic.c:    &&   ch->in_room->sector_type     != SECT_FIELD)
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    if ( ch->in_room->sector_type == SECT_FOREST )
magic.c:    if ( ch->in_room->sector_type == SECT_FOREST )
magic.c:    &&   ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    WEATHER_DATA *weath = ch->in_room->area->weather;
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:		if ( chance(ch, 50) && ch->level + 10 < victim->level )
magic.c:		if ( chance(ch, 50) && ch->level + 15 < victim->level )
magic.c:    for (corpse = ch->in_room->first_content; corpse; corpse = corpse_next)
magic.c:        if ( !IS_IMMORTAL(ch) && ch->pcdata->condition[COND_BLOODTHIRST] -
magic.c:      else if ( ch->mana - (pMobIndex->level*4) < 0 )
magic.c:        ch->mana -= (pMobIndex->level*4);
magic.c:    if ( IS_IMMORTAL(ch) || ( chance(ch, 75) && pMobIndex->level - ch->level < 10 ) )
magic.c:	char_to_room( mob, ch->in_room );
magic.c:	mob->level 	 = UMIN(ch->level / 2, pMobIndex->level);
magic.c:				   ch->level * dice(20,10)), 1 );
magic.c:	mob->damroll   = ch->level / 8;
magic.c:	mob->hitroll   = ch->level / 6;
magic.c:	mob->alignment = ch->alignment;
magic.c:    if (ch->desc->original)
magic.c:    af.duration  = 20 + (ch->level - victim->level) / 2;
magic.c:    ch->desc->character = victim;
magic.c:    ch->desc->original  = ch;
magic.c:    victim->desc        = ch->desc;
magic.c:    ch->desc            = NULL;
magic.c:    ch->switched        = victim;
magic.c:  if ( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:      victim->in_room->area != ch->in_room->area )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )   
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:	if ( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS )       
magic.c:        && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:            hpch = UMAX( 10, ch->hit );
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:		if ( (dam > 0 && ch->fighting && ch->fighting->who == victim)
magic.c:		    int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	if ( !IS_NPC(vch) && xIS_SET(vch->act, PLR_WIZINVIS)
magic.c:	&&    vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:			    vch->hit = URANGE( 0, vch->hit + dam, vch->max_hit );
magic.c:			    if ( (dam > 0 && ch->fighting && ch->fighting->who == vch)
magic.c:			    ||   (dam > 0 && vch->fighting && vch->fighting->who == ch) )
magic.c:				int xp = ch->fighting ? ch->fighting->xp : vch->fighting->xp;
magic.c:				int xp_gain = (int) (xp * dam * 2) / vch->max_hit;
magic.c:		    if ( (af.modifier > 0 && ch->fighting && ch->fighting->who == victim)
magic.c:			int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:	  victim = ch->in_room->first_person;
magic.c:	    WEATHER_DATA *weath = ch->in_room->area->weather;
magic.c:		if ( ch->level - obj->level < 10
magic.c:		||   obj->cost > ch->level * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:		if ( ch->level - obj->level < 20
magic.c:		||   obj->cost > ch->level * get_curr_int(ch) / 5 )
magic.c:		if ( ch->level - obj->level < 5
magic.c:		||   obj->cost > ch->level * 10 * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:		if ( ch->level - obj->level < 0
magic.c:		||   obj->cost > ch->level * 50 * get_curr_int(ch) * get_curr_wis(ch) )
magic.c:      obj_to_room( obj, ch->in_room );
magic.c:    char_to_room( mob, ch->in_room );
magic.c:               ( ch->position == POS_FIGHTING
magic.c:               || ch->position ==  POS_EVASIVE
magic.c:               || ch->position ==  POS_DEFENSIVE
magic.c:               || ch->position ==  POS_AGGRESSIVE
magic.c:               || ch->position ==  POS_BERSERK ) )
magic.c:        ch->gold += val;
magic.c:        ch->gold += val;
magic.c:    ch->gold += val;
makeobjs.c:    if ( ch && ch->in_room )
makeobjs.c:	name		= ch->short_descr;
makeobjs.c:	if ( ch->gold > 0 )
makeobjs.c:	    if ( ch->in_room )
makeobjs.c:	      ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:	      sysdata.global_looted += ch->gold/100;
makeobjs.c:	    obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:	    ch->gold = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:	corpse->cost     = (-(int)ch->pIndexData->vnum);
makeobjs.c:	name		= ch->name;
makeobjs.c:	corpse->value[4] = ch->level;
makeobjs.c:    for ( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:    obj_to_room( corpse, ch->in_room );
makeobjs.c:	obj->value[1]   = number_range( 3, UMIN(5, ch->level) );
makeobjs.c:	obj_to_room( obj, ch->in_room );
makeobjs.c:	obj_to_room( obj, ch->in_room );
mapout.c:	       if(map_index->map_of_vnums[y][x]==ch->in_room->vnum)
mapout.c:		  if ( xIS_SET(ch->act, PLR_ANSI) ){
mapout.c:	bug ("map_stats: ch->pnote==NULL!", 0);
mapout.c:		bug ("do_mapout: sub_writing_map: ch->dest_buf != ch->pnote", 0);
mapout.c:       if ( ch->prev_cmd == do_north )
mapout.c:	   tmp_x = get_exit(ch->in_room, DIR_SOUTH );
mapout.c:       if ( ch->prev_cmd == do_east )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_WEST );
mapout.c:       if ( ch->prev_cmd == do_south )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_NORTH );
mapout.c:       if ( ch->prev_cmd == do_west )
mapout.c:	   tmp_x = get_exit( ch->in_room, DIR_EAST );
mapout.c:        this_rm = ch->in_room;
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->map->vnum);
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:	ch->in_room->map = map;
mapout.c:        map_index->map_of_vnums[y][x] = ch->in_room->vnum;
mapout.c:        this_rm = ch->in_room;
mapout.c:						  ch->in_room->vnum);
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c:						  ch->in_room->vnum,
mapout.c: * This function takes the character string in ch->pnote and
mapout.c:	bug ("map_to_rooms: ch->pnote==NULL!", 0);
mapout.c:	for (i=ch->pcdata->r_range_lo;i<=ch->pcdata->r_range_hi;i++) {
medit.c:    if ( !IS_NPC( victim ) && str_cmp( ch->name, "Tagith" ) )
medit.c:    d = ch->desc;
medit.c:        if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
medit.c:    CHAR_DATA *victim = ch->dest_buf;
medit.c:    switch ( ch->substate )
medit.c:	    if ( !ch->dest_buf )
medit.c:		bug( "do_medit_reset: sub_mob_desc: NULL ch->dest_buf", 0 );
medit.c:		cleanup_olc( ch->desc );
medit.c:		ch->substate = SUB_NONE;
medit.c:	    ch->dest_buf = victim;
medit.c:	    ch->substate = SUB_NONE;
medit.c:	    ch->desc->connected = CON_MEDIT;
medit.c:	    medit_disp_menu( ch->desc );
misc.c:	for ( source = ch->in_room->first_content;
misc.c:		||    ch->carry_weight + get_obj_weight(source) > can_carry_w(ch)
misc.c:		   ch->gold += source->value[0];
misc.c:		||    ch->carry_weight + get_obj_weight(source) > can_carry_w(ch)
misc.c:/*		||   !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )*/ ) 
misc.c:		    if ( str_cmp( name, ch->name ) && !IS_IMMORTAL(ch) )
misc.c:			for ( gch = first_char; gch; gch = gch->next )
misc.c:			    &&   !str_cmp( name, gch->name ) )
misc.c:		    ||    ch->carry_number + otmp->count > can_carry_n(ch)
misc.c:		    ||    ch->carry_weight + get_obj_weight(otmp) > can_carry_w(ch)
misc.c:	for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
misc.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 40 )
misc.c:	     &&   ch->level > 5
misc.c:	    &&   ch->pcdata->condition[COND_BLOODTHIRST] > (5+ch->level/10) )
misc.c:	    if ( ch->pcdata->condition[COND_BLOODTHIRST] < (10 + ch->level) )
misc.c:		if ( ch->pcdata->condition[COND_FULL] >= 48
misc.c:		||   ch->pcdata->condition[COND_THIRST] >= 48 )
misc.c:		   if (obj->value[1] <= (ch->max_mana - ch->mana)) {
misc.c:		if (obj->value[1] > (ch->max_mana - ch->mana)) {
misc.c:			gain_condition(ch, COND_BLOODTHIRST, (ch->max_mana - ch->mana));
misc.c:			obj->value[1] -= (ch->max_mana - ch->mana);
misc.c:	    ch->pcdata->condition[COND_THIRST] = 40;
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 24 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 18 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 12 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 8 )
misc.c:	    if ( ch->pcdata->condition[COND_DRUNK]  > 5 )
misc.c:	    if ( ch->pcdata->condition[COND_FULL]   > 40 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 40 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 36 )
misc.c:	    if ( ch->pcdata->condition[COND_THIRST] > 30 )
misc.c:	    ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:    if ( IS_NPC(ch) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:    if ( !IS_NPC(ch) && (!IS_PKILL(ch) || (IS_PKILL(ch) && !IS_SET(ch->pcdata->flags, PCFLAG_HIGHGAG) ) ) )
misc.c:    if ( ch->fighting && number_percent( ) > (get_curr_dex(ch) * 2 + 47) )
misc.c:	( ch->in_room->sector_type == SECT_UNDERWATER ||
misc.c:	  ch->in_room->sector_type == SECT_WATER_SWIM ||
misc.c:	  ch->in_room->sector_type == SECT_WATER_NOSWIM )   ? "dissolves in the water" :
misc.c:	( ch->in_room->sector_type == SECT_AIR        ||
misc.c:	  IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR ) ) ? "falls far below" :
misc.c:	    condition = ch->pcdata->condition[COND_FULL];
misc.c:	    if ( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:	    else if ( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:		ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:		ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:	    condition = ch->pcdata->condition[COND_FULL];
misc.c:	    if ( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:	    else if ( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:    && ( ch->pcdata->condition[COND_FULL] >= 48
misc.c:    ||   ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:    if ( !IS_NPC(ch) && ch->pcdata->nuisance &&
misc.c:		ch->pcdata->nuisance->flags > 3
misc.c:     &&(ch->pcdata->condition[COND_FULL]>=(48-(3*ch->pcdata->nuisance->flags)+
misc.c:	ch->pcdata->nuisance->power)
misc.c:     ||ch->pcdata->condition[COND_THIRST]>=(48-(ch->pcdata->nuisance->flags)+
misc.c:	ch->pcdata->nuisance->power)))
misc.c:    if ( !IS_NPC(ch) && (!IS_PKILL(ch) || (IS_PKILL(ch) && !IS_SET(ch->pcdata->flags, PCFLAG_HIGHGAG) ) ) )
misc.c:    if ( ch->fighting && number_percent( ) > (get_curr_dex(ch) * 2 + 48) )
misc.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 43 )
misc.c:      &&(ch->level + 10 < scroll->value[0]))
misc.c:	for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:	    for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:		for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:	    for ( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:	    &&   pexit_rev->to_room == ch->in_room )
misc.c:		for ( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:        if ( ch->fighting )
misc.c:          &&    pexit_rev->to_room        == ch->in_room )
misc.c:            for ( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:		obj_cast_spell( sn, UMIN(skill->min_level, ch->level),
misc.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_NODROP )
misc.c:		||  xIS_SET( ch->act, PLR_LITTERBUG ) )
misc.c:		if ( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) 
misc.c:		||   IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
misc.c:		if ( empty_obj( obj, NULL, ch->in_room ) )
misc.c:    if ( ch->fighting )
misc.c:    iroom = IS_NPC( ch ) ? ch->short_descr : ch->name;
mobchat.c:  if (!HAS_PROG(ch->pIndexData, SPEECH_PROG)) {
motd.c:    if ( ch->level >= 103 )
motd.c:    else if ( ch->level >= 101 )
motd.c:    else if ( ch->level >= 50 )
motd.c:    else if ( ch->level >= 2 )
motd.c:    else if ( ch->level == 1 )
mpxset.c:    if ( !IS_NPC( ch ) || IS_AFFECTED(ch, AFF_CHARM) || ch->desc )
mpxset.c:	  ch->name, victim->name, value );
mpxset.c:    if ( !IS_NPC( ch ) || IS_AFFECTED(ch, AFF_CHARM) || ch->desc )
mud_comm.c:    if ( xIS_EMPTY(ch->in_room->progtypes) )
mud_comm.c:	ch->in_room->name, ch->in_room->vnum );
mud_comm.c:    for ( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:    if ( ch->position == POS_FIGHTING
mud_comm.c:       || ch->position ==  POS_EVASIVE
mud_comm.c:       || ch->position ==  POS_DEFENSIVE
mud_comm.c:       || ch->position ==  POS_AGGRESSIVE
mud_comm.c:       || ch->position ==  POS_BERSERK
mud_comm.c:    for ( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    was_in_room = ch->in_room;
mud_comm.c:           ch->in_room = pexit->to_room;
mud_comm.c:    ch->act = actflags;
mud_comm.c:    ch->in_room = was_in_room;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:    ch->act = actflags;
mud_comm.c:    char_to_room( victim, ch->in_room );
mud_comm.c:	obj_to_room( obj, ch->in_room );
mud_comm.c:		sprintf(arg1, "Mpqpadd:  %d glory added to %s from mob #%d", amount, victim->name, ch->pIndexData->vnum);
mud_comm.c:	for ( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:	while ( ch->in_room->first_content )
mud_comm.c:	   extract_obj( ch->in_room->first_content );
mud_comm.c:	ch->mobinvis = level;
mud_comm.c:    if ( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->level;
mud_comm.c:    if ( xIS_SET(ch->act, ACT_MOBINVIS) )
mud_comm.c:        xREMOVE_BIT(ch->act, ACT_MOBINVIS);
mud_comm.c:        xSET_BIT(ch->act, ACT_MOBINVIS);
mud_comm.c:    in_room = ch->in_room;
mud_comm.c:    if ( ch->fighting )
mud_comm.c:        fch_next = fch->next_in_room;
mud_comm.c:	if ( fch->mount && fch->mount == ch )
mud_comm.c:    original = ch->in_room;
mud_comm.c:	if ( victim->level > ch->level )
mud_comm.c:	for ( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:		     || ch->in_room->area != d->character->in_room->area ||
mud_comm.c:	location = ch->in_room;
mud_comm.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c:	    sprintf(arg, "Mpforce - Mob #%d in room %d attempting to force link dead immortal",ch->pIndexData->vnum, ch->in_room->vnum);
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:   if ( !ch->pcdata->nuisance )
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:  if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    actflags = ch->act;
mud_comm.c:    xREMOVE_BIT(ch->act, ACT_SECRETIVE);
mud_comm.c:        vch_next = vch->next;
mud_comm.c:        if ( vch->in_room->area == ch->in_room->area
mud_comm.c:    ch->act = actflags;
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    /* adept = class_table[ch->class]->skill_adept; */
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:        for ( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:	ch->short_descr,
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( gold <= ch->gold && ch->in_room )
mud_comm.c:	ch->gold -= gold;
mud_comm.c:	boost_economy( ch->in_room->area, gold );
mud_comm.c:    if ( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room
mud_comm.c:    &&   economy_has( ch->in_room->area, gold ) )
mud_comm.c:	ch->gold += gold;
mud_comm.c:	lower_economy( ch->in_room->area, gold );
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:      for ( rch=ch->in_room->first_person; rch; rch=rch->next_in_room ) {
mud_comm.c:        if ( rch->fighting ) {
mud_comm.c:    if ( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ))
mud_comm.c:		(IS_NPC(ch) ? ch->short_descr : ch->name) );
mud_comm.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
mud_prog.c:      for ( ch = first_char; ch; ch = ch->next )
mud_prog.c:	&&    ch->desc
mud_prog.c:	&&    ch->desc->host == chkchar->desc->host )
mud_prog.c:     for ( ch = mob->in_room->first_person; ch; ch = ch->next_in_room )
mud_prog.c:       &&   nifty_is_name(ch->name, cvar) )
mud_prog.c:     for ( ch = first_char; ch; ch = ch->next )
mud_prog.c:         &&   ch->in_room->area == mob->in_room->area
mud_prog.c:         &&   nifty_is_name(ch->name, cvar) )
mud_prog.c:     for ( tch = room?room->first_person:NULL; tch; tch = tch->next_in_room )
mud_prog.c:     for ( tch = room?room->first_person:NULL; tch; tch = tch->next_in_room )
mud_prog.c:     for ( tch = room?room->first_person:NULL; tch; tch = tch->next_in_room )
mud_prog.c:  for ( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:	if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:	if ( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c: sprintf( buf, "mprog_greet_trigger -> %s", ch->name );
mud_prog.c: for ( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:  if ( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:    for ( vobj=ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:    for ( vobj=ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:    if ( HAS_PROG(ch->in_room, LEAVE_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:    if ( HAS_PROG(ch->in_room, ENTER_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:    if ( HAS_PROG(ch->in_room, SLEEP_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG(ch->in_room, REST_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG(ch->in_room, RFIGHT_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG(ch->in_room, RDEATH_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG(ch->in_room, SPEECH_PROG) )
mud_prog.c:	rprog_wordlist_check( txt, supermob, ch, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:   if ( HAS_PROG(ch->in_room, RAND_PROG) )
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:   if ( HAS_PROG(ch->in_room, TIME_PROG))
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:	rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:   if ( HAS_PROG(ch->in_room, HOUR_PROG))
mud_prog.c:	rset_supermob( ch->in_room );
mud_prog.c:	rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:      if ( mpact->ch->in_room == room )
oedit.c:    d = ch->desc;
oedit.c:        if ( !ch->pcdata || !(pArea=ch->pcdata->area) )
oedit.c:    OBJ_DATA *obj = ch->dest_buf;
oedit.c:    EXTRA_DESCR_DATA *ed = ch->spare_ptr;
oedit.c:    MPROG_DATA *mprg = ch->spare_ptr;
oedit.c:    int mode = OLC_MODE(ch->desc);
oedit.c:    switch ( ch->substate )
oedit.c:        if ( !ch->dest_buf )
oedit.c:            bug( "do_oedit_reset: sub_obj_extra: NULL ch->dest_buf", 0 );
oedit.c:            ch->substate = SUB_NONE;
oedit.c:        /* OLC_DESC(ch->desc) = ch->spare_ptr; */
oedit.c:        ch->dest_buf = obj;
oedit.c:	ch->spare_ptr = ed;
oedit.c:        ch->substate = SUB_NONE;
oedit.c:        ch->desc->connected = CON_OEDIT;
oedit.c:        OLC_MODE(ch->desc) = OEDIT_EXTRADESC_CHOICE;
oedit.c:        oedit_disp_extra_choice( ch->desc );
oedit.c:        if ( !ch->dest_buf )
oedit.c:            bug( "do_oedit_reset: sub_obj_long: NULL ch->dest_buf", 0 );
oedit.c:            ch->substate = SUB_NONE;
oedit.c:        ch->dest_buf = obj;
oedit.c:        ch->desc->connected = CON_OEDIT;
oedit.c:        ch->substate = SUB_NONE;
oedit.c:        OLC_MODE( ch->desc ) = OEDIT_MAIN_MENU;
oedit.c:        oedit_disp_menu( ch->desc );
oedit.c:	ch->dest_buf = obj;
oedit.c:	ch->desc->connected = ch->tempnum;
oedit.c:	ch->substate = SUB_NONE;
oedit.c:	OLC_MODE( ch->desc ) = mode;
oedit.c:	oedit_disp_prog_choice( ch->desc );
player.c:		if (ch->pcdata->outputprefix)
player.c:			DISPOSE(ch->pcdata->outputprefix);
player.c:		ch->pcdata->outputprefix = str_dup(argument);
player.c:		if (ch->pcdata->outputsuffix)
player.c:			DISPOSE(ch->pcdata->outputsuffix);
player.c:		ch->pcdata->outputsuffix = str_dup(argument);
player.c:	if (ch->level > 1 /*|| !NOT_AUTHED(ch)*/) {
player.c:	ch->perm_str                = 13;
player.c:    ch->perm_dex                = 13;
player.c:    ch->perm_int                = 13;
player.c:    ch->perm_wis                = 13;
player.c:    ch->perm_cha                = 13;
player.c:    ch->perm_con                = 13;
player.c:    ch->perm_lck                = 13;
player.c:    switch ( class_table[ch->class]->attr_prime )
player.c:		case APPLY_STR: ch->perm_str = 16; break;
player.c:		case APPLY_INT: ch->perm_int = 16; break;
player.c:		case APPLY_WIS: ch->perm_wis = 16; break;
player.c:		case APPLY_DEX: ch->perm_dex = 16; break;
player.c:		case APPLY_CON: ch->perm_con = 16; break;
player.c:		case APPLY_CHA: ch->perm_cha = 16; break;
player.c:		case APPLY_LCK: ch->perm_lck = 16; break;
player.c:    ch->perm_str         += race_table[ch->race]->str_plus;
player.c:    ch->perm_int         += race_table[ch->race]->int_plus;
player.c:    ch->perm_wis         += race_table[ch->race]->wis_plus;
player.c:    ch->perm_dex         += race_table[ch->race]->dex_plus;
player.c:    ch->perm_con         += race_table[ch->race]->con_plus;
player.c:    ch->perm_cha         += race_table[ch->race]->cha_plus;
player.c:    ch->perm_lck         += race_table[ch->race]->lck_plus;
player.c:		ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck);
player.c:   ch_printf( ch,  "You have %d gold pieces.\n\r", ch->gold );
player.c:    pager_printf(ch, "\n\rWorth for %s%s.\n\r", ch->name, ch->pcdata->title);
player.c:    if (!ch->pcdata->deity)		 sprintf( buf, "N/A" );
player.c:    else if (ch->pcdata->favor > 2250)	 sprintf( buf, "loved" );
player.c:    else if (ch->pcdata->favor > 2000)	 sprintf( buf, "cherished" );
player.c:    else if (ch->pcdata->favor > 1750) 	 sprintf( buf, "honored" );
player.c:    else if (ch->pcdata->favor > 1500)	 sprintf( buf, "praised" );
player.c:    else if (ch->pcdata->favor > 1250)	 sprintf( buf, "favored" );
player.c:    else if (ch->pcdata->favor > 1000)	 sprintf( buf, "respected" );
player.c:    else if (ch->pcdata->favor > 750)	 sprintf( buf, "liked" );
player.c:    else if (ch->pcdata->favor > 250)	 sprintf( buf, "tolerated" );
player.c:    else if (ch->pcdata->favor > -250)	 sprintf( buf, "ignored" );
player.c:    else if (ch->pcdata->favor > -750)	 sprintf( buf, "shunned" );
player.c:    else if (ch->pcdata->favor > -1000)	 sprintf( buf, "disliked" );
player.c:    else if (ch->pcdata->favor > -1250)	 sprintf( buf, "dishonored" );
player.c:    else if (ch->pcdata->favor > -1500)	 sprintf( buf, "disowned" );
player.c:    else if (ch->pcdata->favor > -1750)	 sprintf( buf, "abandoned" );
player.c:    else if (ch->pcdata->favor > -2000)	 sprintf( buf, "despised" );
player.c:    else if (ch->pcdata->favor > -2250)	 sprintf( buf, "hated" );
player.c:    if ( ch->level < 10 )
player.c:       if (ch->alignment > 900)		 sprintf(buf2, "devout");
player.c:       else if (ch->alignment > 700)	 sprintf(buf2, "noble");
player.c:       else if (ch->alignment > 350)	 sprintf(buf2, "honorable");
player.c:       else if (ch->alignment > 100)	 sprintf(buf2, "worthy");
player.c:       else if (ch->alignment > -100)	 sprintf(buf2, "neutral");
player.c:       else if (ch->alignment > -350)	 sprintf(buf2, "base");
player.c:       else if (ch->alignment > -700)	 sprintf(buf2, "evil");
player.c:       else if (ch->alignment > -900)	 sprintf(buf2, "ignoble");
player.c:	sprintf(buf2, "%d", ch->alignment );
player.c:                     ch->level, buf, buf2, ch->exp );
player.c:        switch (ch->style) {
player.c:                 ch->pcdata->quest_curr, ch->carry_weight, buf, ch->gold );
player.c:    if ( ch->level < 15 && !IS_PKILL(ch) )
player.c:    pager_printf(ch, "\n\r&CScore for: &W%s %s%s%s&C.\n\r", ch->pcdata->extraname, ch->name, ch->pcdata->lastname, ch->pcdata->title);
player.c:    if ( get_trust( ch ) != ch->level )
player.c:	ch->level, capitalize(get_race(ch)), (get_age(ch) - 17) * 2);
player.c:		get_age(ch), capitalize(get_class(ch)), ctime(&(ch->logon)) );
player.c:    if (ch->level >= 15
player.c:		get_curr_str(ch), ch->perm_str, GET_HITROLL(ch), ch->save_time ? ctime(&(ch->save_time)) : "no save this session\n" );
player.c:		get_curr_int(ch), ch->perm_int, GET_DAMROLL(ch), ctime(&current_time) );
player.c:		get_curr_str(ch), ch->perm_str, ch->save_time ? ctime(&(ch->save_time)) : "no\n" );
player.c:		get_curr_int(ch), ch->perm_int, ctime(&current_time) );
player.c:    if (ch->level > 24)
player.c:		get_curr_wis(ch), ch->perm_wis, buf, GET_AC(ch));
player.c:		get_curr_wis(ch), ch->perm_wis, buf);
player.c:    if (ch->alignment > 900)
player.c:    else if (ch->alignment > 700)
player.c:    else if (ch->alignment > 350)
player.c:    else if (ch->alignment > 100)
player.c:    else if (ch->alignment > -100)
player.c:    else if (ch->alignment > -350)
player.c:    else if (ch->alignment > -700)
player.c:    else if (ch->alignment > -900)
player.c:    if (ch->level < 10)
player.c:		get_curr_dex(ch), ch->perm_dex, buf, ch->carry_number, can_carry_n(ch));
player.c:		get_curr_dex(ch), ch->perm_dex, buf, ch->alignment,ch->carry_number, can_carry_n(ch));
player.c:    switch (ch->position)
player.c:	get_curr_con(ch), ch->perm_con, buf, ch->carry_weight, can_carry_w(ch));
player.c:	get_curr_cha(ch), ch->perm_cha, ch->wimpy);
player.c:        switch (ch->style) {
player.c:	get_curr_lck(ch), ch->perm_lck);
player.c:	ch->pcdata->quest_curr, ch->pcdata->quest_accum,
player.c:	(IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) ? '*' : ' '),ch->pcdata->pagerlen);
player.c:	ch->practice, ch->hit, ch->max_hit,
player.c:	 xIS_SET(ch->act, PLR_AUTOEXIT) ? '*' : ' ');
player.c:		ch->exp, ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level,
player.c:		xIS_SET(ch->act, PLR_AUTOLOOT) ? '*' : ' ');
player.c:		ch->exp, ch->mana, ch->max_mana, xIS_SET(ch->act, PLR_AUTOLOOT) ? '*' : ' ');
player.c:	ch->gold, ch->move, ch->max_move, xIS_SET(ch->act, PLR_AUTOSAC) ? '*' : ' ');
player.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] == 0)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] == 0)
player.c:    if ( ch->position != POS_SLEEPING )
player.c:	switch( ch->mental_state / 10 )
player.c:    if ( ch->mental_state >45 )
player.c:    if ( ch->mental_state >25 )
player.c:    if ( ch->mental_state <-35 )
player.c:    if ( ch->mental_state <-25 )
player.c:	||  (IS_NPC(ch) && ch->speaks == 0) )
player.c:	    if ( lang_array[iLang] & ch->speaking
player.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
player.c:    if ( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:		ch->pcdata->bestowments );
player.c:    if ( ch->morph && ch->morph->morph )
player.c:                ch->morph->morph->vnum, ch->morph->morph->short_desc, 
player.c:		ch->morph->timer
player.c:                ch->morph->morph->short_desc );
player.c:	pager_printf(ch, "NonPC DATA:  Mkills (&W%5.5d&C)     Mdeaths (&W%5.5d&C)\n\r", ch->pcdata->mkills, ch->pcdata->mdeaths );
player.c:		ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
player.c:    if (ch->arena_wins || ch->arena_deaths || ch->arena_kills) {
player.c:		ch->arena_wins, ch->arena_kills, ch->arena_deaths);
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER  && ch->pcdata->clan->clan_type != CLAN_GUILD )
player.c:		ch->pcdata->clan->name, ch->pcdata->clan->pkills[5],
player.c:		(ch->pcdata->clan->pkills[0]+ch->pcdata->clan->pkills[1]+
player.c:		 ch->pcdata->clan->pkills[2]+ch->pcdata->clan->pkills[3]+
player.c:		 ch->pcdata->clan->pkills[4]) );
player.c:		ch->pcdata->clan->pdeaths[5],
player.c:		( ch->pcdata->clan->pdeaths[0] + ch->pcdata->clan->pdeaths[1] +
player.c:		  ch->pcdata->clan->pdeaths[2] + ch->pcdata->clan->pdeaths[3] +
player.c:		  ch->pcdata->clan->pdeaths[4] ) );
player.c:    if (ch->pcdata->deity)
player.c:	if (ch->pcdata->favor > 2250)
player.c:	else if (ch->pcdata->favor > 2000)
player.c:	else if (ch->pcdata->favor > 1750)
player.c:	else if (ch->pcdata->favor > 1500)
player.c:	else if (ch->pcdata->favor > 1250)
player.c:	else if (ch->pcdata->favor > 1000)
player.c:	else if (ch->pcdata->favor > 750)
player.c:	else if (ch->pcdata->favor > 250)
player.c:	else if (ch->pcdata->favor > -250)
player.c:	else if (ch->pcdata->favor > -750)
player.c:	else if (ch->pcdata->favor > -1000)
player.c:	else if (ch->pcdata->favor > -1250)
player.c:	else if (ch->pcdata->favor > -1500)
player.c:	else if (ch->pcdata->favor > -1750)
player.c:	else if (ch->pcdata->favor > -2000)
player.c:	else if (ch->pcdata->favor > -2250)
player.c:	pager_printf(ch, "&CDeity:  &Y%-20s  &CFavor: &G%s&C\n\r", ch->pcdata->deity->name, buf );
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_ORDER )
player.c:		ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths);
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_GUILD )
player.c:                ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths);
player.c:		xIS_SET(ch->act, PLR_WIZINVIS) ? "*" : " ", ch->pcdata->wizinvis );
player.c:	pager_printf(ch, "&CBamfin:  &Y%s%s\n\r", ((ch->pcdata->bamfin[0] != '\0') ? "" : ch->name),
player.c:		(ch->pcdata->bamfin[0] != '\0') ? ch->pcdata->bamfin : "appears in a swirling mist.");
player.c:	pager_printf(ch, "&CBamfout: &Y%s%s\n\r", ((ch->pcdata->bamfout[0] != '\0') ? "" : ch->name),
player.c:		(ch->pcdata->bamfout[0] != '\0') ? ch->pcdata->bamfout : "leaves in a swirling mist.");
player.c:	if (ch->pcdata->area)
player.c:		ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
player.c:		ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
player.c:		ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum);
player.c:	    pager_printf(ch, "&CArea Loaded [&W%s&C]\n\r", (IS_SET (ch->pcdata->area->status, AREA_LOADED)) ? "yes" : "no");
player.c:    if (ch->first_affect)
player.c:	for (paf = ch->first_affect; paf; paf = paf->next)
player.c:	    if (ch->level < 20)
player.c:	     if (ch->level >= 20)
player.c:    pager_printf_color(ch, "\n\r&C%s%s.\n\r", ch->name, ch->pcdata->title);
player.c:    if ( get_trust( ch ) != ch->level )
player.c:	ch->level, capitalize(get_race(ch)), (get_age(ch) - 17) * 2);
player.c:		get_age(ch), capitalize(get_class(ch)), ctime(&(ch->logon)) );
player.c:    if (ch->level >= 15
player.c:		get_curr_str(ch), ch->perm_str, GET_HITROLL(ch), ch->save_time ? ctime(&(ch->save_time)) : "no save this session\n" );
player.c:		get_curr_int(ch), ch->perm_int, GET_DAMROLL(ch), ctime(&current_time) );
player.c:		get_curr_str(ch), ch->perm_str, ch->save_time ? ctime(&(ch->save_time)) : "no\n" );
player.c:		get_curr_int(ch), ch->perm_int, ctime(&current_time) );
player.c:    if (ch->level > 24)
player.c:		get_curr_wis(ch), ch->perm_wis, GET_AC(ch), buf);
player.c:		get_curr_wis(ch), ch->perm_wis, buf);
player.c:    if (ch->alignment > 900)
player.c:    else if (ch->alignment > 700)
player.c:    else if (ch->alignment > 350)
player.c:    else if (ch->alignment > 100)
player.c:    else if (ch->alignment > -100)
player.c:    else if (ch->alignment > -350)
player.c:    else if (ch->alignment > -700)
player.c:    else if (ch->alignment > -900)
player.c:    if (ch->level < 10)
player.c:		get_curr_dex(ch), ch->perm_dex, buf, ch->carry_number, can_carry_n(ch));
player.c:		get_curr_dex(ch), ch->perm_dex, ch->alignment, buf, ch->carry_number, can_carry_n(ch));
player.c:    switch (ch->position)
player.c:	get_curr_con(ch), ch->perm_con, buf, ch->carry_weight, can_carry_w(ch));
player.c:	get_curr_cha(ch), ch->perm_cha, ch->wimpy);
player.c:        switch (ch->style) {
player.c:	get_curr_lck(ch), ch->perm_lck, buf );
player.c:	ch->pcdata->quest_curr, ch->pcdata->quest_accum );
player.c:	ch->practice, ch->hit, ch->max_hit,
player.c:	IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) ? 'X' : ' ',
player.c:	ch->pcdata->pagerlen, xIS_SET(ch->act, PLR_AUTOEXIT) ? 'X' : ' ');
player.c:		ch->exp, ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->pcdata->mkills,
player.c:		xIS_SET(ch->act, PLR_AUTOLOOT) ? 'X' : ' ');
player.c:    else if (ch->class == CLASS_WARRIOR)
player.c:		ch->exp, ch->pcdata->mkills, xIS_SET(ch->act, PLR_AUTOLOOT) ? 'X' : ' ');
player.c:		ch->exp, ch->mana, ch->max_mana, ch->pcdata->mkills, xIS_SET(ch->act, PLR_AUTOLOOT) ? 'X' : ' ');
player.c:	ch->gold, ch->move, ch->max_move, ch->pcdata->mdeaths, xIS_SET(ch->act, PLR_AUTOSAC) ? 'X' : ' ');
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] == 0)
player.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] == 0)
player.c:    if ( ch->position != POS_SLEEPING )
player.c:	switch( ch->mental_state / 10 )
player.c:    if ( ch->mental_state >45 )
player.c:    if ( ch->mental_state >25 )
player.c:    if ( ch->mental_state <-35 )
player.c:    if ( ch->mental_state <-25 )
player.c:	||  (IS_NPC(ch) && ch->speaks == 0) )
player.c:	    if ( lang_array[iLang] & ch->speaking
player.c:	    ||  (IS_NPC(ch) && !ch->speaking) )
player.c:    if ( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:		ch->pcdata->bestowments );
player.c:    if ( ch->morph && ch->morph->morph )
player.c:                ch->morph->morph->vnum, ch->morph->morph->short_desc, 
player.c:		ch->morph->timer
player.c:                ch->morph->morph->short_desc );
player.c:		ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER  && ch->pcdata->clan->clan_type != CLAN_GUILD )
player.c:		ch->pcdata->clan->name, ch->pcdata->clan->pkills[5],
player.c:		(ch->pcdata->clan->pkills[0]+ch->pcdata->clan->pkills[1]+
player.c:		 ch->pcdata->clan->pkills[2]+ch->pcdata->clan->pkills[3]+
player.c:		 ch->pcdata->clan->pkills[4]) );
player.c:		ch->pcdata->clan->pdeaths[5],
player.c:		( ch->pcdata->clan->pdeaths[0] + ch->pcdata->clan->pdeaths[1] +
player.c:		  ch->pcdata->clan->pdeaths[2] + ch->pcdata->clan->pdeaths[3] +
player.c:		  ch->pcdata->clan->pdeaths[4] ) );
player.c:    if (ch->pcdata->deity)
player.c:	if (ch->pcdata->favor > 2250)
player.c:	else if (ch->pcdata->favor > 2000)
player.c:	else if (ch->pcdata->favor > 1750)
player.c:	else if (ch->pcdata->favor > 1500)
player.c:	else if (ch->pcdata->favor > 1250)
player.c:	else if (ch->pcdata->favor > 1000)
player.c:	else if (ch->pcdata->favor > 750)
player.c:	else if (ch->pcdata->favor > 250)
player.c:	else if (ch->pcdata->favor > -250)
player.c:	else if (ch->pcdata->favor > -750)
player.c:	else if (ch->pcdata->favor > -1000)
player.c:	else if (ch->pcdata->favor > -1250)
player.c:	else if (ch->pcdata->favor > -1500)
player.c:	else if (ch->pcdata->favor > -1750)
player.c:	else if (ch->pcdata->favor > -2000)
player.c:	else if (ch->pcdata->favor > -2250)
player.c:	pager_printf_color(ch, "&CDeity:  &W%-20s &CFavor:  &W%s&C\n\r", ch->pcdata->deity->name, buf );
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_ORDER )
player.c:		ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths);
player.c:    if (ch->pcdata->clan && ch->pcdata->clan->clan_type == CLAN_GUILD )
player.c:                ch->pcdata->clan->name, ch->pcdata->clan->mkills, ch->pcdata->clan->mdeaths);
player.c:    if (ch->first_affect && !str_cmp( arg, "affects" ) )
player.c:	for (paf = ch->first_affect; paf; paf = paf->next)
player.c:	    if (ch->level < 20)
player.c:	     if (ch->level >= 20)
player.c:    if ( ch->class < MAX_NPC_CLASS && ch->class >= 0)
player.c:	return ( npc_class[ch->class] );
player.c:    if(  ch->race < MAX_RACE  && ch->race >= 0)
player.c:        return (race_table[ch->race]->race_name);
player.c:    if ( ch->race < MAX_NPC_RACE && ch->race >= 0)
player.c:	return ( npc_race[ch->race] );
player.c:	ch->name,
player.c:	IS_NPC(ch) ? "" : ch->pcdata->title,
player.c:	ch->level,
player.c:    if ( get_trust( ch ) != ch->level )
player.c:    if (  IS_NPC(ch) && xIS_SET(ch->act, ACT_MOBINVIS) )
player.c:            ch->mobinvis);
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level,
player.c:	ch->move, ch->max_move,
player.c:	ch->practice );
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->mana, ch->max_mana,
player.c:	ch->move, ch->max_move,
player.c:	ch->practice );
player.c:	ch->carry_number, can_carry_n(ch),
player.c:	ch->carry_weight, can_carry_w(ch) );
player.c:	ch->exp,  ch->gold );
player.c:	ch->pcdata->quest_accum, ch->pcdata->quest_curr );
player.c:	(!IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOEXIT)) ? "yes" : "no",
player.c:	(!IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOLOOT)) ? "yes" : "no",
player.c:	(!IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOSAC) ) ? "yes" : "no",
player.c:  	(!IS_NPC(ch) && xIS_SET(ch->act, PLR_AUTOGOLD)) ? "yes" : "no" );
player.c:    pager_printf( ch, "Wimpy set to %d hit points.\n\r", ch->wimpy );
player.c:       if ( ch->pcdata->condition[COND_DRUNK]   > 10 )
player.c:       if ( ch->pcdata->condition[COND_THIRST] ==  0 )
player.c:       if ( ch->pcdata->condition[COND_FULL]   ==  0 )
player.c:    switch( ch->mental_state / 10 )
player.c:    switch ( ch->position )
player.c:    if ( ch->level >= 25 )
player.c:    if ( ch->level >= 15
player.c:    if ( ch->level >= 10 )
player.c:	pager_printf( ch, "Alignment: %d.  ", ch->alignment );
player.c:	 if ( ch->alignment >  900 ) send_to_pager( "angelic.\n\r", ch );
player.c:    else if ( ch->alignment >  700 ) send_to_pager( "saintly.\n\r", ch );
player.c:    else if ( ch->alignment >  350 ) send_to_pager( "good.\n\r",    ch );
player.c:    else if ( ch->alignment >  100 ) send_to_pager( "kind.\n\r",    ch );
player.c:    else if ( ch->alignment > -100 ) send_to_pager( "neutral.\n\r", ch );
player.c:    else if ( ch->alignment > -350 ) send_to_pager( "mean.\n\r",    ch );
player.c:    else if ( ch->alignment > -700 ) send_to_pager( "evil.\n\r",    ch );
player.c:    else if ( ch->alignment > -900 ) send_to_pager( "demonic.\n\r", ch );
player.c:    if ( ch->first_affect )
player.c:	for ( paf = ch->first_affect; paf; paf = paf->next )
player.c:	    if ( ch->level >= 20 )
player.c:			ch->pcdata->wizinvis,
player.c:			xIS_SET(ch->act, PLR_WIZINVIS) ? "ON" : "OFF" );
player.c:	if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
player.c:	  pager_printf( ch, "Room Range: %d - %d\n\r", ch->pcdata->r_range_lo,
player.c:					 	   ch->pcdata->r_range_hi	);
player.c:	if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
player.c:	  pager_printf( ch, "Obj Range : %d - %d\n\r", ch->pcdata->o_range_lo,
player.c:	  					   ch->pcdata->o_range_hi	);
player.c:	if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
player.c:	  pager_printf( ch, "Mob Range : %d - %d\n\r", ch->pcdata->m_range_lo,
player.c:	  					   ch->pcdata->m_range_hi	);
player.c:    if ( ch->level == 1 )
player.c:      lowlvl = UMAX( 2, ch->level - 5 );
player.c:    hilvl = URANGE( ch->level, ch->level + 5, MAX_LEVEL );
player.c:    sprintf( buf, " exp  (You have: %11d)", ch->exp );
player.c:    sprintf( buf2," exp  (To level: %11d)", exp_level(ch, ch->level+1) - ch->exp );
player.c:		(x == ch->level) ? buf : (x == ch->level+1) ? buf2 : " exp" );
player.c:    if ( !ch->pcdata->deity ) {
player.c:    if ( ch->pcdata->favor < ch->level*2 ) {
player.c:    pager_printf( ch, "%s appears in a vision, revealing that your remains... ", ch->pcdata->deity->name );
player.c:    sprintf( buf, "the corpse of %s", ch->name );
player.c:      ch->pcdata->favor -= ch->level*2;
player.c:	  !xIS_EMPTY(ch->affected_by) ? affect_bit_name( &ch->affected_by ) : "nothing" );
player.c:        if ( ch->level >= 20 )
player.c:            if ( ch->resistant > 0 )
player.c:                ch_printf_color( ch, "&C%s\n\r", flag_string(ch->resistant, ris_flags) );
player.c:            if ( ch->immune > 0 )
player.c:                ch_printf_color( ch, "&C%s\n\r",  flag_string(ch->immune, ris_flags) );
player.c:            if ( ch->susceptible > 0 )
player.c:                ch_printf_color( ch, "&C%s\n\r", flag_string(ch->susceptible, ris_flags) );
player.c:    if ( !ch->first_affect )
player.c:        for (paf = ch->first_affect; paf; paf = paf->next)
player.c:            if ( ch->level >= 20
player.c:    show_list_to_char( ch->first_carrying, ch, TRUE, TRUE );
player.c:	for ( obj = ch->first_carrying; obj; obj = obj->next_content )
player.c:                if( (!IS_NPC(ch)) && (ch->race>0) && (ch->race<MAX_RACE))
player.c:                    send_to_char(race_table[ch->race]->where_name[iWear], ch);
player.c:    STRFREE( ch->pcdata->title );
player.c:    ch->pcdata->title = STRALLOC( buf );
player.c:    STRFREE( ch->pcdata->extraname );
player.c:    ch->pcdata->extraname = STRALLOC( buf );
player.c:    STRFREE( ch->pcdata->lastname );
player.c:    ch->pcdata->lastname = STRALLOC( buf );
player.c:    if ( ch->level < 5 )
player.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
player.c:    if ( ch->level < 5 )
player.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
player.c:    if ( ch->level < 5 )
player.c:    if ( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ))
player.c:    if ( ch->level < 5 )
player.c:	if ( !ch->pcdata->homepage )
player.c:	  ch->pcdata->homepage = str_dup( "" );
player.c:		show_tilde( ch->pcdata->homepage ) );
player.c:	if ( ch->pcdata->homepage )
player.c:	  DISPOSE(ch->pcdata->homepage);
player.c:	ch->pcdata->homepage = str_dup("");
player.c:    if ( ch->pcdata->homepage )
player.c:      DISPOSE(ch->pcdata->homepage);
player.c:    ch->pcdata->homepage = str_dup(buf);
player.c:    if ( !ch->desc )
player.c:    switch( ch->substate )
player.c:	   ch->substate = SUB_PERSONAL_DESC;
player.c:	   ch->dest_buf = ch;
player.c:	   start_editing( ch, ch->description );
player.c:	   STRFREE( ch->description );
player.c:	   ch->description = copy_buffer( ch );
player.c:    if ( ch->level < 5 )
player.c:    if ( !ch->desc )
player.c:    switch( ch->substate )
player.c:	   ch->substate = SUB_PERSONAL_BIO;
player.c:	   ch->dest_buf = ch;
player.c:	   start_editing( ch, ch->pcdata->bio );
player.c:	   STRFREE( ch->pcdata->bio );
player.c:	   ch->pcdata->bio = copy_buffer( ch );
player.c: 		ch->hit,  ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:		 10 + ch->level, ch->move, ch->max_move, ch->exp   );
player.c: 		ch->hit,  ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:		 10 + ch->level, ch->move, ch->max_move, ch->exp   );
player.c: 		ch->hit,  ch->max_hit, ch->mana, ch->max_mana,
player.c: 		ch->move, ch->max_move, ch->exp   );
player.c: 		ch->hit,  ch->max_hit, ch->mana, ch->max_mana,
player.c: 		ch->move, ch->max_move, ch->exp   );
player.c:      		ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, 
player.c:		ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:      		ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, 
player.c:		ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c: 		ch->hit,  ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:		 10 + ch->level, ch->move, ch->max_move, ch->exp   );
player.c: 		ch->hit,  ch->max_hit, ch->mana, ch->max_mana,
player.c: 		ch->move, ch->max_move, ch->exp   );
player.c:      		ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, 
player.c:		ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:    if ( IS_NPC( ch ) && ch->fighting )
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level,
player.c:	ch->move, ch->max_move,
player.c:	ch->exp   );
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->mana, ch->max_mana,
player.c:	ch->move, ch->max_move,
player.c:	ch->exp   );
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level,
player.c:	ch->move, ch->max_move,
player.c:	ch->exp   );
player.c:	ch->hit,  ch->max_hit,
player.c:	ch->mana, ch->max_mana,
player.c:	ch->move, ch->max_move,
player.c:	ch->exp   );
player.c:    ch_printf( ch, "%s\n\r", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)"
player.c:				 				: ch->pcdata->fprompt );
player.c:  ch_printf( ch, "%s\n\r", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)"
player.c:							      : ch->pcdata->fprompt );
player.c:  if (ch->pcdata->fprompt)
player.c:    STRFREE(ch->pcdata->fprompt);
player.c:    ch->pcdata->fprompt = STRALLOC("");
player.c:    ch->pcdata->fprompt = STRALLOC(argument);
player.c:    ch_printf( ch, "%s\n\r", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)"
player.c:				 				: ch->pcdata->prompt );
player.c:  ch_printf( ch, "%s\n\r", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)"
player.c:							      : ch->pcdata->prompt );
player.c:  if (ch->pcdata->prompt)
player.c:    STRFREE(ch->pcdata->prompt);
player.c:    ch->pcdata->prompt = STRALLOC("");
player.c:    ch->pcdata->prompt = STRALLOC(argument);
player.c:  int gold = ch->gold;
player.c:  int mgold = (ch->level * 2000000);
player.c:  int tax = (ch->gold * .05);
player.c:	ch->level, mgold );
player.c:	tax, ch->gold );
player.c:	(ch->gold - tax));
player.c:    ch->gold -= tax;
polymorph.c:  if (!ch->desc)
polymorph.c:  switch( ch->substate )
polymorph.c:          if ( !ch->dest_buf )
polymorph.c:                bug( "do_morphset: sub_morph_desc: NULL ch->dest_buf", 0 );
polymorph.c:                ch->substate = SUB_NONE;
polymorph.c:          morph = ch->dest_buf;
polymorph.c:          ch->substate = ch->tempnum;
polymorph.c:          if ( ch->substate == SUB_REPEATCMD )
polymorph.c:	      ch->dest_buf = morph;
polymorph.c:          if ( !ch->dest_buf )
polymorph.c:                bug( "do_morphset: sub_morph_help: NULL ch->dest_buf", 0 );
polymorph.c:                ch->substate = SUB_NONE;
polymorph.c:          morph = ch->dest_buf;
polymorph.c:          ch->substate = ch->tempnum;
polymorph.c:          if ( ch->substate == SUB_REPEATCMD )
polymorph.c:	      ch->dest_buf = morph;
polymorph.c:  if ( ch->substate == SUB_REPEATCMD )
polymorph.c:        morph = ch->dest_buf;
polymorph.c:          ch->substate = SUB_NONE;
polymorph.c:          ch->dest_buf = NULL;
polymorph.c:          if (ch->pcdata && ch->pcdata->subprompt) {
polymorph.c:            STRFREE (ch->pcdata->subprompt);
polymorph.c:            ch->pcdata->subprompt = NULL;
polymorph.c:  if ( ch->substate != SUB_REPEATCMD && arg1[0] != '\0' &&
polymorph.c:  if (arg1[0] == '\0' || (arg2[0] == '\0' && ch->substate != SUB_REPEATCMD)
polymorph.c:      if (ch->substate == SUB_REPEATCMD)
polymorph.c:        ch->substate = SUB_REPEATCMD;
polymorph.c:        ch->dest_buf = morph;
polymorph.c:        if (ch->pcdata)
polymorph.c:            if (ch->pcdata->subprompt) {
polymorph.c:              STRFREE (ch->pcdata->subprompt);
polymorph.c:              ch->pcdata->subprompt = NULL;
polymorph.c:            ch->pcdata->subprompt = STRALLOC (buf);
polymorph.c:        if ( ch->substate == SUB_REPEATCMD )
polymorph.c:          ch->tempnum = SUB_REPEATCMD;
polymorph.c:          ch->tempnum = SUB_NONE;
polymorph.c:        ch->substate = SUB_MORPH_DESC;
polymorph.c:        ch->dest_buf = morph;
polymorph.c:        if ( ch->substate == SUB_REPEATCMD )
polymorph.c:          ch->tempnum = SUB_REPEATCMD;
polymorph.c:          ch->tempnum = SUB_NONE;
polymorph.c:        ch->substate = SUB_MORPH_HELP;
polymorph.c:        ch->dest_buf = morph;
polymorph.c:   else if ( ch->substate == SUB_REPEATCMD )
polymorph.c:        ch->substate = SUB_RESTRICTED;
polymorph.c:        ch->substate = SUB_REPEATCMD;
polymorph.c:        ch->last_cmd = do_morphset;
polymorph.c:  if ( ch->morph )
polymorph.c:  	if ( ch->hit < morph->hpused )
polymorph.c:  		ch->hit -= morph->hpused;
polymorph.c:  	if ( ch->move < morph->moveused )
polymorph.c:  		ch->move -= morph->moveused;
polymorph.c:  	if ( ch->mana < morph->manaused )
polymorph.c:  		ch->mana -= morph->manaused;
polymorph.c:       if ( ch->pcdata->condition[COND_BLOODTHIRST] < morph->bloodused )
polymorph.c:      	ch->pcdata->condition[COND_BLOODTHIRST]-= morph->bloodused;
polymorph.c:  	if ( IS_NPC(ch) || !ch->pcdata->deity || 
polymorph.c:		ch->pcdata->favor < morph->favourused )
polymorph.c:		ch->pcdata->favor -= morph->favourused;
polymorph.c:		if ( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
polymorph.c:	    	  SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
polymorph.c:  	if ( !IS_NPC(ch) && ch->pcdata->quest_curr < morph->gloryused )
polymorph.c:  		ch->pcdata->quest_curr -= morph->gloryused;
polymorph.c:  if ( !ch->morph )
polymorph.c:  temp = ch->morph->morph;
polymorph.c:   if ( ch->level < morph->level )
polymorph.c:   if ( morph->sex != -1 && morph->sex != ch->sex )
polymorph.c:   if ( morph->class != 0 && !IS_SET( morph->class, (1 << ch->class) ) )
polymorph.c:   if ( morph->race != 0 && IS_SET( morph->race, (1 << ch->race ) ) )
polymorph.c:   if ( morph->deity && ( !ch->pcdata->deity || !get_deity ( morph->deity ) ) )
polymorph.c:  if ( ch->morph )
polymorph.c:  ch->armor               += morph->ac;
polymorph.c:  ch->mod_str             += morph->str;
polymorph.c:  ch->mod_int             += morph->inte;
polymorph.c:  ch->mod_wis             += morph->wis;
polymorph.c:  ch->mod_dex             += morph->dex;
polymorph.c:  ch->mod_cha             += morph->cha;
polymorph.c:  ch->mod_lck             += morph->lck;
polymorph.c:  ch->saving_breath       += morph->saving_breath;
polymorph.c:  ch->saving_para_petri   += morph->saving_para_petri;
polymorph.c:  ch->saving_poison_death += morph->saving_poison_death;
polymorph.c:  ch->saving_spell_staff  += morph->saving_spell_staff;
polymorph.c:  ch->saving_wand         += morph->saving_wand;
polymorph.c:  ch->hitroll		  += ch_morph->hitroll;
polymorph.c:  ch->damroll		  += ch_morph->damroll;
polymorph.c:  if ( (ch->hit + ch_morph->hit ) > 32700 )
polymorph.c:	ch_morph->hit = (32700 - ch->hit);
polymorph.c:  ch->hit		  += ch_morph->hit;
polymorph.c:  if ( (ch->move + ch_morph->move ) > 32700 )
polymorph.c:	ch_morph->move = (32700 - ch->move);
polymorph.c:  ch->move		  += ch_morph->move;
polymorph.c:	ch->pcdata->condition[COND_BLOODTHIRST] += ch_morph->blood;
polymorph.c:  	if ( (ch->mana + ch_morph->mana ) > 32700 )
polymorph.c:		ch_morph->mana = (32700 - ch->mana);
polymorph.c: 	ch->mana	  += ch_morph->mana;
polymorph.c:  xSET_BITS ( ch->affected_by, morph->affected_by );
polymorph.c:  SET_BIT ( ch->immune, morph->immune );
polymorph.c:  SET_BIT ( ch->resistant, morph->resistant );
polymorph.c:  SET_BIT ( ch->susceptible, morph->suscept );
polymorph.c:  xREMOVE_BITS ( ch->affected_by, morph->no_affected_by );
polymorph.c:  REMOVE_BIT ( ch->immune, morph->no_immune );
polymorph.c:  REMOVE_BIT ( ch->resistant, morph->no_resistant );
polymorph.c:  REMOVE_BIT ( ch->susceptible, morph->no_suscept );
polymorph.c:  ch->morph = ch_morph;
polymorph.c:  if ( (morph = ch->morph) == NULL )
polymorph.c:  ch->armor               -= morph->ac;
polymorph.c:  ch->mod_str             -= morph->str;
polymorph.c:  ch->mod_int             -= morph->inte;
polymorph.c:  ch->mod_wis             -= morph->wis;
polymorph.c:  ch->mod_dex             -= morph->dex;
polymorph.c:  ch->mod_cha             -= morph->cha;
polymorph.c:  ch->mod_lck             -= morph->lck;
polymorph.c:  ch->saving_breath       -= morph->saving_breath;
polymorph.c:  ch->saving_para_petri   -= morph->saving_para_petri;
polymorph.c:  ch->saving_poison_death -= morph->saving_poison_death;
polymorph.c:  ch->saving_spell_staff  -= morph->saving_spell_staff;
polymorph.c:  ch->saving_wand         -= morph->saving_wand;
polymorph.c:  ch->hitroll             -= morph->hitroll;
polymorph.c:  ch->damroll             -= morph->damroll;
polymorph.c:  ch->hit                 -= morph->hit;
polymorph.c:  ch->move                -= morph->move;
polymorph.c:  	ch->pcdata->condition[COND_BLOODTHIRST]-=morph->blood;
polymorph.c:  	ch->mana          -= morph->mana;
polymorph.c:  xREMOVE_BITS( ch->affected_by, morph->affected_by );
polymorph.c:  REMOVE_BIT ( ch->immune, morph->immune );
polymorph.c:  REMOVE_BIT ( ch->resistant, morph->resistant );
polymorph.c:  REMOVE_BIT ( ch->susceptible, morph->suscept );
polymorph.c:  free_char_morph ( ch->morph );
polymorph.c:  ch->morph = NULL;
polymorph.c:  if ( ch->morph == NULL )
polymorph.c:  morph = ch->morph;
polymorph.c:  ch->morph = morph;
polymorph.c:  for (vch = first_char; vch; vch = vch->next )
polymorph.c:	if ( vch->morph == NULL || vch->morph->morph == NULL || 
polymorph.c:	     vch->morph->morph != morph )
redit.c:    if ( IS_NPC(ch) || !ch->desc )
redit.c:        room = ch->in_room;
redit.c:    d = ch->desc;
redit.c:        if ( !ch->pcdata || !( pArea = ch->pcdata->area ) )
redit.c:    copy->area		        = (ch->pcdata->area) ? ch->pcdata->area : orig->area;
redit.c:    ROOM_INDEX_DATA *room = ch->dest_buf;
redit.c:    EXTRA_DESCR_DATA *ed = ch->spare_ptr;
redit.c:    switch( ch->substate )
redit.c:	if ( !ch->dest_buf )
redit.c:	    bug( "do_redit_reset: sub_obj_extra: NULL ch->dest_buf", 0 );
redit.c:	    ch->substate = SUB_NONE;
redit.c:	    ch->desc->connected = CON_PLAYING;
redit.c:	ch->dest_buf = room;
redit.c:	ch->desc->connected = CON_REDIT;
redit.c:	ch->substate = SUB_NONE;
redit.c:	olc_log( ch->desc, "Edited room description" );
redit.c:	redit_disp_menu( ch->desc );
redit.c:	ch->dest_buf = room;
redit.c:	ch->spare_ptr = ed;
redit.c:	ch->substate = SUB_NONE;
redit.c:	ch->desc->connected = CON_REDIT;
redit.c:	oedit_disp_extra_choice( ch->desc );
redit.c:	OLC_MODE(ch->desc) = REDIT_EXTRADESC_CHOICE;
redit.c:	olc_log( ch->desc, "Edit description for exdesc %s", ed->keyword );
reset.c: * pRoom->people, rch->carrying, obj->contains, and pArea->reset_first ..
reset.c:    pRoom = ch->in_room;
reset.c:    char *nm = (ch->substate == SUB_REPEATCMD ? "" : (aRoom ? "rreset "
reset.c:    ch->substate = SUB_REPEATCMD;
reset.c:    ch->dest_buf = (aRoom ? (void *)aRoom : (void *)pArea);
reset.c:      vnum = (aRoom ? aRoom->vnum : ch->in_room->vnum);
reset.c:        pRoom = ch->in_room;
reset.c:        pRoom = ch->in_room;
reset.c:  if ( ch->substate == SUB_REPEATCMD )
reset.c:    ch->substate = SUB_NONE;
reset.c:    ch->substate = SUB_REPEATCMD;
reset.c:    ch->last_cmd = (aRoom ? do_rreset : do_reset);
reset.c:  if ( ch->substate == SUB_REPEATCMD )
reset.c:    pArea = ch->dest_buf;
reset.c:    if ( pArea && pArea != ch->pcdata->area && pArea != ch->in_room->area )
reset.c:		ch->name);	/* why was this cast to an int? */
reset.c:        ch->substate = SUB_NONE;
reset.c:        ch->dest_buf = NULL;
reset.c:      ch->substate = SUB_NONE;
reset.c:      ch->dest_buf = NULL;
reset.c:      pArea = ch->pcdata->area;
reset.c:      pArea = ch->in_room->area;
reset.c:    pArea = ch->pcdata->area;
reset.c:  if ( ch->substate == SUB_REPEATCMD )
reset.c:    pRoom = ch->dest_buf;
reset.c:      bug("do_rreset: %s's dest_buf points to invalid room", (int)ch->name);
reset.c:    ch->substate = SUB_NONE;
reset.c:    ch->dest_buf = NULL;
reset.c:    pRoom = ch->in_room;
reset.c:  for ( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:    add_reset( pArea, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count,
reset.c:    for ( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:  if ( IS_NPC(ch) || get_trust(ch) < LEVEL_SAVIOR || !ch->pcdata ||
reset.c:      !ch->pcdata->area )
reset.c:  pArea = ch->pcdata->area;
reset.c:  if ( IS_NPC(ch) || get_trust(ch) < LEVEL_SAVIOR || !ch->pcdata ||
reset.c:      !ch->pcdata->area )
reset.c:  pArea = ch->pcdata->area;
save.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:			ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:	       sprintf( buf, "%s had on %s:  ch->level = %d  obj->level = %d",
save.c:		ch->name, obj->name,
save.c:	       	ch->level, obj->level );
save.c:    if ( IS_NPC(ch) || ch->level < 2 )
save.c:    if ( ch->desc && ch->desc->original )
save.c:	ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf( strsave, "%s%c/%s",PLAYER_DIR,tolower(ch->pcdata->filename[0]),
save.c:				 capitalize( ch->pcdata->filename ) );
save.c:        sprintf( strback,"%s%c/%s",BACKUP_DIR,tolower(ch->pcdata->filename[0]),
save.c:                                 capitalize( ch->pcdata->filename ) );
save.c:    if ( ch->level >= LEVEL_IMMORTAL )
save.c:      sprintf( strback, "%s%s", GOD_DIR, capitalize( ch->pcdata->filename ) );
save.c:	fprintf( fp, "Level        %d\n", ch->level );
save.c:	fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:	if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:	  fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo,
save.c:	  				       ch->pcdata->r_range_hi	);
save.c:	if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:	  fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo,
save.c:	  				       ch->pcdata->o_range_hi	);
save.c:	if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:	  fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo,
save.c:	  				       ch->pcdata->m_range_hi	);
save.c:        if ( ch->morph )
save.c:	if ( ch->first_carrying )
save.c:	  fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY );
save.c:        if ( !IS_NPC( ch ) && ch->pcdata->first_alias )
save.c:          fwrite_alias( ch, ch->pcdata->first_alias, fp );
save.c:	if ( sysdata.save_pets && ch->pcdata->pet )
save.c:		fwrite_mobile( fp, ch->pcdata->pet );
save.c:	if ( ch->comments )                 /* comments */
save.c:    fprintf( fp, "Name         %s~\n",	ch->name		);
save.c:    if ( ch->description )
save.c:      fprintf( fp, "Description  %s~\n",	ch->description	);
save.c:    fprintf( fp, "Sex          %d\n",	ch->sex			);
save.c:    fprintf( fp, "Class        %d\n",	ch->class		);
save.c:    fprintf( fp, "Race         %d\n",	ch->race		);
save.c:    fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:    fprintf( fp, "Level        %d\n",	ch->level		);
save.c:	ch->played + (int) (current_time - ch->logon)		);
save.c:	(  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:	&& ch->was_in_room )
save.c:	    ? ch->was_in_room->vnum
save.c:	    : ch->in_room->vnum );
save.c:		ch->pcdata->memorize[0],
save.c:		ch->pcdata->memorize[1],
save.c:		ch->pcdata->memorize[2],
save.c:		ch->pcdata->memorize[3],
save.c:		ch->pcdata->memorize[4],
save.c:		ch->pcdata->memorize[5],
save.c:		ch->pcdata->memorize[6],
save.c:		ch->pcdata->memorize[7] );
save.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:    fprintf( fp, "Gold         %d\n",	ch->gold		);
save.c:    fprintf( fp, "Exp          %d\n",	ch->exp			);
save.c:    fprintf( fp, "Height          %d\n",	ch->height	);
save.c:    fprintf( fp, "Weight          %d\n",	ch->weight	);
save.c:    if ( !xIS_EMPTY(ch->act) )
save.c:      fprintf( fp, "Act          %s\n", print_bitvector(&ch->act) );
save.c:    if ( !xIS_EMPTY(ch->affected_by) )
save.c:      fprintf( fp, "AffectedBy   %s\n",	print_bitvector(&ch->affected_by) );
save.c:    if ( !xIS_EMPTY(ch->no_affected_by) )
save.c:      fprintf( fp, "NoAffectedBy %s\n",	print_bitvector(&ch->no_affected_by) );
save.c:    pos = ch->position;
save.c:    fprintf( fp, "Style     %d\n", ch->style);
save.c:    fprintf( fp, "Practice     %d\n",	ch->practice		);
save.c:    		  ch->saving_poison_death,
save.c:		  ch->saving_wand,
save.c:    		  ch->saving_para_petri,
save.c:    		  ch->saving_breath,
save.c:    		  ch->saving_spell_staff			);
save.c:    fprintf( fp, "Alignment    %d\n",	ch->alignment		);
save.c:    fprintf( fp, "Favor	       %d\n",	ch->pcdata->favor	);
save.c:    fprintf( fp, "Glory        %d\n",   ch->pcdata->quest_curr  );
save.c:    fprintf( fp, "MGlory       %d\n",   ch->pcdata->quest_accum );
save.c:    fprintf( fp, "Hitroll      %d\n",	ch->hitroll		);
save.c:    fprintf( fp, "Damroll      %d\n",	ch->damroll		);
save.c:    fprintf( fp, "Armor        %d\n",	ch->armor		);
save.c:    if ( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n",	ch->wimpy		);
save.c:    if ( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n",	ch->deaf		);
save.c:    if ( ch->pcdata->imc_deaf )
save.c:      fprintf( fp, "IMC          %ld\n", ch->pcdata->imc_deaf );
save.c:    if ( ch->pcdata->imc_allow )
save.c:      fprintf( fp, "IMCAllow     %ld\n", ch->pcdata->imc_allow );
save.c:    if ( ch->pcdata->imc_deny )
save.c:      fprintf( fp, "IMCDeny      %ld\n", ch->pcdata->imc_deny );
save.c:    fprintf(fp, "ICEListen %s~\n", ch->pcdata->ice_listen);
save.c:    if ( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n",	ch->resistant		);
save.c:    if ( ch->no_resistant )
save.c:      fprintf( fp, "NoResistant  %d\n",	ch->no_resistant	);
save.c:    if ( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n",	ch->immune		);
save.c:    if ( ch->no_immune )
save.c:      fprintf( fp, "NoImmune     %d\n",	ch->no_immune		);
save.c:    if ( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n",	ch->susceptible		);
save.c:    if ( ch->no_susceptible )
save.c:      fprintf( fp, "NoSusceptible  %d\n",ch->no_susceptible	);
save.c:    if ( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n",ch->pcdata->outcast_time );
save.c:    if ( ch->pcdata && ch->pcdata->nuisance )
save.c:      fprintf( fp, "NuisanceNew %ld %ld %d %d\n", ch->pcdata->nuisance->time,
save.c:		ch->pcdata->nuisance->max_time,ch->pcdata->nuisance->flags,
save.c:		ch->pcdata->nuisance->power );
save.c:    if ( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n",	ch->mental_state	);
save.c:        fprintf( fp, "Password     %s~\n",	ch->pcdata->pwd		);
save.c:	if ( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c:	  fprintf( fp, "Rank         %s~\n",	ch->pcdata->rank	);
save.c:	if ( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:	  fprintf( fp, "Bestowments  %s~\n", 	ch->pcdata->bestowments );
save.c:	fprintf( fp, "Title        %s~\n",	ch->pcdata->title	);
save.c:	if (ch->pcdata->extraname && ch->pcdata->extraname[0] != '\0' )
save.c:		fprintf( fp, "Extraname %s~\n",ch->pcdata->extraname );
save.c:	if (ch->pcdata->lastname && ch->pcdata->lastname[0] != '\0' );
save.c:		fprintf( fp, "Lastname %s~\n", ch->pcdata->lastname );
save.c:	if ( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:	  fprintf( fp, "Homepage     %s~\n",	ch->pcdata->homepage	);
save.c:	if ( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:	  fprintf( fp, "Bio          %s~\n",	ch->pcdata->bio 	);
save.c:	if ( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:	  fprintf( fp, "AuthedBy     %s~\n",	ch->pcdata->authed_by	);
save.c:	if ( ch->pcdata->min_snoop )
save.c:	  fprintf( fp, "Minsnoop     %d\n",	ch->pcdata->min_snoop	);
save.c:	if ( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:	  fprintf( fp, "Prompt       %s~\n",	ch->pcdata->prompt	);
save.c: 	if ( ch->pcdata->fprompt && *ch->pcdata->fprompt )
save.c:	  fprintf( fp, "FPrompt	     %s~\n",    ch->pcdata->fprompt	);
save.c:	if ( ch->pcdata->pagerlen != 24 )
save.c:	  fprintf( fp, "Pagerlen     %d\n",	ch->pcdata->pagerlen	);
save.c: 		if ( !ch->pcdata->alias[pos]
save.c: 		||   !ch->pcdata->alias_sub[pos] )
save.c: 		fprintf( fp, "Alias %s %s~\n", ch->pcdata->alias[pos],
save.c: 					      ch->pcdata->alias_sub[pos] );
save.c:	for(temp = ch->pcdata->first_ignored; temp; temp = temp->next)
save.c:	  if ( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:	    fprintf( fp, "Bamfin       %s~\n",	ch->pcdata->bamfin	);
save.c:	  if ( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:	    fprintf( fp, "Bamfout      %s~\n",	ch->pcdata->bamfout	);
save.c:          if ( ch->trust )
save.c:            fprintf( fp, "Trust        %d\n",	ch->trust		);
save.c:          if ( ch->pcdata && ch->pcdata->restore_time )
save.c:            fprintf( fp, "Restore_time %ld\n",ch->pcdata->restore_time );
save.c:	  fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:	  if ( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:	    fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo,
save.c:	  					 ch->pcdata->r_range_hi	);
save.c:	  if ( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:	    fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo,
save.c:	  					 ch->pcdata->o_range_hi	);
save.c:	  if ( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:	    fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo,
save.c:	  					 ch->pcdata->m_range_hi	);
save.c:	if ( ch->pcdata->council)
save.c:	  fprintf( fp, "Council      %s~\n", 	ch->pcdata->council_name );
save.c:        if ( ch->pcdata->deity_name && ch->pcdata->deity_name[0] != '\0' )
save.c:	  fprintf( fp, "Deity	     %s~\n",	ch->pcdata->deity_name	 );
save.c:	if ( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:	  fprintf( fp, "Clan         %s~\n",	ch->pcdata->clan_name	);
save.c:        fprintf( fp, "Flags        %d\n",	ch->pcdata->flags	);
save.c:        if ( ch->pcdata->release_date > current_time )
save.c:        	(int)ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:	fprintf( fp, "PKills       %d\n",	ch->pcdata->pkills	);
save.c:	fprintf( fp, "PDeaths      %d\n",	ch->pcdata->pdeaths	);
save.c:        fprintf( fp, "MKills       %d\n",	ch->pcdata->mkills	);
save.c:	fprintf( fp, "MDeaths      %d\n",	ch->pcdata->mdeaths	);
save.c:        fprintf( fp, "ArenaWins    %d\n",	ch->arena_wins		);
save.c:        fprintf( fp, "ArenaKills   %d\n",       ch->arena_kills		);
save.c:        fprintf( fp, "ArenaDeaths  %d\n",	ch->arena_deaths	);
save.c:	fprintf( fp, "IllegalPK    %d\n",	ch->pcdata->illegal_pk	);
save.c:	    ch->perm_str,
save.c:	    ch->perm_int,
save.c:	    ch->perm_wis,
save.c:	    ch->perm_dex,
save.c:	    ch->perm_con,
save.c:	    ch->perm_cha,
save.c:	    ch->perm_lck );
save.c:	    ch->mod_str, 
save.c:	    ch->mod_int, 
save.c:	    ch->mod_wis,
save.c:	    ch->mod_dex, 
save.c:	    ch->mod_con,
save.c:	    ch->mod_cha, 
save.c:	    ch->mod_lck );
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2],
save.c:	    ch->pcdata->condition[3] );
save.c:	if ( ch->desc && ch->desc->host )
save.c:            fprintf( fp, "Site         %s\n", ch->desc->host );
save.c:	    if ( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:			  ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:    for ( paf = ch->first_affect; paf; paf = paf->next )
save.c:    track = URANGE( 2, ((ch->level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
save.c:	if ( ch->pcdata->killed[sn].vnum == 0 )
save.c:		ch->pcdata->killed[sn].vnum,
save.c:		ch->pcdata->killed[sn].count );
save.c:    CREATE( ch->pcdata, PC_DATA, 1 );
save.c:    ch->desc			= d;
save.c:    ch->pcdata->filename	= STRALLOC( name );
save.c:    ch->name			= NULL;
save.c:    ch->act			= multimeb(PLR_BLANK, PLR_COMBINE, PLR_PROMPT, -1);
save.c:    ch->perm_str		= 13;
save.c:    ch->perm_int		= 13;
save.c:    ch->perm_wis		= 13;
save.c:    ch->perm_dex		= 13;
save.c:    ch->perm_con		= 13;
save.c:    ch->perm_cha		= 13;
save.c:    ch->perm_lck		= 13;
save.c:    ch->no_resistant 		= 0;
save.c:    ch->no_susceptible 		= 0;
save.c:    ch->no_immune 		= 0;
save.c:    ch->was_in_room		= NULL;
save.c:    xCLEAR_BITS(ch->no_affected_by);
save.c:    ch->pcdata->condition[COND_THIRST]	= 48;
save.c:    ch->pcdata->condition[COND_FULL]	= 48;
save.c:    ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:    ch->pcdata->nuisance		= NULL;
save.c:    ch->pcdata->wizinvis		= 0;
save.c:    ch->mental_state			= -10;
save.c:    ch->mobinvis			= 0;
save.c:        ch->pcdata->learned[i]		= 0;
save.c:    ch->pcdata->release_date		= 0;
save.c:    ch->pcdata->helled_by		= NULL;
save.c:    ch->saving_poison_death 		= 0;
save.c:    ch->saving_wand			= 0;
save.c:    ch->saving_para_petri		= 0;
save.c:    ch->saving_breath			= 0;
save.c:    ch->saving_spell_staff		= 0;
save.c:    ch->style 				= STYLE_FIGHTING;
save.c:    ch->comments                        = NULL;    /* comments */
save.c:    ch->pcdata->pagerlen		= 24;
save.c:    ch->pcdata->first_ignored		= NULL;    /* Ignore list */
save.c:    ch->pcdata->last_ignored		= NULL;
save.c:    ch->pcdata->tell_history		= NULL;	/* imm only lasttell cmnd */
save.c:    ch->pcdata->lt_index		= 0;	/* last tell index */
save.c:    ch->morph                           = NULL;
save.c:    ch->pcdata->imc_deaf		= 0;
save.c:    ch->pcdata->imc_deny		= 0;
save.c:    ch->pcdata->imc_allow		= 0;
save.c:    ch->pcdata->ice_listen		= NULL;
save.c:	  preload ? "Preloading" : "Loading", ch->pcdata->filename,
save.c:					ch->pcdata->pet = mob;
save.c:    if ( ch->pcdata->ice_listen == NULL )
save.c:        ch->pcdata->ice_listen = str_dup("");
save.c:        ch->name	   		= STRALLOC( name );
save.c:	ch->short_descr			= STRALLOC( "" );
save.c:	ch->long_descr			= STRALLOC( "" );
save.c:	ch->description			= STRALLOC( "" );
save.c:	ch->editor			= NULL;
save.c:	ch->pcdata->clan_name		= STRALLOC( "" );
save.c:	ch->pcdata->clan		= NULL;
save.c:	ch->pcdata->council_name 	= STRALLOC( "" );
save.c:	ch->pcdata->council 		= NULL;
save.c:  	ch->pcdata->deity_name		= STRALLOC( "" );
save.c:	ch->pcdata->deity		= NULL;
save.c:	ch->pcdata->pet			= NULL;
save.c:	ch->pcdata->pwd			= str_dup( "" );
save.c:	ch->pcdata->bamfin		= str_dup( "" );
save.c:	ch->pcdata->bamfout		= str_dup( "" );
save.c:	ch->pcdata->rank		= str_dup( "" );
save.c:	ch->pcdata->bestowments		= str_dup( "" );
save.c:	ch->pcdata->title		= STRALLOC( "" );
save.c:	ch->pcdata->extraname	= STRALLOC( "" );
save.c:	ch->pcdata->lastname	= STRALLOC( "" );
save.c:	ch->pcdata->homepage		= str_dup( "" );
save.c:	ch->pcdata->bio 		= STRALLOC( "" );
save.c:	ch->pcdata->authed_by		= STRALLOC( "" );
save.c:	ch->pcdata->prompt		= STRALLOC( "" );
save.c:	ch->pcdata->fprompt		= STRALLOC( "" );
save.c:	ch->pcdata->r_range_lo		= 0;
save.c:	ch->pcdata->r_range_hi		= 0;
save.c:	ch->pcdata->m_range_lo		= 0;
save.c:	ch->pcdata->m_range_hi		= 0;
save.c:	ch->pcdata->o_range_lo		= 0;
save.c:	ch->pcdata->o_range_hi		= 0;
save.c:	ch->pcdata->wizinvis		= 0;
save.c:	if ( !ch->name )
save.c:    		ch->name	= STRALLOC( name );
save.c:	if ( !ch->pcdata->clan_name )
save.c:	  ch->pcdata->clan_name	= STRALLOC( "" );
save.c:	  ch->pcdata->clan	= NULL;
save.c:	if ( !ch->pcdata->council_name )
save.c:	  ch->pcdata->council_name = STRALLOC( "" );
save.c:	  ch->pcdata->council 	= NULL;
save.c:	if ( !ch->pcdata->deity_name )
save.c:	  ch->pcdata->deity_name = STRALLOC( "" );
save.c:	  ch->pcdata->deity	 = NULL;
save.c:        if ( !ch->pcdata->bio )
save.c:          ch->pcdata->bio	 = STRALLOC( "" );
save.c:	if ( !ch->pcdata->authed_by )
save.c:	  ch->pcdata->authed_by	 = STRALLOC( "" );
save.c:	if ( xIS_SET(ch->act, PLR_FLEE) )
save.c:	  xREMOVE_BIT(ch->act, PLR_FLEE);
save.c:	  if ( ch->pcdata->wizinvis < 2 )
save.c:	    ch->pcdata->wizinvis = ch->level;
save.c:		REMOVE_BIT(ch->speaks, LANG_COMMON | race_table[ch->race]->language);
save.c:	if ( countlangs(ch->speaks) < (ch->level / 10) && !IS_IMMORTAL(ch) )
save.c:			int need = (ch->level / 10) - countlangs(ch->speaks);
save.c:			if ( ch->practice >= prac )
save.c:			if ( ch->pcdata->learned[iLang] > 0 )
save.c:			SET_BIT(ch->speaks, lang_array[lang]);
save.c:			ch->pcdata->learned[iLang] = 70;
save.c:			ch->speaks &= VALID_LANGS;
save.c:			REMOVE_BIT(ch->speaks,
save.c:					   LANG_COMMON | race_table[ch->race]->language);
save.c:	    KEY( "Act",		ch->act,		fread_bitvector( fp ) );
save.c:	    KEY( "AffectedBy",	ch->affected_by,	fread_bitvector( fp ) );
save.c:	    KEY( "Alignment",	ch->alignment,		fread_number( fp ) );
save.c:	    KEY( "Armor",	ch->armor,		fread_number( fp ) );
save.c:	    KEY( "ArenaWins",	ch->arena_wins,		fread_number( fp ) );
save.c:	    KEY( "ArenaKills",  ch->arena_kills,	fread_number( fp ) );
save.c:	    KEY( "ArenaDeaths", ch->arena_deaths,	fread_number( fp ) );
save.c:		LINK(paf, ch->first_affect, ch->last_affect, next, prev );
save.c:		ch->mod_str = x1;
save.c:		ch->mod_int = x2;
save.c:		ch->mod_wis = x3;
save.c:		ch->mod_dex = x4;
save.c:		ch->mod_con = x5;
save.c:		ch->mod_cha = x6;
save.c:		ch->mod_lck = x7;
save.c:		ch->mod_lck = 0;
save.c:			ch->pcdata->alias[count]      =	 str_dup( fread_word( fp ) );
save.c:			ch->pcdata->alias_sub[count]  =	 fread_string_nohash( fp );
save.c:		ch->perm_str = x1;
save.c:		ch->perm_int = x2;
save.c:		ch->perm_wis = x3;
save.c:		ch->perm_dex = x4;
save.c:		ch->perm_con = x5;
save.c:		ch->perm_cha = x6;
save.c:		ch->perm_lck = x7;
save.c:		  ch->perm_lck = 13;
save.c:	    KEY( "AuthedBy",	ch->pcdata->authed_by,	fread_string( fp ) );
save.c:	    KEY( "Bamfin",	ch->pcdata->bamfin,	fread_string_nohash( fp ) );
save.c:	    KEY( "Bamfout",	ch->pcdata->bamfout,	fread_string_nohash( fp ) );
save.c:	    KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:	    KEY( "Bio",		ch->pcdata->bio,	fread_string( fp ) );
save.c:		ch->pcdata->clan_name = fread_string( fp );
save.c:		&&   ch->pcdata->clan_name[0] != '\0'
save.c:		&& ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name )) == NULL )
save.c:		           ch->pcdata->clan_name );
save.c:		  STRFREE( ch->pcdata->clan_name );
save.c:		  ch->pcdata->clan_name = STRALLOC( "" );
save.c:	    KEY( "Class",	ch->class,		fread_number( fp ) );
save.c:		ch->pcdata->condition[0] = x1;
save.c:		ch->pcdata->condition[1] = x2;
save.c:		ch->pcdata->condition[2] = x3;
save.c:		ch->pcdata->condition[3] = x4;
save.c:		ch->pcdata->council_name = fread_string( fp );
save.c:		&&   ch->pcdata->council_name[0] != '\0'
save.c:		&& ( ch->pcdata->council = get_council( ch->pcdata->council_name )) == NULL )
save.c:		           ch->pcdata->council_name );
save.c:		  STRFREE( ch->pcdata->council_name );
save.c:		  ch->pcdata->council_name = STRALLOC( "" );
save.c:	    KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Deaf",	ch->deaf,		fread_number( fp ) );
save.c:                ch->pcdata->deity_name = fread_string( fp );
save.c:                &&   ch->pcdata->deity_name[0] != '\0'
save.c:                && ( ch->pcdata->deity = get_deity( ch->pcdata->deity_name )) == NULL )
save.c:                           ch->pcdata->deity_name );
save.c:                  STRFREE( ch->pcdata->deity_name );
save.c:                  ch->pcdata->deity_name = STRALLOC( "" );
save.c:		  ch->pcdata->favor = 0;
save.c:	    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Favor",	ch->pcdata->favor,	fread_number( fp ) );
save.c:	    KEY( "Flags",	ch->pcdata->flags,	fread_number( fp ) );
save.c:	    KEY( "FPrompt",	ch->pcdata->fprompt,	fread_string( fp ) );
save.c:	    KEY( "Glory",       ch->pcdata->quest_curr, fread_number( fp ) );
save.c:	    KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:		ch->pcdata->clan_name = fread_string( fp );
save.c:		&&   ch->pcdata->clan_name[0] != '\0'
save.c:		&& ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name )) == NULL )
save.c:		           ch->pcdata->clan_name );
save.c:		  STRFREE( ch->pcdata->clan_name );
save.c:		  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Height",        ch->height,   fread_number( fp ) );
save.c:	      ch->pcdata->release_date = fread_number(fp);
save.c:	      ch->pcdata->helled_by = fread_string(fp);
save.c:	      if ( ch->pcdata->release_date < current_time )
save.c:	        STRFREE(ch->pcdata->helled_by);
save.c:	        ch->pcdata->helled_by = NULL;
save.c:	        ch->pcdata->release_date = 0;
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Homepage",	ch->pcdata->homepage,	fread_string_nohash( fp ) );
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		ch->mana	= fread_number( fp );
save.c:		ch->max_mana	= fread_number( fp );
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:	    	for(ign = 0, inode = ch->pcdata->first_ignored; inode;
save.c:	    		LINK(inode, ch->pcdata->first_ignored,
save.c:	    			ch->pcdata->last_ignored, next,
save.c:	    KEY( "IllegalPK",	ch->pcdata->illegal_pk,	fread_number( fp ) );
save.c:	    KEY ( "IMC",	ch->pcdata->imc_deaf,	fread_number( fp ) );
save.c:	    KEY ( "IMCAllow",	ch->pcdata->imc_allow,	fread_number( fp ) );
save.c:	    KEY ( "IMCDeny",	ch->pcdata->imc_deny,	fread_number( fp ) );
save.c:	    KEY ( "ICEListen",	ch->pcdata->ice_listen, fread_string_nohash( fp ) );
save.c:	    KEY( "Immune",	ch->immune,		fread_number( fp ) );
save.c:		    ch->pcdata->killed[killcnt].vnum    = fread_number( fp );
save.c:		    ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:		ch->pcdata->lastname = fread_string( fp );
save.c:		if ( isalpha(ch->pcdata->lastname[0])
save.c:		||   isdigit(ch->pcdata->lastname[0]) )
save.c:		    sprintf( buf, " %s", ch->pcdata->lastname );
save.c:		    if ( ch->pcdata->lastname )
save.c:		      STRFREE( ch->pcdata->lastname );
save.c:		    ch->pcdata->lastname = STRALLOC( buf );
save.c:	    KEY( "Level",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "LongDescr",	ch->long_descr,		fread_string( fp ) );
save.c:	    	ch->speaks = fread_number( fp );
save.c:	    	ch->speaking = fread_number( fp );
save.c:	    KEY( "MDeaths",	ch->pcdata->mdeaths,	fread_number( fp ) );
save.c:			ch->pcdata->memorize[0] = fread_number( fp );
save.c:			ch->pcdata->memorize[1] = fread_number( fp );
save.c:			ch->pcdata->memorize[2] = fread_number( fp );
save.c:			ch->pcdata->memorize[3] = fread_number( fp );
save.c:			ch->pcdata->memorize[4] = fread_number( fp );
save.c:			ch->pcdata->memorize[5] = fread_number( fp );
save.c:			ch->pcdata->memorize[6] = fread_number( fp );
save.c:			ch->pcdata->memorize[7] = fread_number( fp );
save.c:		KEY( "Mentalstate", ch->mental_state,	fread_number( fp ) );
save.c:	    KEY( "MGlory",      ch->pcdata->quest_accum,fread_number( fp ) );
save.c:	    KEY( "Minsnoop",	ch->pcdata->min_snoop,	fread_number( fp ) );
save.c:	    KEY( "MKills",	ch->pcdata->mkills,	fread_number( fp ) );
save.c:	    KEY( "Mobinvis",	ch->mobinvis,		fread_number( fp ) );
save.c:		ch->pcdata->m_range_lo = fread_number( fp );
save.c:		ch->pcdata->m_range_hi = fread_number( fp );
save.c:	    KEY ("Name", ch->name, fread_string( fp ) );
save.c:            KEY ("NoAffectedBy", ch->no_affected_by, fread_bitvector( fp ) );
save.c:            KEY ("NoImmune", ch->no_immune, fread_number( fp ) );
save.c:            KEY ("NoResistant", ch->no_resistant, fread_number( fp ) );
save.c:            KEY ("NoSusceptible", ch->no_susceptible, fread_number( fp ) );
save.c:                CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:                ch->pcdata->nuisance->time = fread_number( fp );
save.c:                ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:                ch->pcdata->nuisance->flags = fread_number( fp );
save.c:		ch->pcdata->nuisance->power = 1;
save.c:		CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:		ch->pcdata->nuisance->time = fread_number( fp );
save.c:		ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:		ch->pcdata->nuisance->flags = fread_number( fp );
save.c:		ch->pcdata->nuisance->power = fread_number( fp );
save.c:	    KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:		ch->pcdata->o_range_lo = fread_number( fp );
save.c:		ch->pcdata->o_range_hi = fread_number( fp );
save.c:	    KEY( "Pagerlen",	ch->pcdata->pagerlen,	fread_number( fp ) );
save.c:	    KEY( "Password",	ch->pcdata->pwd,	fread_string_nohash( fp ) );
save.c:	    KEY( "PDeaths",	ch->pcdata->pdeaths,	fread_number( fp ) );
save.c:	    KEY( "PKills",	ch->pcdata->pkills,	fread_number( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    /* KEY( "Position",	ch->position,		fread_number( fp ) );*/
save.c:               ch->position          = fread_number( fp );
save.c:               if(ch->position<100){
save.c:                  switch(ch->position){
save.c:                      case 5: ch->position=6; break;
save.c:                      case 6: ch->position=8; break;
save.c:                      case 7: ch->position=9; break;
save.c:                      case 8: ch->position=12; break;
save.c:                      case 9: ch->position=13; break;
save.c:                      case 10: ch->position=14; break;
save.c:                      case 11: ch->position=15; break;
save.c:                  ch->position-=100;
save.c:	    KEY( "Practice",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Prompt",	ch->pcdata->prompt,	fread_string( fp ) );
save.c:	    KEY( "Race",        ch->race,		fread_number( fp ) );
save.c:	    KEY( "Rank",        ch->pcdata->rank,	fread_string_nohash( fp ) );
save.c:	    KEY( "Resistant",	ch->resistant,		fread_number( fp ) );
save.c:	    KEY( "Restore_time",ch->pcdata->restore_time, fread_number( fp ) );
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( !ch->in_room )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:		ch->pcdata->r_range_lo = fread_number( fp );
save.c:		ch->pcdata->r_range_hi = fread_number( fp );
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	ch->short_descr,	fread_string( fp ) );
save.c:	    KEY( "Style",	ch->style,		fread_number( fp ) );
save.c:	    KEY( "Susceptible",	ch->susceptible,	fread_number( fp ) );
save.c:		ch->saving_wand 	= fread_number( fp );
save.c:		ch->saving_poison_death = ch->saving_wand;
save.c:		ch->saving_para_petri 	= ch->saving_wand;
save.c:		ch->saving_breath 	= ch->saving_wand;
save.c:		ch->saving_spell_staff 	= ch->saving_wand;
save.c:		ch->saving_poison_death = fread_number( fp );
save.c:		ch->saving_wand 	= fread_number( fp );
save.c:		ch->saving_para_petri 	= fread_number( fp );
save.c:		ch->saving_breath 	= fread_number( fp );
save.c:		ch->saving_spell_staff 	= fread_number( fp );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    if ( ch->level < LEVEL_IMMORTAL )
save.c:		      if ( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:		        ch->pcdata->learned[sn] = 0;
save.c:		        ch->practice++;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    if ( ch->level < LEVEL_IMMORTAL )
save.c:			if ( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:			    ch->pcdata->learned[sn] = 0;
save.c:			    ch->practice++;
save.c:		ch->pcdata->extraname = fread_string( fp );
save.c:		if ( isalpha(ch->pcdata->extraname[0])
save.c:		||   isdigit(ch->pcdata->extraname[0]) )
save.c:		    sprintf( buf, " %s", ch->pcdata->extraname );
save.c:		    if ( ch->pcdata->extraname )
save.c:		      STRFREE( ch->pcdata->extraname );
save.c:		    ch->pcdata->extraname = STRALLOC( buf );
save.c:		if (!ch->short_descr)
save.c:		  ch->short_descr	= STRALLOC( "" );
save.c:		if (!ch->long_descr)
save.c:		  ch->long_descr	= STRALLOC( "" );
save.c:		if (!ch->description)
save.c:		  ch->description	= STRALLOC( "" );
save.c:		if (!ch->pcdata->pwd)
save.c:		  ch->pcdata->pwd	= str_dup( "" );
save.c:		if (!ch->pcdata->bamfin)
save.c:		  ch->pcdata->bamfin	= str_dup( "" );
save.c:		if (!ch->pcdata->bamfout)
save.c:		  ch->pcdata->bamfout	= str_dup( "" );
save.c:		if (!ch->pcdata->bio)
save.c:		  ch->pcdata->bio	= STRALLOC( "" );
save.c:		if (!ch->pcdata->rank)
save.c:		  ch->pcdata->rank	= str_dup( "" );
save.c:		if (!ch->pcdata->bestowments)
save.c:		  ch->pcdata->bestowments = str_dup( "" );
save.c:		if (!ch->pcdata->title)
save.c:		  ch->pcdata->title	= STRALLOC( "" );
save.c:		if (!ch->pcdata->extraname)
save.c:			ch->pcdata->extraname = STRALLOC( "" );
save.c:		if (!ch->pcdata->lastname)
save.c:			ch->pcdata->lastname = STRALLOC( "" );
save.c:		if (!ch->pcdata->homepage)
save.c:		  ch->pcdata->homepage	= str_dup( "" );
save.c:		if (!ch->pcdata->authed_by)
save.c:		  ch->pcdata->authed_by = STRALLOC( "" );
save.c:		if (!ch->pcdata->prompt )
save.c:		  ch->pcdata->prompt	= STRALLOC( "" );
save.c:	        if (!ch->pcdata->fprompt )
save.c:		  ch->pcdata->fprompt   = STRALLOC( "" );
save.c:		ch->editor		= NULL;
save.c:		killcnt = URANGE( 2, ((ch->level+3) * MAX_KILLTRACK)/LEVEL_AVATAR, MAX_KILLTRACK );
save.c:		  ch->pcdata->killed[killcnt].vnum = 0;
save.c:		if ( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:			ch->speaking = LANG_COMMON;
save.c:		/*	ch->speaking = race_table[ch->race]->language; */
save.c:			ch->speaks = ~0;
save.c:			if ( ch->speaking == 0 )
save.c:				ch->speaking = ~0;
save.c:			CREATE(ch->pcdata->tell_history, char *, 26);
save.c:				ch->pcdata->tell_history[i] = NULL;
save.c:		if ( !ch->pcdata->prompt )
save.c:		  ch->pcdata->prompt = STRALLOC("");
save.c:                if ( ch->height== 72)
save.c:                   ch->height = number_range(race_table[ch->race]->height *.9, race_table[ch->race]->height *1.1);
save.c:		if ( ch->weight==180)
save.c:		   ch->weight = number_range(race_table[ch->race]->weight *.9, race_table[ch->race]->weight *1.1);
save.c:	    KEY( "Exp",		ch->exp,		fread_number( fp ) );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    if ( ch->level < LEVEL_IMMORTAL )
save.c:			if ( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:			    ch->pcdata->learned[sn] = 0;
save.c:			    ch->practice++;
save.c:	    KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:	    ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:		ch->pcdata->title = fread_string( fp );
save.c:		if ( isalpha(ch->pcdata->title[0])
save.c:		||   isdigit(ch->pcdata->title[0]) )
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    if ( ch->pcdata->title )
save.c:		      STRFREE( ch->pcdata->title );
save.c:		    ch->pcdata->title = STRALLOC( buf );
save.c:		ch->pIndexData = get_mob_index( fread_number( fp ) );
save.c:            KEY( "Weight",        ch->weight,   fread_number( fp ) );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    if ( ch->level < LEVEL_IMMORTAL )
save.c:			if ( skill_table[sn]->skill_level[ch->class] >= LEVEL_IMMORTAL )
save.c:			    ch->pcdata->learned[sn] = 0;
save.c:			    ch->practice++;
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "WizInvis",	ch->pcdata->wizinvis,	fread_number( fp ) );
save.c:	room = ch->in_room;
save.c:		    LINK( alias, ch->pcdata->first_alias, ch->pcdata->last_alias, next, prev );
save.c:    name = ch->name;
save.c:  if ( IS_NPC( ch ) || !ch->pcdata->pet )
save.c:  mob = ch->pcdata->pet;
save.c:		if (ch->in_room) {
save.c:			return ch->in_room->vnum;
save.c:			bug("get_obj_room_vnum_recursive: Char \"%s\" not in room?!",ch->name);
save.c:		for (rch = first_char; rch; rch = rch->next ) {
save.c:			if (!IS_NPC(rch) || rch==supermob || xIS_SET(rch->act, ACT_PROTOTYPE) || xIS_SET(rch->act, ACT_PET))
saveall.c:    for ( vch = first_char; vch; vch = vch->next )
saveall.c:           pager_printf( ch, "Saving %-s...\n\r", vch->name);
shops.c:    for ( keeper = ch->in_room->first_person;
shops.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_KILLER) )
shops.c:	sprintf( buf, "%s the KILLER is over here!\n\r", ch->name );
shops.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_THIEF) )
shops.c:	sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
shops.c:    speakswell = UMIN(knows_language(keeper, ch->speaking, ch),
shops.c:		      knows_language(ch, ch->speaking, keeper));
shops.c:	    sprintf( buf, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:	    sprintf( buf, "%s Could you say that a little more clearly please?", ch->name );
shops.c:	    sprintf( buf, "%s Sorry... What was that you wanted?", ch->name );
shops.c:	    sprintf( buf, "%s I can't understand you.", ch->name );
shops.c:    for ( keeper = ch->in_room->first_person;
shops.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_KILLER) )
shops.c:	sprintf( buf, "%s the KILLER is over here!\n\r", ch->name );
shops.c:    if ( !IS_NPC(ch) && xIS_SET(ch->act, PLR_THIEF) )
shops.c:	sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
shops.c:    speakswell = UMIN(knows_language(keeper, ch->speaking, ch),
shops.c:		      knows_language(ch, ch->speaking, keeper));
shops.c:	    sprintf( buf, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:	    sprintf( buf, "%s Could you say that a little more clearly please?", ch->name );
shops.c:	    sprintf( buf, "%s Sorry... What was that you wanted?", ch->name );
shops.c:	    sprintf( buf, "%s I can't understand you.", ch->name );
shops.c:    if ( ch->gold > (ch->level * ch->level * 100000) )
shops.c:		  + ((URANGE(5,ch->level,LEVEL_AVATAR)-20)/2);
shops.c:	cost = (int) (cost * (80 + UMIN(ch->level, LEVEL_AVATAR))) / 100;
shops.c:        switch(ch->race) /* racism... should compare against shopkeeper's race */
shops.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
shops.c:	pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:	in_room     = ch->in_room;
shops.c:	ch->in_room = pRoomIndexNext;
shops.c:	ch->in_room = in_room;
shops.c:	if ( xIS_SET(ch->act, PLR_BOUGHT_PET) )
shops.c:	if ( ch->gold < 10 * pet->level * pet->level )
shops.c:	if ( ch->level < pet->level )
shops.c:	ch->gold	-= maxgold;
shops.c:	boost_economy( ch->in_room->area, maxgold );
shops.c:	xSET_BIT(ch->act, PLR_BOUGHT_PET);
shops.c:	    pet->description, ch->name );
shops.c:	char_to_room( pet, ch->in_room );
shops.c:		ch->reply = keeper;
shops.c:	    ch->reply = keeper;
shops.c:	    ch->reply = keeper;
shops.c:	if ( ch->gold < cost )
shops.c:	    ch->reply = keeper;
shops.c:/*	if ( obj->level > ch->level )
shops.c:	    ch->reply = keeper;
shops.c:      	    ch->reply = keeper;
shops.c:	if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:	if ( ch->carry_weight + ( get_obj_weight( obj ) * noi )
shops.c:	ch->gold     -= cost;
shops.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
shops.c:        pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:            bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:	ch->reply = keeper;
shops.c:    ch->gold     += cost;
shops.c:	ch->reply = keeper;
shops.c:    ch->reply = keeper;
shops.c:   else if ( (cost = strcmp("all",arg) ? cost : 11*cost/10) > ch->gold )
shops.c:      ch->gold     -= cost;
shops.c:	for ( obj = ch->first_carrying; obj ; obj = obj->next_content )
shops.c:	ch->reply = keeper;
shops.c:    for ( obj = ch->first_carrying; obj != NULL ; obj = obj->next_content )
shops.c:	ch->reply = keeper;
shops.c:    if ( cost > ch->gold )
skills.c:  if ( ch->pcdata->clan && ch->pcdata->clan == vch->pcdata->clan )
skills.c:	||  (ch->pcdata->learned[sn] > 0
skills.c:	&&   ch->level >= skill_table[sn]->skill_level[ch->class])) )
skills.c:	   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:	    if (ch->pcdata->condition[COND_BLOODTHIRST] < blood)
skills.c:	if ( !IS_NPC(ch) && ch->mana < mana )
skills.c:		if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
skills.c:		  ch->mana -= mana/2;
skills.c:		ch->mana -= mana;
skills.c:	retcode = (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, vo );
skills.c:	    for ( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:		vch_next = vch->next_in_room;
skills.c:	  ch->mana -= mana;
skills.c:    ch->prev_cmd = ch->last_cmd;    /* haus, for automapping */
skills.c:    ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:    if ( IS_NPC(ch) || ch->pcdata->learned[sn] <= 0 )
skills.c:    sklvl = skill_table[sn]->skill_level[ch->class];
skills.c:	sklvl = ch->level;
skills.c:    if ( ch->pcdata->learned[sn] < adept )
skills.c:	chance = ch->pcdata->learned[sn] + (5 * skill_table[sn]->difficulty);
skills.c:	ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:	if ( ch->pcdata->learned[sn] == adept )	 /* fully learned! */
skills.c:            if ( ch->class==CLASS_MAGE ) gain *= 5;	/* h, mage upgrade */
skills.c:            if ( ch->class==CLASS_CLERIC ) gain *= 2;	/* h, mage upgrade */
skills.c:            if ( ch->class==CLASS_MAGE ) gain *= 6;	/* h, mage upgrade */
skills.c:            if ( ch->class==CLASS_CLERIC ) gain *= 3;	/* h, mage upgrade */
skills.c:	    if ( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:    if ( IS_NPC(ch) || ch->pcdata->learned[sn] <= 0 )
skills.c:    chance = ch->pcdata->learned[sn] + (5 * skill_table[sn]->difficulty);
skills.c:    if ( ch->pcdata->learned[sn] < (adept-1) )
skills.c:	ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + 1 );
skills.c:    if ( ch->mount )
skills.c:	dam = number_range( 5, ch->level );
skills.c:		    af.duration = ( ch->level+10 ) / get_curr_con( victim );
skills.c:		    af.duration  = 3 + (ch->level/15);
skills.c:    switch( ch->substate )
skills.c:	    if ( ch->mount )
skills.c:	    if ( !ch->in_room->first_content )
skills.c:	    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:	    ch->alloc_ptr = str_dup( obj->name );
skills.c:	    if ( !ch->alloc_ptr )
skills.c:		bug( "do_detrap: ch->alloc_ptr NULL!", 0 );
skills.c:	    strcpy( arg, ch->alloc_ptr );
skills.c:	    DISPOSE( ch->alloc_ptr );
skills.c:	    ch->alloc_ptr = NULL;
skills.c:	    ch->substate = SUB_NONE;
skills.c:	    DISPOSE(ch->alloc_ptr);
skills.c:	    ch->substate = SUB_NONE;
skills.c:    if ( !ch->in_room->first_content )
skills.c:    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:    percent  = number_percent( ) - ( ch->level / 15 ) 
skills.c:    switch( ch->substate )
skills.c:          if ( ch->mount )
skills.c:	      switch( ch->in_room->sector_type )
skills.c:	  ch->alloc_ptr = str_dup( arg );
skills.c:	  if ( !ch->alloc_ptr )
skills.c:	  strcpy( arg, ch->alloc_ptr );  
skills.c:	  DISPOSE( ch->alloc_ptr );	
skills.c:	  DISPOSE( ch->alloc_ptr );
skills.c:	  ch->substate = SUB_NONE;
skills.c:    ch->substate = SUB_NONE;
skills.c:    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:    startobj = ch->in_room->first_content;
skills.c:	    (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:    switch( ch->substate )
skills.c:	    if ( ch->mount )
skills.c:	    ch->alloc_ptr = str_dup( arg );
skills.c:	    if ( !ch->alloc_ptr )
skills.c:	    strcpy( arg, ch->alloc_ptr );
skills.c:	    DISPOSE( ch->alloc_ptr );
skills.c:	    DISPOSE( ch->alloc_ptr );
skills.c:	    ch->substate = SUB_NONE;
skills.c:    ch->substate = SUB_NONE;
skills.c:	startobj = ch->in_room->first_content;
skills.c:    percent  = number_percent( ) + number_percent( ) - ( ch->level / 10 );
skills.c:	if ( (pexit = get_exit( ch->in_room, door )) != NULL
skills.c:    if ( ch->mount )
skills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:	if ((ch->level > victim->level + 10) && !IS_NPC(victim)) {
skills.c:	if ((ch->level < victim->level - 10) && !IS_NPC(victim)) {
skills.c:    if( ch->level + 10 < victim->level )
skills.c:	sprintf( buf, "%s is a bloody thief!", ch->name );
skills.c:		  if ( (mst = ch->master) == NULL )
skills.c:	ch->gold     += amount;
skills.c:    ||   obj->level > ch->level )
skills.c:    if ( ch->carry_number + (get_obj_number(obj)/obj->count) > can_carry_n( ch ) )
skills.c:    if ( ch->carry_weight + (get_obj_weight(obj)/obj->count) > can_carry_w( ch ) )
skills.c:    if ( ch->mount )
skills.c:    if ( ch->mount )
skills.c:    if ( !ch->fighting )
skills.c:    if ( ch->fighting )
skills.c:    &&   ch->level < skill_table[gsn_kick]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_kick );
skills.c:    &&   ch->level < skill_table[gsn_punch]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_punch );
skills.c:    &&   ch->level < skill_table[gsn_bite]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bite );
skills.c:    &&   ch->level < skill_table[gsn_claw]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_claw );
skills.c:    &&   ch->level < skill_table[gsn_sting]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_sting );
skills.c:    &&   ch->level < skill_table[gsn_tail]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_tail );
skills.c:    &&   ch->level < skill_table[gsn_bash]->skill_level[ch->class] )
skills.c:	global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bash );
skills.c:    &&   ch->level < skill_table[gsn_stun]->skill_level[ch->class] )
skills.c:    if ( !IS_NPC(ch) && ch->move < ch->max_move/10 )
skills.c:    chance = ris_save( victim, ch->level, RIS_PARALYSIS );
skills.c:  	  ch->move -= ch->max_move/10;
skills.c:	  ch->move -= ch->max_move/15;
skills.c:    if ( ch->fighting )
skills.c:    if ( ch->pcdata->condition[COND_BLOODTHIRST] < 10 )
skills.c:	obj_to_room( obj, ch->in_room );
skills.c:	if ( ch->mount )
skills.c:	  dam = number_range( 1, ch->level );
skills.c:	  &&  ch->fighting
skills.c:	  &&  ch->pcdata->condition[COND_BLOODTHIRST] < (10 + ch->level) )
skills.c:	     UMIN( number_range(1, (ch->level+victim->level / 20) + 3 ),
skills.c:	     (10 + ch->level) - ch->pcdata->condition[COND_BLOODTHIRST] ) );
skills.c:            if ( ch->pcdata->condition[COND_FULL] <= 37 )
skills.c:	  &&  ch->fighting
skills.c:	  &&  ch->pcdata->condition[COND_BLOODTHIRST] < (10 + ch->level) )
skills.c:    &&   ch->level < skill_table[gsn_disarm]->skill_level[ch->class] )
skills.c:    percent = number_percent( ) + victim->level - ch->level
skills.c:    if ( ch->mount ) {
skills.c:    if ( IS_PKILL(ch) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
skills.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
skills.c:    ||   victim->level >= ch->level + 15
skills.c:    ||  (IS_NPC(victim) && saves_spell_staff( ch->level, victim ))
skills.c:    if ( ch->mount ) {
skills.c:        if ( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:    if ( ch->mount )
skills.c:    for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
skills.c:/*        for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:          if ( IS_NPC(gch) && IS_AWAKE(gch) && xIS_SET(gch->act, ACT_GUARDIAN ) )
skills.c:	&&   pexit_rev->to_room == ch->in_room )
skills.c:    if ( ch->mount )
skills.c:	af.duration  = ch->level * DUR_CONV;
skills.c:    if ( ch->mount )
skills.c:	xREMOVE_BIT(ch->affected_by, AFF_HIDE);
skills.c:	xSET_BIT(ch->affected_by, AFF_HIDE);
skills.c:    xREMOVE_BIT  ( ch->affected_by, AFF_HIDE		);
skills.c:    xREMOVE_BIT  ( ch->affected_by, AFF_INVISIBLE	);
skills.c:    xREMOVE_BIT  ( ch->affected_by, AFF_SNEAK		);
skills.c:        if (IS_AFFECTED(ch, AFF_CHARM) && ch->master && !IS_NPC(ch->master)) {
skills.c:          location = get_room_index( ch->master->pcdata->memorize[0] );
skills.c:        location = get_room_index( ch->pcdata->memorize[0] );
skills.c:    if ( !location && !IS_NPC(ch) && ch->pcdata->clan )
skills.c:      location = get_room_index( ch->pcdata->clan->recall );
skills.c:    if ( !IS_NPC( ch ) && !location && ch->level >= 5
skills.c:   /* &&   IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) */ )
skills.c:       location = get_room_index(race_table[ch->race]->race_recall);
skills.c:    if ( ch->in_room == location )
skills.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) )
skills.c:	    lose = (exp_level(ch, ch->level+1) - exp_level(ch, ch->level)) * 0.1;
skills.c:	    if ( ch->desc )
skills.c:    if ( ch->mount )
skills.c:	char_from_room( ch->mount );
skills.c:	char_to_room( ch->mount, location );
skills.c:    if ( ch->mount )
skills.c:    &&   ch->level < skill_table[gsn_mount]->skill_level[ch->class] )
skills.c:    if ( ch->mount )
skills.c:	ch->mount = victim;
skills.c:	ch->position = POS_MOUNTED;
skills.c:    if ( (victim = ch->mount) == NULL )
skills.c:	ch->mount = NULL;
skills.c:	ch->position = POS_STANDING;
skills.c:	ch->mount = NULL;
skills.c:	ch->position = POS_SITTING;
skills.c:    if ( !chance( victim, chances + victim->level - ch->level ) )
skills.c:         && !IS_SET( ch->pcdata->flags, PCFLAG_GAG) )  /* SB */   
skills.c:    if ( !chance( victim, chances + victim->level - ch->level ) )
skills.c:    if ( !IS_NPC(ch) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG) ) 
skills.c:    if ( !chance( victim, chances + victim->level - ch->level ) )
skills.c:    if ( !IS_NPC(ch) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:  && ch->level < skill_table[gsn_poison_weapon]->skill_level[ch->class] )
skills.c:    if ( ch->fighting )
skills.c:    for ( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:    for ( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:    && ( (get_curr_dex( ch ) < 17) || ch->pcdata->condition[COND_DRUNK] > 0 ) )
skills.c:	damage( ch, ch, ch->level, gsn_poison_weapon );
skills.c:    obj->timer = UMIN( obj->level, ch->level );
skills.c:    &&   ch->level < skill_table[gsn_scribe]->skill_level[ch->class] )
skills.c:     100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:    if ( !IS_NPC(ch) && ch->mana < mana )
skills.c:	ch->mana -= (mana / 2);
skills.c:       ch->mana -= (mana / 2);
skills.c:     scroll->value[0] = ch->level;
skills.c:     ch->mana -= mana;
skills.c:    &&   ch->level < skill_table[gsn_brew]->skill_level[ch->class] )
skills.c:     100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->class] ) );
skills.c:    if ( !IS_NPC(ch) && ch->mana < mana )
skills.c:    for ( fire = ch->in_room->first_content; fire; 
skills.c:	ch->mana -= (mana / 2);
skills.c:       ch->mana -= (mana / 2);
skills.c:     potion->value[0] = ch->level;
skills.c:     ch->mana -= mana;
skills.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
skills.c:    if ( ch->mount )
skills.c:    if ( !ch->fighting )
skills.c:  if ( !ch->fighting )
skills.c:  af.duration = number_range(ch->level/5, ch->level*2/5);
skills.c:  if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE) )
skills.c:  if ( !ch->in_room->first_person )
skills.c:  for ( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:    vch_next = vch->next_in_room;
skills.c:    if ( ++nvict > ch->level / 5 )
skills.c:  ch->move = UMAX(0, ch->move-nvict*3+nhit);
skills.c:	if (/* ( !IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) || */ch->level - victim->level > 10
skills.c:    /*	|| !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) ) */
skills.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
skills.c:    was_in_room = ch->in_room;
skills.c:    if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:    if ( ch->level < 50 ) --max_dist;
skills.c:    if ( ch->level < 40 ) --max_dist;
skills.c:    if ( ch->level < 30 ) --max_dist;
skills.c:	&&   ch->level < LEVEL_GREATER )
skills.c:	send_to_char( ch->in_room->name, ch );
skills.c:	show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:	show_char_to_char( ch->in_room->first_person, ch );
skills.c:	switch( ch->in_room->sector_type )
skills.c:	if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:    was_in_room = ch->in_room;
skills.c:    if ( ch->level < 50 ) --max_dist;
skills.c:    if ( ch->level < 40 ) --max_dist;
skills.c:    if ( ch->level < 30 ) --max_dist;
skills.c:	&&   ch->level < LEVEL_GREATER )
skills.c:	switch( ch->in_room->sector_type )
skills.c:	if ( (pexit=get_exit(ch->in_room, dir)) == NULL )
skills.c:    for ( obj = ch->last_carrying; obj; obj = obj->prev_content )
skills.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE) )
skills.c:	    global_retcode = spell_attack( dt, ch->level, ch, victim );
skills.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_PRIVATE)
skills.c:	||   IS_SET(ch->in_room->room_flags, ROOM_SOLITARY) )
skills.c:	if ( ch->in_room->tunnel > 0 )
skills.c:	    for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:	    if ( count >= ch->in_room->tunnel )
skills.c:	if ( IS_NPC(vch) && xIS_SET(vch->act, ACT_STAY_AREA)
skills.c:	&&   ch->in_room->area != vch->in_room->area) )
skills.c:	if ( IS_SET(vch->in_room->room_flags, ROOM_NOMISSILE) )
skills.c:	if ( vch->num_fighting > max_fight(vch) )
skills.c:	 xIS_SET(ch->act, PLR_NICE ) )
skills.c:    was_in_room = ch->in_room;
skills.c:	    for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:	if ( victim && ch->in_room == victim->in_room )
skills.c:		obj_to_room(projectile, ch->in_room);
skills.c:	if ( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:		obj_to_room(projectile, ch->in_room);
skills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:  for ( throw_obj = ch->last_carrying; throw_obj;
skills.c:  if ( ch->fighting )
skills.c:    victim = ch->fighting;
skills.c:  &&   ch->level < skill_table[gsn_slice]->skill_level[ch->class] )
skills.c:      damage(ch, ch, ch->level, gsn_slice);
skills.c:          ch->style == STYLE_BERSERK    ? "&Rberserk"    :
skills.c:          ch->style == STYLE_AGGRESSIVE ? "&Raggressive" :
skills.c:          ch->style == STYLE_DEFENSIVE  ? "&Ydefensive"  :
skills.c:          ch->style == STYLE_EVASIVE    ? "&Yevasive"    :
skills.c:      if( ch->level < skill_table[gsn_style_evasive]->skill_level[ch->class])
skills.c:	  if(ch->fighting){
skills.c:             ch->position = POS_EVASIVE;
skills.c:          ch->style = STYLE_EVASIVE;
skills.c:      if( ch->level < skill_table[gsn_style_defensive]->skill_level[ch->class])
skills.c:	  if(ch->fighting) {
skills.c:             ch->position = POS_DEFENSIVE;
skills.c:          ch->style = STYLE_DEFENSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_standard]->skill_level[ch->class])
skills.c:	  if(ch->fighting) {
skills.c:             ch->position = POS_FIGHTING;
skills.c:          ch->style = STYLE_FIGHTING;
skills.c:      if( ch->level < skill_table[gsn_style_aggressive]->skill_level[ch->class])
skills.c:	  if(ch->fighting) {
skills.c:             ch->position = POS_AGGRESSIVE;
skills.c:          ch->style = STYLE_AGGRESSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_berserk]->skill_level[ch->class])
skills.c:	  if(ch->fighting) {
skills.c:             ch->position = POS_BERSERK;
skills.c:          ch->style = STYLE_BERSERK;
skills.c:   else if ( ch->morph && ch->morph->morph && ch->morph->morph->skills &&
skills.c:             ch->morph->morph->skills[0] != '\0' &&
skills.c:             is_name( skill_table[gsn]->name, ch->morph->morph->skills ) && 
skills.c:   if ( ch->morph && ch->morph->morph && ch->morph->morph->no_skills &&
skills.c:             ch->morph->morph->no_skills[0] != '\0' &&
skills.c:             is_name( skill_table[gsn]->name, ch->morph->morph->no_skills ) )
skills.c:   if ( IS_NPC(ch) || ch->level < skill_table[gsn_cook]->skill_level[ch->class])
skills.c:   for ( fire = ch->in_room->first_content; fire; fire = fire->next_content )
special.c:    if ( ch->position <= POS_SLEEPING )
special.c:    if ( ch->fighting || ch->fearing
special.c:    ||  !ch->hating || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:    if ( ch->hunting )
special.c:    one_argument( ch->hating->name, name );
special.c:	if ( !str_cmp( ch->hating->name, victim->name ) )
special.c:    if ( ch->in_room == victim->in_room )
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:		ch->name,spell_name);
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, NULL );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	spell_smaug( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:	spell_smaug( skill_lookup( "bless" ), ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	spell_smaug( skill_lookup( "refresh" ), ch->level, ch, victim );
special.c:        spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, victim );
special.c:        spell_remove_curse( skill_lookup( "remove curse" ), ch->level, ch, victim );
special.c:		spell_smaug( skill_lookup( "restore mana" ), ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn]->spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:    char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:    char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:    for ( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:    if ( victim && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:    for ( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:    if ( ch->fighting )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	move_char( ch, get_exit( ch->in_room, path[pos] - '0' ), 0 );
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:    if ( ch->position != POS_FIGHTING
special.c:       && ch->position !=  POS_EVASIVE
special.c:       && ch->position !=  POS_DEFENSIVE
special.c:       && ch->position !=  POS_AGGRESSIVE
special.c:       && ch->position !=  POS_BERSERK
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim );
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
special.c:	    maxgold = ch->level * ch->level * 1000;
special.c:	    	 * number_range( 1, URANGE(2, ch->level/4, 10) ) / 100;
special.c:	    ch->gold     += 9 * gold / 10;
special.c:	    if ( ch->gold > maxgold )
special.c:		boost_economy( ch->in_room->area, ch->gold - maxgold/2 );
special.c:		ch->gold = maxgold/2;
stat_obj.c:    if (!ch->desc) {
suicide.c:  if (strcmp (crypt (arg, ch->pcdata->pwd), ch->pcdata->pwd))
suicide.c:      do_destroy (ch, ch->name);
suicide.c:      sprintf (buf, "%s has committed suicide.", ch->name);
track.c:    if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_track] <= 0 )
track.c:    maxdist = 100 + ch->level * 30;
track.c:    dir = find_first_step(ch->in_room, vict->in_room, maxdist);
track.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:    if (!ch || !ch->hunting)
track.c:	if ( ch->hunting->who == tmp )
track.c:    if ( ch->in_room == ch->hunting->who->in_room )
track.c:	if ( ch->fighting )
track.c:	found_prey( ch, ch->hunting->who );
track.c:    ret = find_first_step(ch->in_room, ch->hunting->who->in_room, 500 + ch->level * 25);
track.c:	if ( (pexit=get_exit(ch->in_room, ret)) == NULL )
track.c:	if ( !ch->hunting )
track.c:	    if ( !ch->in_room )
track.c:		bug( "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.",
track.c:		    ch->pIndexData->vnum, ch->name );
track.c:	if ( ch->in_room == ch->hunting->who->in_room )
track.c:	    found_prey(ch, ch->hunting->who);
track.c:	    if ( (vch=scan_for_victim(ch, pexit, ch->hunting->name)) != NULL )
track.c:		if ( !mob_fire(ch, ch->hunting->who->name) )
update.c:	title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:	if (!IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS))
update.c:		    class_table[ch->class]->hp_min,
update.c:		    class_table[ch->class]->hp_max );
update.c:    add_mana = class_table[ch->class]->fMana ? number_range(2, (2*(get_curr_int(ch)+get_curr_wis(ch)))/8) : 0;
update.c:	add_hp    += race_table[ch->race]->hit;
update.c:    add_mana  += race_table[ch->race]->mana;
update.c:    ch->max_hit 	+= add_hp;
update.c:    ch->max_mana	+= add_mana;
update.c:    ch->max_move	+= add_move;
update.c:    ch->practice	+= add_prac;
update.c:	xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:    if ( ch->level == LEVEL_PCAVATAR ) {
update.c:	sprintf( buf, "%s has just become an Avatar!", ch->name );
update.c:    if ( ch->level == LEVEL_AVATAR )
update.c:	sprintf( buf, "%s has just become a Demi-God!", ch->name );
update.c:    if ( ch->level < LEVEL_IMMORTAL )
update.c:	  add_hp,	ch->max_hit,
update.c:	  1,	        ch->level + 10,
update.c:	  add_move,	ch->max_move,
update.c:	  add_prac,	ch->practice
update.c:	  add_hp,	ch->max_hit,
update.c: 	  add_mana,	ch->max_mana,
update.c:	  add_move,	ch->max_move,
update.c:	  add_prac,	ch->practice
update.c:    if ( IS_NPC(ch) || ch->level >= LEVEL_AVATAR )
update.c:    if(modgain>0 /*&& IS_PKILL(ch)*/ && ch->level<33){
update.c:       if(ch->level<=9){
update.c:       if(ch->level<=18 && ch->level>=10){
update.c:       if(ch->level<=27 && ch->level>=19){
update.c:       if(ch->level<=28 && ch->level>=36){
update.c:    modgain *= ( race_table[ch->race]->exp_multiplier/100.0);
update.c:       if( ch->exp + modgain < exp_level(ch, ch->level)){
update.c:          modgain = exp_level(ch, ch->level) - ch->exp;
update.c:    	exp_level(ch, ch->level+2) - exp_level(ch, ch->level+1));
update.c:    ch->exp = UMAX( 0, ch->exp + modgain );
update.c:    if (NOT_AUTHED(ch) && ch->exp >= exp_level(ch, ch->level+1))
update.c:	ch->exp = (exp_level(ch, (ch->level+1)) - 1);
update.c:    while ( ch->level < LEVEL_AVATAR && ch->exp >= exp_level(ch, ch->level+1))
update.c:	ch_printf( ch, "You have now obtained experience level %d!\n\r", ++ch->level );
update.c:	if (!IS_SET( ch->pcdata->flags, PCFLAG_ANONYMOUS)) {
update.c:		sprintf( buf, "%s has achieved level %d!", ch->name, ch->level );
update.c:	gain = ch->level * 3 / 2;
update.c:	gain = UMIN( 5, ((ch->level + get_curr_con(ch))/ 8) );
update.c:	switch ( ch->position )
update.c:	case POS_SLEEPING: gain += get_curr_con(ch) * 2.0; if(ch->on) gain += 5; break;
update.c:	case POS_RESTING:  gain += get_curr_con(ch) * 1.25;if(ch->on) gain += 2; break;
update.c:            if ( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:	    if ( ch->pcdata->condition[COND_BLOODTHIRST] >= (8 + ch->level) )
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:	gain = ch->level;
update.c:	gain = UMIN( 5, ((ch->level + get_curr_int(ch)) / 8) );
update.c:	if ( ch->position < POS_SLEEPING )
update.c:	switch ( ch->position )
update.c:	case POS_SLEEPING: gain += get_curr_int(ch) * 3.25; if(ch->on) gain += 5;	break;
update.c:	case POS_RESTING:  gain += get_curr_int(ch) * 1.75; if(ch->on) gain += 2;	break;
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:	gain = ch->level;
update.c:	gain = UMAX( 15, ((2*ch->level + get_curr_dex(ch)) / 8) );
update.c:	switch ( ch->position )
update.c:	case POS_SLEEPING: gain += get_curr_dex(ch) * 4.5;if(ch->on) gain+=5;	break;
update.c:	case POS_RESTING:  gain += get_curr_dex(ch) * 2.5;if(ch->on) gain+=2;	break;
update.c:            if ( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:	    if ( ch->pcdata->condition[COND_BLOODTHIRST] >= (8 + ch->level) )
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:    if (value == 0 || IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL || NOT_AUTHED(ch))
update.c:	if ((ch->desc) && ((ch->desc->connected == CON_PLAYING) && (ch->desc->idle > 1200 && !xIS_SET(ch->act, PLR_AFK))))
update.c:	condition				= ch->pcdata->condition[iCond];
update.c:	  ch->pcdata->condition[iCond]	= URANGE(0, condition+value, (10 + ch->level));
update.c:	  ch->pcdata->condition[iCond]	= URANGE(0, condition+value, 48);
update.c:    if ( ch->pcdata->condition[iCond] == 0 )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR)
update.c:			sprintf(buf, "gain_condition bloodthirst update for non blood ch: %s", ch->name);
update.c:	    retcode = damage(ch, ch, ch->max_hit / 20, TYPE_UNDEFINED);
update.c:    if ( ch->pcdata->condition[iCond] == 1 )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR )
update.c:    if ( ch->pcdata->condition[iCond] == 2 )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR )
update.c:    if ( ch->pcdata->condition[iCond] == 3 )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR && ch->race != RACE_VAMPIRE )
update.c:          if ( ch->level < LEVEL_AVATAR )
update.c:		if ((!ch->pcdata) && !(xIS_SET(ch->act, ACT_IS_NPC))) {
update.c:			bug( "Mob %d in room %d was not set with the NPC flag!  Fixing...", ch->pIndexData->vnum, ch->in_room->vnum);
update.c:			xSET_BIT( ch->act, ACT_IS_NPC );
update.c:	if ( ch == first_char && ch->prev ) {
update.c:		ch->prev = NULL;
update.c:	gch_prev = ch->prev;
update.c:		ch->name );
update.c:	    ch->prev = NULL;
update.c:	if ( !ch->in_room
update.c:        if ( ch->pIndexData->vnum == 5 && !IS_AFFECTED(ch, AFF_CHARM) )
update.c:	  if(ch->in_room->first_person)
update.c:	if ( !xIS_SET( ch->act, ACT_RUNNING )
update.c:	&&   !xIS_SET( ch->act, ACT_SENTINEL )
update.c:	&&   !ch->fighting && ch->hunting )
update.c:	  sprintf( buf, "%s hunting %s from %s.", ch->name,
update.c:	  	ch->hunting->name,
update.c:		ch->in_room->name );
update.c:	if ( !xIS_SET( ch->act, ACT_RUNNING )
update.c:	&&    ch->spec_fun )
update.c:	    if ( (*ch->spec_fun) ( ch ) )
update.c:	if ( HAS_PROG( ch->pIndexData, SCRIPT_PROG ) )
update.c:	if ( ch->position != POS_STANDING )
update.c:	if ( xIS_SET(ch->act, ACT_MOUNTED ) )
update.c:	    if ( xIS_SET(ch->act, ACT_AGGRESSIVE)
update.c:	    ||   xIS_SET(ch->act, ACT_META_AGGR) )
update.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE )
update.c:	&&  (xIS_SET(ch->act, ACT_AGGRESSIVE) || xIS_SET(ch->act, ACT_META_AGGR)) )
update.c:        if(! ch->in_room->area)
update.c:			ch->in_room->vnum,ch->name);
update.c:                if(ch->was_in_room)
update.c:		   bug("Was in room %d",ch->was_in_room->vnum);
update.c:	if ( ch->in_room->area->nplayer > 0 )
update.c:	    if ( ch->position < POS_STANDING )
update.c:	if ( ch->position < POS_STANDING )
update.c:					if ((obj->cost > big_obj->cost) && (ch->gold >= big_obj->cost)) 
update.c:					if (big_obj == ch->last_carrying)
update.c:				for (obj=ch->last_carrying; obj; obj=obj->next_content)
update.c:	if ( ch->in_room->first_content
update.c:		if (!xIS_SET(ch->act, ACT_SCAVENGER) && number_percent() < 70) {
update.c:		    for ( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:			|| (ch->in_room->area->weather->precip > 10))
update.c:				if (ch->in_room->area->weather->precip > 10)
update.c:	if (ch->last_carrying && find_keeper(ch)!=ch)
update.c:	if ( !xIS_SET(ch->act, ACT_RUNNING)
update.c:	&&   !xIS_SET(ch->act, ACT_SENTINEL)
update.c:	&&   !xIS_SET(ch->act, ACT_PROTOTYPE)
update.c:	&& ( pexit = get_exit(ch->in_room, door) ) != NULL
update.c:	&& ( !xIS_SET(ch->act, ACT_STAY_AREA) || pexit->to_room->area == ch->in_room->area ) )
update.c:	    if ( retcode != rNONE || xIS_SET(ch->act, ACT_SENTINEL)
update.c:	    ||    ch->position < POS_STANDING )
update.c:	if ( ch->hit < ch->max_hit / 2
update.c:	&& ( pexit = get_exit(ch->in_room,door) ) != NULL
update.c:	    for ( rch  = ch->in_room->first_person;
update.c:		  rch  = rch->next_in_room )
update.c:			  sprintf( buf, "Get away from me, %s!", rch->name );
update.c:			  sprintf( buf, "Leave me be, %s!", rch->name );
update.c:			  sprintf( buf, "%s is trying to kill me!  Help!", rch->name );
update.c:			  sprintf( buf, "Someone save me from %s!", rch->name );
update.c:	if ( ch == first_char && ch->prev )
update.c:	    ch->prev = NULL;
update.c:	gch_prev = ch->prev;
update.c:	    bug( "char_gains: ch->prev->next != ch", 0 );
update.c:	if ( ch->position >= POS_STUNNED )
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:	if ( ch == first_char && ch->prev )
update.c:	    ch->prev = NULL;
update.c:	gch_prev = ch->prev;
update.c:	    bug( "char_update: ch->prev->next != ch", 0 );
update.c:	&& ( !ch->desc || ch->desc->connected == CON_PLAYING )
update.c:	&&    ch->level >= 2
update.c:	&&    current_time - ch->save_time > (sysdata.save_frequency*60) )
update.c:	if ( ch->position >= POS_STUNNED )
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:	if ( ch->position == POS_STUNNED )
update.c:      	if ( ch->morph ) {
update.c:           if ( ch->morph->timer > 0 )
update.c:            	    ch->morph->timer--;
update.c:           	    if ( ch->morph->timer == 0 )
update.c:        if ( !IS_NPC(ch) && ch->pcdata->nuisance )
update.c:	    if ( ch->pcdata->nuisance->flags < MAX_NUISANCE_STAGE )
update.c:	     temp = ch->pcdata->nuisance->max_time-ch->pcdata->nuisance->time;
update.c: 	     temp *= ch->pcdata->nuisance->flags;
update.c:	     temp += ch->pcdata->nuisance->time;
update.c:		    ch->pcdata->nuisance->flags++;
update.c:	if ( !IS_NPC(ch) && ch->level < LEVEL_IMMORTAL )
update.c:		if ( --obj->value[2] == 0 && ch->in_room )
update.c:		    ch->in_room->light -= obj->count;
update.c:		    if (ch->in_room->light < 0 )
update.c:				ch->in_room->light=0;
update.c:	    if ( ++ch->timer >= 12 ) 
update.c:		if ( ch->timer == 12 && ch->in_room )
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if ( ch->fighting )
update.c:	    if ( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:		worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK]/8 );
update.c:	    if ( ch->pcdata->condition[COND_FULL] > 1 )
update.c:		switch( ch->position )
update.c:	    if ( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:		switch( ch->position )
update.c:	    gain_condition( ch, COND_FULL,  -1 + race_table[ch->race]->hunger_mod );
update.c:        if ( IS_VAMPIRE(ch) && ch->level >= 10 )
update.c:	    if ( CAN_PKILL( ch ) && ch->pcdata->condition[COND_THIRST] - 9 > 10 )
update.c:	    if ( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:		value = ((0 - ch->pcdata->nuisance->flags)*ch->pcdata->nuisance->power);
update.c:	    if ( ch->in_room )
update.c:	      switch( ch->in_room->sector_type )
update.c:		    gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod);  break;
update.c:		    gain_condition( ch, COND_THIRST, -3 + race_table[ch->race]->thirst_mod);  break;
update.c:			gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod);  break;
update.c:      if ( !IS_NPC(ch) && !IS_IMMORTAL(ch) && ch->pcdata->release_date > 0 &&
update.c:           ch->pcdata->release_date <= current_time )
update.c:         if ( ch->pcdata->clan )
update.c:          location = get_room_index( ch->pcdata->clan->recall );
update.c:          location = ch->in_room;
update.c:         STRFREE( ch->pcdata->helled_by );
update.c:         ch->pcdata->release_date = 0;
update.c:		ch->mental_state = URANGE( 20, ch->mental_state
update.c:	    if ( ch->position == POS_INCAP )
update.c:	    if ( ch->position == POS_MORTAL )
update.c:		for ( paf = ch->first_affect; paf; paf = paf_next )
update.c:			    if ( (*skill->spell_fun)(paf->modifier, ch->level, ch, ch) == rCHAR_DIED
update.c:		    xREMOVE_BIT(ch->affected_by, AFF_RECURRINGSPELL);
update.c:     if(ch->alignment<race_table[ch->race]->minalign)
update.c:     if(ch->alignment>race_table[ch->race]->maxalign)
update.c:		if ( ch->mental_state >= 30 )
update.c:		switch( (ch->mental_state+5) / 10 )
update.c:	    if ( ch->mental_state <= -30 )
update.c:		switch( (abs(ch->mental_state)+5) / 10 )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( (ch->position == POS_STANDING
update.c:			   ||    ch->position < POS_FIGHTING)
update.c:			   &&    number_percent()+10 < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( (ch->position == POS_STANDING
update.c:			   ||    ch->position < POS_FIGHTING)
update.c:			   &&   (number_percent()+20) < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_SLEEPING )
update.c:			   if ( ch->position < POS_SITTING
update.c:			   &&  (number_percent()+30) < abs(ch->mental_state) )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:			if ( ch->position > POS_RESTING )
update.c:	    if ( ch->timer > 24 )
update.c:	ch_next = ch->next;
update.c:	    if ( xIS_SET(ch->act, ACT_RUNNING) )
update.c:		if ( !xIS_SET(ch->act, ACT_SENTINEL)
update.c:		&&   !ch->fighting && ch->hunting )
update.c:		if ( ch->spec_fun )
update.c:		    if ( (*ch->spec_fun) ( ch ) )
update.c:		if ( !xIS_SET(ch->act, ACT_SENTINEL)
update.c:		&&   !xIS_SET(ch->act, ACT_PROTOTYPE)
update.c:		&& ( pexit = get_exit(ch->in_room, door) ) != NULL
update.c:		&& ( !xIS_SET(ch->act, ACT_STAY_AREA)
update.c:		||   pexit->to_room->area == ch->in_room->area ) )
update.c:		    if ( retcode != rNONE || xIS_SET(ch->act, ACT_SENTINEL)
update.c:		    ||    ch->position < POS_STANDING )
update.c:	    if ( ch->mount
update.c:	    &&   ch->in_room != ch->mount->in_room )
update.c:		xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:		ch->mount = NULL;
update.c:		ch->position = POS_STANDING;
update.c:	    if ( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:	    || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:		    if ( ch->level < LEVEL_IMMORTAL )
update.c:			dam = number_range( ch->max_hit / 100, ch->max_hit / 50 );
update.c:	    if ( ch->in_room
update.c:	    && (( ch->in_room->sector_type == SECT_WATER_NOSWIM )
update.c:	    ||  ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:		&& !ch->mount )
update.c:		    for ( obj = ch->first_carrying; obj; obj = obj->next_content )
update.c:			if ( ch->level < LEVEL_IMMORTAL )
update.c:			    if ( ch->move > 0 )
update.c:				mov = number_range( ch->max_move / 20, ch->max_move / 5 );
update.c:				if ( ch->move - mov < 0 )
update.c:				    ch->move = 0;
update.c:				    ch->move -= mov;
update.c:				dam = number_range( ch->max_hit / 20, ch->max_hit / 5 );
update.c:	    if ( !ch->desc )
update.c:		for ( wch = ch->in_room->first_person; wch; wch = wch_next )
update.c:		    wch_next	= wch->next_in_room;
update.c:		    ||   wch->fighting
update.c:		    || (xIS_SET(wch->act, ACT_WIMPY) && IS_AWAKE(ch) )
update.c:		    if ( (!xIS_SET(wch->act, ACT_AGGRESSIVE)
update.c:		    &&    !xIS_SET(wch->act, ACT_META_AGGR))
update.c:		    ||    xIS_SET(wch->act, ACT_MOUNTED)
update.c:		    ||    IS_SET(wch->in_room->room_flags, ROOM_SAFE ) )
update.c:        if ( IS_NPC( wch ) && wch->mpactnum > 0
update.c:	    && wch->in_room->area->nplayer > 0 )
update.c:	    for ( tmp_act = wch->mpact; tmp_act;
update.c:	    for ( tmp_act = wch->mpact; tmp_act; tmp_act = tmp2_act )
update.c:            wch->mpactnum = 0;
update.c:            wch->mpact    = NULL;
update.c:	if ( !char_died(wch) && wch->mpactnum > 0 )
update.c:	    while ( (tmp_act = wch->mpact) != NULL )
update.c:		wch->mpact = tmp_act->next;
update.c:	    wch->mpactnum = 0;
update.c:	    wch->mpact    = NULL;
update.c:	||   wch->level >= LEVEL_IMMORTAL
update.c:	||  !wch->in_room )
update.c:	for ( ch = wch->in_room->first_person; ch; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||   ch->fighting
update.c:	    ||   (xIS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch) )
update.c:	    if ( (!xIS_SET(ch->act, ACT_AGGRESSIVE)
update.c:	    &&    !xIS_SET(ch->act, ACT_META_AGGR))
update.c:	    ||     xIS_SET(ch->act, ACT_MOUNTED)
update.c:	    ||     IS_SET(ch->in_room->room_flags, ROOM_SAFE ) )
update.c:	    for ( vch = wch->in_room->first_person; vch; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		if ( (!IS_NPC(vch) || xIS_SET(ch->act, ACT_META_AGGR)
update.c:		||    xIS_SET(vch->act, ACT_ANNOYING))
update.c:		&&   vch->level < LEVEL_IMMORTAL
update.c:		&&   (!xIS_SET(ch->act, ACT_WIMPY) || !IS_AWAKE(vch) )
update.c:	    if ( IS_NPC(ch) && xIS_SET(ch->attacks, ATCK_BACKSTAB ) )
update.c:		if ( !ch->mount
update.c:		    ||   number_percent( )+5 < ch->level )
update.c:    if ( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:    drunk = ch->pcdata->condition[COND_DRUNK];
update.c:    position = ch->position;
update.c:    ch->position = POS_STANDING;
update.c:	for ( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:	check_social( ch, "puke", (rvch ? rvch->name : "") );
update.c:    ch->position = position;
update.c:    if ( ch->mental_state >= 30 && number_bits(5 - (ch->mental_state >= 50) - (ch->mental_state >= 75)) == 0 )
update.c:	switch( number_range( 1, UMIN(21, (ch->mental_state+5) / 5)) )
update.c:    for ( vch = first_char; vch; vch = vch->next )
websvr.c:    if(change_web_pass(ch->name, buf))
